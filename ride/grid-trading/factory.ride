{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let separator = "__"

func mustAddress(i: Invocation, address: Address) = {
  i.caller == address || throw()
}

func mustThis(i: Invocation) = {
  mustAddress(i, this)
}

let kServicePublicKey = "%s__servicePublicKey"
let kBotPublicKey = "%s__botPublicKey"

# account keys
let kFactoryPublicKey = "%s__factoryPublicKey"
let kOwnerPublicKey = "%s__ownerPublicKey"
let kCreatorPublicKey = "%s__creatorPublicKey"

let kAccountScript = "%s__accountScriptHash"
func accountScript() = this.getBinary(
  kAccountScript
).valueOrErrorMessage("account script is not set")

let kRewardAmount = "%s__rewardAmount"
func rewardAmount() = this.getInteger(
  kRewardAmount
).valueOrErrorMessage("reward amount is not set")

func kRequestCompleted(requestId: String) = {
  ["%s%s", requestId, "completed"].makeString(separator)
}
func requestCompleted(requestId: String) = {
  this.getBoolean(
    kRequestCompleted(requestId)
  ).valueOrErrorMessage("request is not found")
}

func kRequestOwner(requestId: String) = {
  ["%s%s", requestId, "owner"].makeString(separator)
}
func requestOwner(requestId: String) = {
  this.getBinary(
    kRequestOwner(requestId)
  ).valueOrErrorMessage("request is not found")
}

# can be updated by voting
let serviceAddress = addressFromPublicKey(this.getBinaryValue(kServicePublicKey))
let botPublicKey = this.getBinaryValue(kBotPublicKey)

@Callable(i)
func init(
  servicePublicKey: ByteVector,
  botPublicKey: ByteVector,
  accountScript: ByteVector,
  rewardAmount: Int
) = {
  strict checkCaller = i.mustThis()

  ([
    BinaryEntry(kServicePublicKey, servicePublicKey),
    BinaryEntry(kBotPublicKey, botPublicKey),
    BinaryEntry(kAccountScript, accountScript),
    IntegerEntry(kRewardAmount, rewardAmount)
  ], unit)
}

# called by user
# additional fee in payment
@Callable(i)
func request(amountAssetId: ByteVector, priceAssetId: ByteVector) = {
  let requestId = sha256(i.caller.bytes + amountAssetId + priceAssetId).toBase58String()

  strict checks = [
    i.payments.size() == 1 || throw("1 payment is required"),
    i.payments[0].assetId == unit || throw("invalid asset"),
    i.payments[0].amount == rewardAmount() || throw("invalid amount"),
    this.getBoolean(kRequestCompleted(requestId)) == unit || throw("request exists")
  ]

  ([
    BooleanEntry(kRequestCompleted(requestId), false),
    BinaryEntry(kRequestOwner(requestId), i.callerPublicKey)
  ], unit)
}

# called by account script
# additional fee is sent to recipient
@Callable(i)
func complete(requestId: String, accountPublicKey: ByteVector) = {
  let accountAddress = addressFromPublicKey(accountPublicKey)

  strict checks = [
    !requestCompleted(requestId) || throw("request is already completed"),
    match scriptHash(accountAddress) {
      case b: ByteVector => b == blake2b256_32Kb(accountScript())
      case _ => false
    } || throw("invalid script"),
    match accountAddress.getBinary(kFactoryPublicKey) {
      case b: ByteVector => addressFromPublicKey(b) == this
      case _ => false
    } || throw("invalid factory public key"),
    match accountAddress.getBinary(kOwnerPublicKey) {
      case b: ByteVector => b == requestOwner(requestId)
      case _ => false
    } || throw("invalid owner public key")
  ]

  let creatorPublicKey = accountAddress.getBinary(
    kCreatorPublicKey
  ).valueOrErrorMessage("creator public key is not set")
  let creatorAddress = addressFromPublicKey(creatorPublicKey)
  let result = accountAddress.invoke("approve", [], [])

  ([
    BooleanEntry(kRequestCompleted(requestId), true),
    ScriptTransfer(creatorAddress, rewardAmount(), unit)
  ], result)
}