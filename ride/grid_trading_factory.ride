{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# IMPORT common.lib.ride #-}

let wavesString = "WAVES"
let queueItemSize = 32

func parseAssetId(input: String) = {
  if (input == wavesString) then unit else input.fromBase58String()
}

func assetIdToString(input: ByteVector|Unit) = {
  if (input == unit) then wavesString else input.value().toBase58String()
}

let kServicePublicKey = "%s__servicePublicKey"
let kBotPublicKey = "%s__botPublicKey"

let kAccountScript = "%s__accountScript"
func accountScript() = this.getBinary(
  kAccountScript
).valueOrErrorMessage("account script is not set")

let kRewardAmount = "%s__rewardAmount"
func rewardAmount() = this.getInteger(
  kRewardAmount
).valueOrErrorMessage("reward amount is not set")

let REQUEST_STATUS_EMPTY = 0
let REQUEST_STATUS_READY = 1
func kRequestStatus(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "status"].makeString(separator)
}

func kAccountCreatorPublicKey(accountAddress: Address) = {
  ["%s%s", accountAddress.toString(), "creatorPublicKey"].makeString(separator)
}
func kRequestOwnerPublicKey(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "ownerPublicKey"].makeString(separator)
}
func kRequestAmountAssetId(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "amountAssetId"].makeString(separator)
}
func kRequestPriceAssetId(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "priceAssetId"].makeString(separator)
}
func kRequestIdToAccountPublicKey(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "requestIdToAccountPublicKey"].makeString(separator)
}
func kAccountAddressToRequestId(accountAddress: Address) = {
  ["%s%s", accountAddress.toString(), "accountAddressToRequestId"].makeString(separator)
}

func kRequestsQueue() = {
  ["%s", "requestsQueue"].makeString(separator)
}
func requestsQueue() = this.getBinary(kRequestsQueue()).valueOrElse(base58'')

func kAccountsQueue() = {
  ["%s", "accountsQueue"].makeString(separator)
}
func accountsQueue() = this.getBinary(kAccountsQueue()).valueOrElse(base58'')

func kPairAllowed(amountAssetId: ByteVector|Unit, priceAssetId: ByteVector|Unit) = {
  ["%s%s%s", assetIdToString(amountAssetId), assetIdToString(priceAssetId), "pairAllowed"].makeString(separator)
}
func pairAllowed(amountAssetId: ByteVector|Unit, priceAssetId: ByteVector|Unit) = {
  this.getBoolean(
    kPairAllowed(amountAssetId, priceAssetId)
  ).valueOrElse(false)
}

# can be updated by voting
let serviceAddress = addressFromPublicKey(this.getBinaryValue(kServicePublicKey))
let botPublicKey = this.getBinaryValue(kBotPublicKey)

@Callable(i)
func init(
  servicePublicKey: ByteVector,
  botPublicKey: ByteVector,
  accountScript: ByteVector,
  rewardAmount: Int
) = {
  strict checkCaller = i.mustThis()

  ([
    BinaryEntry(kServicePublicKey, servicePublicKey),
    BinaryEntry(kBotPublicKey, botPublicKey),
    BinaryEntry(kAccountScript, accountScript),
    IntegerEntry(kRewardAmount, rewardAmount)
  ], unit)
}

# called by user
# additional fee in payment
@Callable(i)
func requestAccount(amountAssetIdStr: String, priceAssetIdStr: String) = {
  let requestId = sha256(i.caller.bytes + amountAssetIdStr.fromBase58String() + priceAssetIdStr.fromBase58String())
  let amountAssetId = parseAssetId(amountAssetIdStr)
  let priceAssetId = parseAssetId(priceAssetIdStr)

  strict checks = [
    i.payments.size() == 1 || throw("1 payment is required"),
    i.payments[0].assetId == unit || throw("invalid asset"),
    i.payments[0].amount == rewardAmount() || throw("invalid amount"),
    pairAllowed(amountAssetId, priceAssetId) || throw("pair is not allowed"),
    this.getInteger(kRequestStatus(requestId)) == unit || throw("account is already exists")
  ]

  # add request to queue or match with account immediately

  let actions = if (accountsQueue().size() == 0) then { # if the accounts queue is empty
    # then add request to requests queue
    [
      IntegerEntry(kRequestStatus(requestId), REQUEST_STATUS_EMPTY),
      BinaryEntry(kRequestsQueue(), requestsQueue() + requestId)
    ]
  } else { # if the accounts queue is not empty
    # then fullfill request
    let accountPublicKey = accountsQueue().take(queueItemSize)
    let accountAddress = addressFromPublicKey(accountPublicKey)
    let creatorAddress = addressFromPublicKey(
      this.getBinary(
        kAccountCreatorPublicKey(accountAddress)
      ).valueOrErrorMessage("invalid creator public key")
    )
    [
      BinaryEntry(kAccountsQueue(), accountsQueue().drop(queueItemSize)),
      IntegerEntry(kRequestStatus(requestId), REQUEST_STATUS_READY),
      BinaryEntry(kRequestIdToAccountPublicKey(requestId), accountPublicKey),
      StringEntry(kAccountAddressToRequestId(accountAddress), requestId.toBase58String()),
      ScriptTransfer(creatorAddress, rewardAmount(), unit)
    ]
  }

  (actions ++ [
    BinaryEntry(kRequestOwnerPublicKey(requestId), i.callerPublicKey),
    StringEntry(kRequestAmountAssetId(requestId), amountAssetIdStr),
    StringEntry(kRequestPriceAssetId(requestId), priceAssetIdStr)
  ], unit)
}

# called by account script
# additional fee is sent to recipient
@Callable(i)
func addAccount(creatorPublicKey: ByteVector) = {
  let accountPublicKey = i.callerPublicKey
  let accountAddress = i.caller
  let creatorAddress = addressFromPublicKey(creatorPublicKey)

  strict checks = [
    this.getBinary(kAccountCreatorPublicKey(accountAddress)) == unit || throw("account is already exists"),
    match scriptHash(accountAddress) {
      case b: ByteVector => b == blake2b256_32Kb(accountScript())
      case _ => false
    } || throw("invalid script")
  ]

  let actions = if (requestsQueue().size() == 0) then { # if the requests queue is empty
    # then add account to accounts queue
    [
      BinaryEntry(kAccountsQueue(), accountsQueue() + accountPublicKey)
    ]
  } else { # if the requests queue is not empty
    # then fullfill next request
    let requestId = requestsQueue().take(queueItemSize)
    [
      BinaryEntry(kRequestsQueue(), requestsQueue().drop(queueItemSize)),
      IntegerEntry(kRequestStatus(requestId), REQUEST_STATUS_READY),
      BinaryEntry(kRequestIdToAccountPublicKey(requestId), accountPublicKey),
      StringEntry(kAccountAddressToRequestId(accountAddress), requestId.toBase58String()),
      ScriptTransfer(creatorAddress, rewardAmount(), unit)
    ]
  }

  (actions ++ [
    BinaryEntry(kAccountCreatorPublicKey(accountAddress), creatorPublicKey)
  ], unit)
}