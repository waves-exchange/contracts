{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# IMPORT common.lib.ride #-}

let wavesString = "WAVES"

func parseAssetId(input: String) = {
  if (input == wavesString) then unit else input.fromBase58String()
}

func assetIdToString(input: ByteVector|Unit) = {
  if (input == unit) then wavesString else input.value().toBase58String()
}

let kServicePublicKey = "%s__servicePublicKey"
let kBotPublicKey = "%s__botPublicKey"

let kAccountScript = "%s__accountScript"
func accountScript() = this.getBinary(
  kAccountScript
).valueOrErrorMessage("account script is not set")

let kRewardAmount = "%s__rewardAmount"
func rewardAmount() = this.getInteger(
  kRewardAmount
).valueOrErrorMessage("reward amount is not set")

let ACCOUNT_STATUS_EMPTY = 0
let ACCOUNT_STATUS_READY = 1
func kAccountStatus(accountId: String) = {
  ["%s%s", accountId, "status"].makeString(separator)
}
func accountStatus(accountId: String) = {
  this.getInteger(
    kAccountStatus(accountId)
  ).valueOrErrorMessage("account is not found")
}

func kAccountCreatorPublicKey(accountId: String) = {
  ["%s%s", accountId, "creatorPublicKey"].makeString(separator)
}
func kAccountOwnerPublicKey(accountId: String) = {
  ["%s%s", accountId, "ownerPublicKey"].makeString(separator)
}
func kAccountAmountAssetId(accountId: String) = {
  ["%s%s", accountId, "amountAssetId"].makeString(separator)
}
func kAccountPriceAssetId(accountId: String) = {
  ["%s%s", accountId, "priceAssetId"].makeString(separator)
}
func kAccountIdToAccountPublicKey(accountId: String) = {
  ["%s%s", accountId, "accountIdToAccountPublicKey"].makeString(separator)
}
func kAccountAddressToAccountId(accountAddress: Address) = {
  ["%s%s", accountAddress.toString(), "accountAddressToAccountId"].makeString(separator)
}

func kPairAllowed(amountAssetId: ByteVector|Unit, priceAssetId: ByteVector|Unit) = {
  ["%s%s%s", assetIdToString(amountAssetId), assetIdToString(priceAssetId), "pairAllowed"].makeString(separator)
}
func pairAllowed(amountAssetId: ByteVector|Unit, priceAssetId: ByteVector|Unit) = {
  this.getBoolean(
    kPairAllowed(amountAssetId, priceAssetId)
  ).valueOrElse(false)
}

# can be updated by voting
let serviceAddress = addressFromPublicKey(this.getBinaryValue(kServicePublicKey))
let botPublicKey = this.getBinaryValue(kBotPublicKey)

@Callable(i)
func init(
  servicePublicKey: ByteVector,
  botPublicKey: ByteVector,
  accountScript: ByteVector,
  rewardAmount: Int
) = {
  strict checkCaller = i.mustThis()

  ([
    BinaryEntry(kServicePublicKey, servicePublicKey),
    BinaryEntry(kBotPublicKey, botPublicKey),
    BinaryEntry(kAccountScript, accountScript),
    IntegerEntry(kRewardAmount, rewardAmount)
  ], unit)
}

# called by user
# additional fee in payment
@Callable(i)
func request(amountAssetIdStr: String, priceAssetIdStr: String) = {
  let accountId = [i.caller.toString(), amountAssetIdStr, priceAssetIdStr].makeString(":")
  let amountAssetId = parseAssetId(amountAssetIdStr)
  let priceAssetId = parseAssetId(priceAssetIdStr)

  strict checks = [
    i.payments.size() == 1 || throw("1 payment is required"),
    i.payments[0].assetId == unit || throw("invalid asset"),
    i.payments[0].amount == rewardAmount() || throw("invalid amount"),
    pairAllowed(amountAssetId, priceAssetId) || throw("pair is not allowed"),
    this.getInteger(kAccountStatus(accountId)) == unit || throw("account already exists")
  ]

  ([
    IntegerEntry(kAccountStatus(accountId), 0),
    BinaryEntry(kAccountOwnerPublicKey(accountId), i.callerPublicKey),
    StringEntry(kAccountAmountAssetId(accountId), amountAssetIdStr),
    StringEntry(kAccountPriceAssetId(accountId), priceAssetIdStr)
  ], unit)
}

# called by account script
# additional fee is sent to recipient
@Callable(i)
func complete(accountId: String, creatorPublicKey: ByteVector) = {
  let accountPublicKey = i.callerPublicKey
  let accountAddress = i.caller

  strict checks = [
    accountStatus(accountId) == ACCOUNT_STATUS_EMPTY || throw("account is already exists"),
    match scriptHash(accountAddress) {
      case b: ByteVector => b == blake2b256_32Kb(accountScript())
      case _ => false
    } || throw("invalid script")
  ]

  let creatorAddress = addressFromPublicKey(creatorPublicKey)

  ([
    IntegerEntry(kAccountStatus(accountId), ACCOUNT_STATUS_READY),
    BinaryEntry(kAccountCreatorPublicKey(accountId), creatorPublicKey),
    BinaryEntry(kAccountIdToAccountPublicKey(accountId), accountPublicKey),
    StringEntry(kAccountAddressToAccountId(accountAddress), accountId),
    ScriptTransfer(creatorAddress, rewardAmount(), unit)
  ], unit)
}