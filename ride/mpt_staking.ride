{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let contractFile = "mpt_staking.ride"
let SEP = "__"
let scale8 = 1_0000_0000
let ADDRESS_BYTES_SIZE = 26

func throwErr(msg: String) = {
    throw(contractFile + ": " + msg)
}

let keyAssetId = ["%s", "assetId"].makeString(SEP)

let keyEmissionPerBlock = ["%s", "emissionPerBlock"].makeString(SEP)
let keyStartBlock       = ["%s", "startBlock"].makeString(SEP)
let keyTotalLpAmount    = ["%s", "totalLpAmount"].makeString(SEP)
let keyTotalAssetAmount = ["%s", "totalAssetAmount"].makeString(SEP)

func keyUserLpAmount(userAddress: String)            = ["%s%s", "userLpAmount", userAddress].makeString(SEP)
func keyUserTotalAssetWithdrawn(userAddress: String) = ["%s%s", "totalAssetWithdrawn", userAddress].makeString(SEP)
func keyUserTotalAssetStaked(userAddress: String)    = ["%s%s", "totalAssetStaked", userAddress].makeString(SEP)

let totalLpAmount = this.getInteger(keyTotalLpAmount).valueOrElse(0)
let totalAssetAmount = this.getInteger(keyTotalAssetAmount).valueOrElse(0)
let assetIdString = this.getString(keyAssetId).valueOrElse("WAVES")
let assetIdBytes = if (assetIdString == "WAVES") then unit else assetIdString.fromBase58String()

func getUserLpAmount(userAddress: String) = this.getInteger(keyUserLpAmount(userAddress)).valueOrElse(0)

func calcTotalProfit() = {
    let emissionPerBlock = this.getInteger(keyEmissionPerBlock).valueOrElse(0)
    let startBlock = this.getInteger(keyStartBlock).valueOrElse(0)
    let elapsedBlocks = height - startBlock

    max([0, emissionPerBlock * elapsedBlocks])
}

func getTotalAssetAmountWithProfitOrMaxAvailable() = {
    let totalAssetAmountWithProfit = totalAssetAmount + calcTotalProfit()

    let totalAmount = match(assetIdBytes) {
        case u: Unit => min([totalAssetAmountWithProfit, this.wavesBalance().available])
        case b: ByteVector => min([totalAssetAmountWithProfit, this.assetBalance(b)])
    }

    if (totalLpAmount == 0) then 0 else totalAmount
}

func getCurrentPrice() = {
    if (totalLpAmount != 0) then {
        fraction(getTotalAssetAmountWithProfitOrMaxAvailable(), scale8, totalLpAmount)
    } else {
        1 * scale8
    }
}

func getStakeActions(i: Invocation, userAddress: String) = {
    strict checks = [
        i.payments.size() == 1 || "should include 1 payment".throwErr(),
        i.payments[0].assetId == assetIdBytes || ("payment should be in " + assetIdString).throwErr(),
        i.payments[0].amount > 0 || "payment amount should be greater than 0"
    ]

    let paymentAmount = i.payments[0].amount
    let paymentLpAmount = fraction(paymentAmount, scale8, getCurrentPrice())
    let userLpAmount = getUserLpAmount(userAddress)
    let userTotalStakedAmount = this.getInteger(keyUserTotalAssetStaked(userAddress)).valueOrElse(0)

    let newTotalLpAmount= totalLpAmount + paymentLpAmount
    let newTotalAssetAmount = totalAssetAmount + paymentAmount
    let newUserLpAmount = userLpAmount + paymentLpAmount
    let newUserTotalStakedAmount = userTotalStakedAmount + paymentAmount

    let updateStartHeightAction = if (totalLpAmount == 0) then [ IntegerEntry(keyStartBlock, height) ] else []

    [
        IntegerEntry(keyTotalLpAmount, newTotalLpAmount),
        IntegerEntry(keyTotalAssetAmount, newTotalAssetAmount),
        IntegerEntry(keyUserLpAmount(userAddress), newUserLpAmount),
        IntegerEntry(keyUserTotalAssetStaked(userAddress), newUserTotalStakedAmount)
    ] ++ updateStartHeightAction
}

@Callable(i)
func setEmissionPerBlock(emissionPerBlock: Int) = {
    strict check = [
        i.caller == this || "permission denied".throwErr()
    ]

    [
        IntegerEntry(keyTotalAssetAmount, getTotalAssetAmountWithProfitOrMaxAvailable()),
        IntegerEntry(keyStartBlock, height),
        IntegerEntry(keyEmissionPerBlock, max([0, emissionPerBlock]))
    ]
}

@Callable(i)
func stake() = {
    getStakeActions(i, i.caller.toString())
}

@Callable(i)
func stakeFor(userAddress: String) = {
    strict check = [
        userAddress.fromBase58String().size() == ADDRESS_BYTES_SIZE || "address is not valid".throwErr()
    ]
    getStakeActions(i, userAddress)
}

@Callable(i)
func withdraw(lpAssetWithdrawAmount: Int) = {
    let userAddress = i.caller.toString()
    let userLpAmount = getUserLpAmount(userAddress)
    strict check = [
        lpAssetWithdrawAmount > 0 || "amount should be more than 0".throwErr(),
        lpAssetWithdrawAmount <= userLpAmount || ("cannot withdraw more than available (" + userLpAmount.toString() + ")").throwErr()
    ]

    let newUserLpAmount = userLpAmount - lpAssetWithdrawAmount
    let withdrawAssetAmount = fraction(lpAssetWithdrawAmount, getCurrentPrice(), scale8)
    let newTotalLpAmount = totalLpAmount - lpAssetWithdrawAmount
    let newTotalAssetAmount = fraction(newTotalLpAmount, getCurrentPrice(), scale8)
    
    let userTotalAssetWithdrawn = this.getInteger(keyUserTotalAssetWithdrawn(userAddress)).valueOrElse(0)
    let newUserTotalAssetWithdrawn = userTotalAssetWithdrawn + withdrawAssetAmount

    [
        IntegerEntry(keyTotalLpAmount, newTotalLpAmount),
        IntegerEntry(keyTotalAssetAmount, newTotalAssetAmount),
        IntegerEntry(keyUserLpAmount(userAddress), newUserLpAmount),
        IntegerEntry(keyUserTotalAssetWithdrawn(userAddress), newUserTotalAssetWithdrawn),
        IntegerEntry(keyStartBlock, height),
        ScriptTransfer(i.caller, withdrawAssetAmount, assetIdBytes)
    ]
}

# Return tuple: 
# _1 = user available internal LP amount
# _2 = user available tokens to withdraw
# _3 = current internal LP price
# _4 = user total staked token amount
# _5 = user total withdrawn token amount
@Callable(i)
func getUserAssetsREADONLY(userAddress: String) = {
    let userLpAmount = getUserLpAmount(userAddress)
    let userAvailableAssetToWithdraw = fraction(userLpAmount, getCurrentPrice(), scale8)
    let userTotalStakedAmount = this.getInteger(keyUserTotalAssetStaked(userAddress)).valueOrElse(0)
    let userTotalAssetWithdrawn = this.getInteger(keyUserTotalAssetWithdrawn(userAddress)).valueOrElse(0)

    (nil, (userLpAmount, userAvailableAssetToWithdraw, getCurrentPrice(), userTotalStakedAmount, userTotalAssetWithdrawn))
}

# Return tuple: 
# _1 = total available internal LP amount
# _2 = total available tokens to withdraw
# _3 = current internal LP price
@Callable(i)
func getTotalAssetsREADONLY() = {
    (nil, (totalLpAmount, getTotalAssetAmountWithProfitOrMaxAvailable(), getCurrentPrice()))
}
