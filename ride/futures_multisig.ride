{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let separator = "__"
let chainId = this.bytes.drop(1).take(1)
let chainIdW = base16'57'
let contractFilename = "futures_multisig.ride"

let publicKeySize = 32
let txIdSize = 32
let maxOwners = 10

let kMultisig = "%s__multisig"
let kPublicKeys = "%s__publicKeys"
let kQuorum = "%s__quorum"

func kConfirm(dapp: String, txId: String) = ["%s__confirm", dapp, txId].makeString(separator)
func kStatus(dapp: String, txId: String) = ["%s__status", dapp, txId].makeString(separator)

func wrapErr(s: String) = {
  contractFilename + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func validateAddress(address: String) = {
  addressFromString(address).isDefined()
}

func validatePublicKey(publicKey: String) = {
  fromBase58String(publicKey).size() == publicKeySize
}

@Callable(i)
func init(owners: List[String], quorum: Int) = {
  func validateOwner(acc: Unit, pk: String) = validatePublicKey(pk) || throwErr("invalid owner public key")
  strict checks = [
    getString(kMultisig).isDefined() || throwErr("init: already initialized"),
    (owners.size() > 0 && owners.size() <= maxOwners) || throwErr("init: invalid owners"),
    (quorum > 0 || quorum <= owners.size()) || throwErr("init: invalid quorum"),
    # maxOwners
    FOLD<10>(owners, unit, validateOwner)
  ]

  ([
    StringEntry(kMultisig, this.toString()),
    StringEntry(kPublicKeys, makeString(owners, separator)),
    IntegerEntry(kQuorum, quorum)
  ], unit)
}

@Callable(i)
func addOwner(publicKey: String) = {
  let publicKeysList = getStringValue(kPublicKeys).split(separator)

  strict checks = [
    i.caller == this || throwErr("addOwner: not allowed"),
    validatePublicKey(publicKey) || throwErr("addOwner: invalid public key"),
    !containsElement(publicKeysList, publicKey) || throwErr("addOwner: public key already added"),
    publicKeysList.size() < maxOwners || throwErr("addOwner: too many owners")
  ]

  let publicKeysListUpdated = publicKeysList :+ publicKey
  let publicKeysUpdated = [
    StringEntry(kPublicKeys, publicKeysListUpdated.makeString(separator))
  ]

  (publicKeysUpdated, unit)
}

@Callable(i)
func removeOwner(publicKey: String) = {
  let quorum = getIntegerValue(kQuorum)
  let publicKeys = getStringValue(kPublicKeys)
  let publicKeysList = publicKeys.split(separator)

  strict checks = [
    i.caller == this || throwErr("removeOwner: not allowed"),
    validatePublicKey(publicKey) || throwErr("removeOwner: invalid public key"),
    publicKeysList.size() > 1 || throwErr("removeOwner: too few owners")
  ]

  let index = indexOf(publicKeysList, publicKey).valueOrErrorMessage(
    wrapErr("removeOwner: no such owner")
  )
  let publicKeysListUpdated = removeByIndex(publicKeysList, index)
  let publicKeysUpdated = [
    StringEntry(kPublicKeys, makeString(publicKeysListUpdated, separator))
  ]

  let quorumUpdated = if quorum > publicKeysListUpdated.size() then [
    IntegerEntry(kQuorum, publicKeysListUpdated.size())
  ] else []

  (publicKeysUpdated ++ quorumUpdated, unit)
}

@Callable(i)
func setQuorum(quorum: Int) = {
  let publicKeys = getStringValue(kPublicKeys)
  let publicKeysList = publicKeys.split(separator)

  strict checks = [
    i.caller == this || throwErr("setQuorum: not allowed"),
    (quorum > 0 && quorum <= publicKeysList.size()) || throwErr("setQuorum: invalid quorum")
  ]

  ([
    IntegerEntry(kQuorum, quorum)
  ], unit)
}

@Callable(i)
func confirmTransaction(dapp: String, txId: String) = {
  let callerPublicKey = toBase58String(i.callerPublicKey)
  let quorum = getIntegerValue(kQuorum)
  let publicKeys = getStringValue(kPublicKeys)
  let publicKeysList = publicKeys.split(separator)
  let confirmationsKey = kConfirm(dapp, txId)
  let confirmations = getString(confirmationsKey).valueOrElse("")
  let statusKey = kStatus(dapp, txId)

  strict checks = [
    containsElement(publicKeysList, callerPublicKey) || throwErr("confirmTransaction: only admin"),
    fromBase58String(txId).size() == txIdSize ||throwErr("confirmTransaction: invalid txId"),
    validateAddress(dapp) || throwErr("confirmTransaction: invalid dapp address"),
    !contains(confirmations, callerPublicKey) || throwErr("confirmTransaction: already confirmed")
  ]

  let (confirmationsCount, confirmationsUpdated) = if confirmations == "" then (
    1,
    callerPublicKey
  ) else (
    confirmations.split(separator).size(),
    confirmations + separator + callerPublicKey
  )

  ([
    StringEntry(confirmationsKey, confirmationsUpdated),
    BooleanEntry(statusKey, confirmationsCount >= quorum)
  ], unit)
}

@Callable(i)
func revokeConfirmation(dapp: String, txId: String) = {
  let callerPublicKey = toBase58String(i.callerPublicKey)
  let quorum = getIntegerValue(kQuorum)
  let publicKeys = getStringValue(kPublicKeys)
  let publicKeysList = publicKeys.split(separator)
  let confirmationsKey = kConfirm(dapp, txId)
  let confirmations = getString(confirmationsKey).valueOrElse("")
  let confirmationsList = confirmations.split(separator)
  let statusKey = kStatus(dapp, txId)
  let status = getBoolean(statusKey).valueOrElse(false)

  strict checks = [
    containsElement(publicKeysList, callerPublicKey) || throwErr("revokeConfirmation: only admin"),
    fromBase58String(txId).size() == txIdSize ||throwErr("revokeConfirmation: invalid txId"),
    validateAddress(dapp) || throwErr("revokeConfirmation: invalid dapp address"),
    contains(confirmations, callerPublicKey) || throwErr("revokeConfirmation: not confirmed"),
    !status || throwErr("revokeConfirmation: quorum already reached")
  ]

  let confirmationsListUpdated = confirmationsList.removeByIndex(
    confirmationsList.indexOf(callerPublicKey).value()
  )
  let confirmationsCount = confirmationsListUpdated.size()

  ([
    StringEntry(confirmationsKey, makeString(confirmationsListUpdated, separator)),
    BooleanEntry(statusKey, confirmationsCount >= quorum)
  ], unit)
}

@Verifier(tx)
func verify() = {
  match getString(kMultisig) {
    case multisig: String => {
      let statusKey = kStatus(this.toString(), tx.id.toBase58String())
      let status = multisig.addressFromStringValue().getBoolean(statusKey).valueOrElse(false)

      status
    }
    case _ => sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
  }
}