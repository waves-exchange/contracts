{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let nextVoteNumber = 0
let gwxContractAddress


func managerPublicKeyOrUnit() = match keyManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func pendingManagerPublicKeyOrUnit() = match keyPendingManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}


func isManager(i: Invocation) = {
  match managerPublicKeyOrUnit() {
    case pk: ByteVector => i.callerPublicKey == pk
    case _: Unit => i.caller == this
  }
}

func mustManager(i: Invocation) = {
  i.isManager() || "permission denied".throw()
}

@Callable(i)
func constructor(
    gwxContractAddressString: string
) = {
    gwxContractAddress = gwxContractAddressString
}

# type Point : 
# { 
#     bias: Int, 
#     slope: Int, # - dweight / dt
#     ts: Int, # ??? uint
#     blck: Int # block # ??? uint
# }

# type LockedBalance : 
# { 
#     amount: Int, 
#     end: Int # ??? uint
# }



# let depositForType = 0
# let createLockType = 1
# let increaseLockTime = 2
# let increaseUnlockTime = 3


# let week = 7 * 86400 # all future times are rounded by week # ??? constant
# let maxTime = 4 * 365 * 86400 # 4 years # ??? constant
# let multiplier = 10 ^ 18  # ??? constant


# # token: public(address)
# # supply: public(uint256)

# # locked: public(HashMap[address, LockedBalance])


# # epoch: public(uint256)
# # point_history: public(Point[100000000000000000000000000000])  # epoch -> unsigned point
# # user_point_history: public(HashMap[address, Point[1000000000]])  # user -> Point[user_epoch]
# # user_point_epoch: public(HashMap[address, uint256])
# # slope_changes: public(HashMap[uint256, int128])  # time -> signed slope change


# # admin: public(address)  # Can and will be a smart contract
# # future_admin: public(address)


# @Callable(i)
# func constructor() = {

# }


# func transferOwnership() = {

# }

# func getLastUserSlope() = {
    
# }






func startNewVote(description: String, startTimeStamp: Int, expirationTime: Int) = {
    strict checks = [
        i.mustManager()
    ]

    nextVoteNumber = nextVoteNumber + 1
    [
        StringEntry(toString(nextVoteNumber - 1), description)

        StringEntry(toString(nextVoteNumber - 1) + "end", startTimeStamp + expirationTime)
    ]
    
}

@Callable(i)
func voteFor(proposalIndex: String, choice: Boolean) = {
    strict checks = [
        lastBlock.timestamp < getString(proposalIndex + "end")
    ]

    [
        
        BooleanEntry(toString(i.caller) + proposalIndex, choice)
    ]
}

@Callable(i)
func deleteVote(proposalIndex: String) = {
    [
        DeleteEntry(toString(i.caller) + proposalIndex)
    ]
}

# @Callable(i)
# func changeVote() = {
    
# }

@Callable(i)
func summarizeVote() = {
    
}










@Callable(i)
func setManager(pendingManagerPublicKey: String) = {
  strict checkCaller = i.mustManager()
  strict checkManagerPublicKey = pendingManagerPublicKey.fromBase58String()

  [StringEntry(keyPendingManagerPublicKey(), pendingManagerPublicKey)]
}

@Callable(i)
func confirmManager() = {
  let pm = pendingManagerPublicKeyOrUnit()
  strict hasPM = pm.isDefined() || throw("no pending manager")
  strict checkPM = i.callerPublicKey == pm.value() || throw("you are not pending manager")

  [
    StringEntry(keyManagerPublicKey(), pm.value().toBase58String()),
    DeleteEntry(keyPendingManagerPublicKey())
  ]
}

@Verifier(tx)
func verify() = {
  let targetPublicKey = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
}