{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# IMPORT common.lib.ride #-}

let SEP = "__"
let WAVES = "WAVES"
let contractFilename = "wxdao_calculator.ride"

func wrapErr(s: String) = {
  contractFilename + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func keyPowerConfigAddress() = "%s__powerConfigAddress"
func powerConfigAddress(factoryAddress: Address) = {
  match factoryAddress.getString(keyPowerConfigAddress()) {
    case s: String => s.addressFromString()
    case _: Unit => unit
  }
}.valueOrErrorMessage(wrapErr("invalid power config address"))

func keyPowerAssetId() = "powerAssetId"
func powerAssetId(factoryAddress: Address) = powerConfigAddress(factoryAddress).getString(
  keyPowerAssetId()
).valueOrErrorMessage(wrapErr("invalid power asset id")).fromBase58String()

func keyPowerContractAddress() = "%s__powerContractAddress"
func powerContractAddress(factoryAddress: Address) = {
  match factoryAddress.getString(keyPowerContractAddress()) {
    case s: String => s.addressFromString()
    case _: Unit => unit
  }
}.valueOrErrorMessage(wrapErr("invalid power contract address"))

func keyAssets() = "%s__assets"
func getAssetsStr(factoryAddress: Address) = factoryAddress.getString(
  keyAssets()
).valueOrErrorMessage(wrapErr("invalid assets"))

func keyLpAssetId() = "%s__lpAssetId"
func getLpAssetId(factoryAddress: Address) = factoryAddress.getString(
  keyLpAssetId()
).valueOrErrorMessage(wrapErr("invalid lp asset id")).fromBase58String()

# withdraw from investment account to specified address
@Callable(i)
func withdraw(args: List[String]) = {
  let recipient = addressFromStringValue(args[0])
  let amount = parseIntValue(args[1])
  let result = i.caller.invoke("transferWaves", [recipient.bytes, amount], [])

  (nil, result)
}

# set param example
@Callable(i)
func setIntParam(args: List[String]) = {
  let key = args[0]
  let val = parseIntValue(args[1])
  let result = i.caller.invoke("integerEntry", [key, val], [])

  (nil, result)
}

# Swap WXDAO token to staked PWR token
# Stake PWR token, send profit to caller, burn WXDAO token
# payments:
# - WXDAO token
@Callable(i)
func swap(callerPublicKey: ByteVector, args: List[String]) = {
  let factoryAddress = i.caller
  let userAddress = addressFromPublicKey(callerPublicKey)

  let payment = if (i.payments.size() == 1) then i.payments[0] else {
    throwErr("1 payment is required")
  }

  let err = wrapErr("invalid payment asset id")
  let paymentAssetId = if (payment.assetId.valueOrErrorMessage(err) == getLpAssetId(factoryAddress)) then {
    payment.assetId.value()
  } else {
    throwErr(err)
  }

  let pwrPrice = 100 # 100 WXDAO tokens for 1 PWR token
  let pwrAmount = payment.amount / pwrPrice

  let assetsStr = getAssetsStr(factoryAddress).split(SEP)
  strict pwrBalance = factoryAddress.assetBalance(powerAssetId(factoryAddress))

  func map(acc: (List[ByteVector], List[Int]), nextAssetId: String) = {
    let assetId = nextAssetId.fromBase58String()
    strict balance = factoryAddress.assetBalance(assetId)
    let amount = fraction(balance, pwrAmount, pwrBalance)

    if (amount > 0) then (
      acc._1 :+ assetId,
      acc._2 :+ amount
    ) else acc
  }

  strict transfers = FOLD<6>(assetsStr, (nil, nil), map)

  let additionalLockRounds = 0
  let factoryActions = [
    factoryAddress.invoke(
      "commitAfterStartWithLockRoundFor",
      [
        powerContractAddress(factoryAddress).toString(),
        factoryAddress.toString(),
        userAddress.toString(),
        additionalLockRounds,
        powerAssetId(factoryAddress),
        pwrAmount
      ],
      []
    )
  ] ++ if (transfers._1.size() == 0) then [] else [
    factoryAddress.invoke(
      "transferAssets",
      [
        userAddress.bytes,
        transfers._1,
        transfers._2
      ],
      []
    )
  ]

  ([
    Burn(paymentAssetId, payment.amount)
  ], factoryActions)
}

# returns wxdao token price
@Callable(i)
func price(callerPublicKey: ByteVector, args: List[String]) = {
  (nil, 0)
}

@Verifier(tx)
func verify() = {
  chainId == chainIdT
}
