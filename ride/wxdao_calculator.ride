{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# IMPORT common.lib.ride #-}

let SEP = "__"
let WAVES = "WAVES"
let contractFilename = "wxdao_calculator.ride"
let mult18 = 1_000_000_000_000_000_000.toBigInt()

func wrapErr(s: String) = {
  contractFilename + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func keyPowerConfigAddress() = "%s__powerConfigAddress"
func powerConfigAddress(factoryAddress: Address) = {
  match factoryAddress.getString(keyPowerConfigAddress()) {
    case s: String => s.addressFromString()
    case _: Unit => unit
  }
}.valueOrErrorMessage(wrapErr("invalid power config address"))

func keyPowerAssetId() = "powerAssetId"
func powerAssetId(factoryAddress: Address) = powerConfigAddress(factoryAddress).getString(
  keyPowerAssetId()
).valueOrErrorMessage(wrapErr("invalid power asset id")).fromBase58String()

func keyPowerContractAddress() = "%s__powerContractAddress"
func powerContractAddress(factoryAddress: Address) = {
  match factoryAddress.getString(keyPowerContractAddress()) {
    case s: String => s.addressFromString()
    case _: Unit => unit
  }
}.valueOrErrorMessage(wrapErr("invalid power contract address"))

func keyPoolsFactoryAddress() = "%s__poolsFactoryAddress"
func getPoolsFactoryAddress(factoryAddress: Address) = {
  match factoryAddress.getString(keyPoolsFactoryAddress()) {
    case s: String => s.addressFromString()
    case _: Unit => unit
  }
}.valueOrErrorMessage(wrapErr("invalid pools factory address"))

func keyAssets() = "%s__assets"
func getAssetsStr(factoryAddress: Address) = factoryAddress.getString(
  keyAssets()
).valueOrErrorMessage(wrapErr("invalid assets"))

func keyLpAssetId() = "%s__lpAssetId"
func getLpAssetId(factoryAddress: Address) = factoryAddress.getString(
  keyLpAssetId()
).valueOrErrorMessage(wrapErr("invalid lp asset id")).fromBase58String()

func getAssetPrice(i: Invocation, assetId: ByteVector) = {
  let factoryAddress = i.caller
  let poolsFactoryAddress = getPoolsFactoryAddress(factoryAddress)
  # mainnet
  # WAVES/USDT
  # WAVES/XTN -> XTN/USDT
  match assetId {
    # PWR 2thsACuHmzDMuNezPM32wg9a3BwUzBWDeSKakgz3cw21
    # PWR/WAVES -> WAVES/USDT -> PWR/USDT

    # WX Atqv59EYzjFGuitKVnMRk6H8FukjoV3ktPorbEys25on
    # WX/WAVES -> WAVES/USDT -> WX/USDT
    case base58'Atqv59EYzjFGuitKVnMRk6H8FukjoV3ktPorbEys25on' => {
      let wxWavesAddressStr = "3PFzaH2ghpwANHFgjeva83N1yxzErELx2eh"
      let wavesUsdtAddressStr = "3PKfrupEydU2nZAghVjZAfvCwMBkzuR1F52"
      let wxWavesPrice = poolsFactoryAddress.invoke("getPriceX18", [wxWavesAddressStr], []).exactAs[String].parseBigIntValue()
      let wavesUsdtPrice = poolsFactoryAddress.invoke("getPriceX18", [wavesUsdtAddressStr], []).exactAs[String].parseBigIntValue()
      let wxUsdtPrice = fraction(wxWavesPrice, wavesUsdtPrice, mult18)
      wxUsdtPrice
    }
    # USDT-WXG 34N9YcEETLWn93qYQ64EsP1x89tSruJU44RrEMSXXEPJ
    # USDT-WXG/XTN -> WAVES/XTN -> XTN/USDT -> USDT-WXG/USDT

    # USDC-WXG 6XtHjpXbs9RRJP2Sr9GUyVqzACcby9TkThHXnjVC5CDJ
    # USDС-WXG/XTN -> WAVES/XTN -> XTN/USDT -> USDС-WXG/USDT

    # LTC-WXG HZk1mbfuJpmxU1Fs4AX5MWLVYtctsNcg6e2C6VKqK8zk
    # LTC-WXG/XTN -> WAVES/XTN -> XTN/USDT -> LTC-WXG/USDT

    # ETH-WXG 474jTeYx2r2Va35794tCScAXWJG9hU2HcgxzMowaZUnu
    # ETH-WXG/WAVES -> WAVES/USDT -> ETH-WXG/USDT

    # BTC-WXG 8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS
    # BTC-WXG/XTN -> WAVES/XTN -> XTN/USDT -> BTC/USDT

    case _ => throwErr("invalid asset id")
  }
}

# withdraw from investment account to specified address
@Callable(i)
func withdraw(args: List[String]) = {
  let recipient = addressFromStringValue(args[0])
  let amount = parseIntValue(args[1])
  let result = i.caller.invoke("transferWaves", [recipient.bytes, amount], [])

  (nil, result)
}

# set param example
@Callable(i)
func setIntParam(args: List[String]) = {
  let key = args[0]
  let val = parseIntValue(args[1])
  let result = i.caller.invoke("integerEntry", [key, val], [])

  (nil, result)
}

# Swap WXDAO token to staked PWR token
# Stake PWR token, send profit to caller, burn WXDAO token
# payments:
# - WXDAO token
@Callable(i)
func swap(callerPublicKey: ByteVector, args: List[String]) = {
  let factoryAddress = i.caller
  let userAddress = addressFromPublicKey(callerPublicKey)

  let payment = if (i.payments.size() == 1) then i.payments[0] else {
    throwErr("1 payment is required")
  }

  let err = wrapErr("invalid payment asset id")
  let paymentAssetId = if (payment.assetId.valueOrErrorMessage(err) == getLpAssetId(factoryAddress)) then {
    payment.assetId.value()
  } else {
    throwErr(err)
  }

  let pwrPrice = 100 # 100 WXDAO tokens for 1 PWR token
  let pwrAmount = payment.amount / pwrPrice

  let assetsStr = getAssetsStr(factoryAddress).split(SEP)
  strict pwrBalance = factoryAddress.assetBalance(powerAssetId(factoryAddress))

  func map(acc: (List[ByteVector], List[Int]), nextAssetId: String) = {
    let assetId = nextAssetId.fromBase58String()
    strict balance = factoryAddress.assetBalance(assetId)
    let amount = fraction(balance, pwrAmount, pwrBalance)

    if (amount > 0) then (
      acc._1 :+ assetId,
      acc._2 :+ amount
    ) else acc
  }

  strict transfers = FOLD<6>(assetsStr, (nil, nil), map)

  let additionalLockRounds = 0
  let factoryActions = [
    factoryAddress.invoke(
      "commitAfterStartWithLockRoundFor",
      [
        powerContractAddress(factoryAddress).toString(),
        factoryAddress.toString(),
        userAddress.toString(),
        additionalLockRounds,
        powerAssetId(factoryAddress),
        pwrAmount
      ],
      []
    )
  ] ++ if (transfers._1.size() == 0) then [] else [
    factoryAddress.invoke(
      "transferAssets",
      [
        userAddress.bytes,
        transfers._1,
        transfers._2
      ],
      []
    )
  ]

  ([
    Burn(paymentAssetId, payment.amount)
  ], factoryActions)
}

# returns wxdao token price
@Callable(i)
func price(callerPublicKey: ByteVector, args: List[String]) = {
  (nil, 0)
}

@Verifier(tx)
func verify() = {
  chainId == chainIdT
}
