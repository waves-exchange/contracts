{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# Required state entries:
# * "%s%s__config__referralsContractAddress": String
# * "%s__nextUserNum": Int
# * "%s%s__config__factoryAddress": String
# * "%s__config": String
# ("%s%d%d%d%s%d%d__<assetId>__<minLockAmount>__<minLockDuration>__<maxLockDuration>__<mathContract>__<blocksInPeriod>__<lockStepBlocks>")
# * "%s__lpStakingPoolsContract": String

let SEP = "__"
let SCALE8 = 8
let MULT8 = 100000000
let POOLWEIGHTMULT = MULT8
let contractFilename = "boosting.ride"
let SCALE18 = 18
let MULT18 = 1_000_000_000_000_000_000
let MULT18BI = MULT18.toBigInt()
let DECAY_CONSTANT = 8

func wrapErr(msg: String) = [contractFilename, ": ", msg].makeString("")
func throwErr(msg: String) = msg.wrapErr().throw()

func getStringOrFail(address: Address, key: String) = address.getString(key).valueOrErrorMessage(("mandatory this." + key + " is not defined").wrapErr())
func getIntOrZero(address: Address, key: String) = address.getInteger(key).valueOrElse(0)
func getIntOrDefault(address: Address, key: String, defaultVal: Int) = address.getInteger(key).valueOrElse(defaultVal)
func getIntOrFail(address: Address, key: String) = address.getInteger(key).valueOrErrorMessage(("mandatory this." + key + " is not defined").wrapErr())

func abs(val: Int) = if (val < 0) then -val else val

func ensurePositive(v: Int, m: String|Unit) = {
  if (v >= 0) then v else throwErr(m.valueOrElse("value") + " should be positive")
}

func keyReferralsContractAddress() = ["%s%s", "config", "referralsContractAddress"].makeString(SEP)
let referralsContractAddressOrFail = this.getStringOrFail(keyReferralsContractAddress()).addressFromStringValue()

let keyReferralProgramName = ["%s%s", "referral", "programName"].makeString(SEP)
let referralProgramNameDefault = "wxlock"
let referralProgramName = this.getString(keyReferralProgramName).valueOrElse(referralProgramNameDefault)

# FACTORY API
# own factory address key
func keyFactoryAddress() = "%s%s__config__factoryAddress"

let IdxFactoryCfgStakingDapp = 1
let IdxFactoryCfgBoostingDapp = 2
let IdxFactoryCfgIdoDapp = 3
let IdxFactoryCfgTeamDapp = 4
let IdxFactoryCfgEmissionDapp = 5
let IdxFactoryCfgRestDapp = 6
let IdxFactoryCfgSlippageDapp = 7
let IdxFactoryCfgDaoDapp = 8
let IdxFactoryCfgMarketingDapp = 9
let IdxFactoryCfgGwxRewardDapp = 10
let IdxFactoryCfgBirdsDapp = 11

func keyFactoryCfg() = "%s__factoryConfig"
func keyFactoryLpAssetToPoolContractAddress(lpAssetStr: String) = makeString(["%s%s%s", lpAssetStr, "mappings__lpAsset2PoolContract"], SEP)
func keyFactoryPoolWeight(contractAddress: String) = { ["%s%s", "poolWeight", contractAddress].makeString(SEP) }
func keyFactoryPoolWeightHistory(poolAddress: String, num: Int) = {"%s%s__poolWeight__" + poolAddress + "__" + num.toString()}

func readFactoryAddressOrFail() = this.getStringOrFail(keyFactoryAddress()).addressFromStringValue()
func readFactoryCfgOrFail(factory: Address) = factory.getStringOrFail(keyFactoryCfg()).split(SEP)
func getBoostingAddressOrFail(factoryCfg: List[String]) = factoryCfg[IdxFactoryCfgBoostingDapp].addressFromStringValue()
func getEmissionAddressOrFail(factoryCfg: List[String]) = factoryCfg[IdxFactoryCfgEmissionDapp].addressFromStringValue()
func getStakingAddressOrFail(factoryCfg: List[String]) = factoryCfg[IdxFactoryCfgStakingDapp].addressFromStringValue()
func getGwxRewardAddressOrFail(factoryCfg: List[String]) = factoryCfg[IdxFactoryCfgGwxRewardDapp].addressFromStringValue()

func keyManagerPublicKey() = "%s__managerPublicKey"
func keyManagerVaultAddress() = "%s__managerVaultAddress"

# EMISSION API
func keyEmissionRatePerBlockCurrent() = "%s%s__ratePerBlock__current"
func keyEmissionRatePerBlockMaxCurrent() = "%s%s__ratePerBlockMax__current"
func keyEmissionStartBlock() = "%s%s__emission__startBlock"
func keyBoostingV2LastUpdateHeight() = "%s%s__boostingV2__startBlock"
func keyBoostingV2Integral() = "%s%s__boostingV2__integral"
func keyEmissionDurationInBlocks() = "%s%s__emission__duration"
func keyEmissionEndBlock() = "%s%s__emission__endBlock"

# OWN KEYS
let IdxCfgAssetId = 1
let IdxCfgMinLockAmount = 2
let IdxCfgMinLockDuration = 3
let IdxCfgMaxLockDuration = 4
let IdxCfgMathContract = 5
let IdxCfgBlocksInPeriod = 6
let IdxCfgLockStepBlocks = 7

func keyConfig() = {"%s__config"}
func readConfigArrayOrFail() = this.getStringOrFail(keyConfig()).split(SEP)
let cfgArray = readConfigArrayOrFail()
let assetId = cfgArray[IdxCfgAssetId].fromBase58String()
let minLockAmount = cfgArray[IdxCfgMinLockAmount].parseInt().valueOrErrorMessage(wrapErr("invalid min lock amount"))
let minLockDuration = cfgArray[IdxCfgMinLockDuration].parseInt().valueOrErrorMessage(wrapErr("invalid min lock duration"))
let maxLockDuration = cfgArray[IdxCfgMaxLockDuration].parseInt().valueOrErrorMessage(wrapErr("invalid max lock duration"))
let mathContract = cfgArray[IdxCfgMathContract].addressFromString().valueOrErrorMessage(wrapErr("invalid math contract address"))
let blocksInPeriod = cfgArray[IdxCfgBlocksInPeriod].parseInt().valueOrErrorMessage(wrapErr("invalid blocks in period"))
let lockStepBlocks = cfgArray[IdxCfgLockStepBlocks].parseInt().valueOrErrorMessage(wrapErr("invalid lock step blocks"))

let keySuspension = "%s__suspension"
let isSuspended = this.getBoolean(keySuspension).valueOrElse(false)
func throwIfSuspended() = !isSuspended || throwErr("suspended")

func getManagerVaultAddressOrThis() = {
  match keyManagerVaultAddress().getString() {
    case s:String => s.addressFromStringValue()
    case _=> this
  }
}

func managerPublicKeyOrUnit() = {
  let managerVaultAddress = getManagerVaultAddressOrThis()
  match managerVaultAddress.getString(keyManagerPublicKey()) {
    case s: String => s.fromBase58String()
    case _: Unit => unit
  }
}

func mustManager(i: Invocation) = {
  let pd = "Permission denied".throwErr()

  match managerPublicKeyOrUnit() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

let IdxLockAmount = 1
let IdxLockStart = 2
let IdxLockDuration = 3
let IdxLockLastUpdateTimestamp = 4
let IdxLockGwxAmount = 5
let IdxLockWxClaimed = 6

func keyLockParamsRecord(userAddress: Address, txId: ByteVector|Unit) = makeString([
  "%s%s%s__lock",
  userAddress.toString(),
  match txId {
    case b: ByteVector => b.toBase58String()
    case _: Unit => "legacy"
  }
], SEP)
func readLockParamsRecordOrFail(userAddress: Address, txId: ByteVector|Unit) = this.getStringOrFail(keyLockParamsRecord(userAddress, txId)).split(SEP)

func keyUserGwxAmountTotal(userAddress: Address) = makeString(["%s%s__gwxAmountTotal", userAddress.toString()], SEP)

func formatLockParamsRecord(
  amount: Int,
  start: Int,
  duration: Int,
  gwxAmount: Int,
  wxClaimed: Int
) = {
  makeString([
    "%d%d%d%d%d%d", # 0
    amount.toString(), # 1
    start.toString(), # 2
    duration.toString(), # 3
    lastBlock.timestamp.toString(), # 4
    gwxAmount.toString(), # 5
    wxClaimed.toString() # 6
  ], SEP)
}

# mappings
func keyNextUserNum() = "%s__nextUserNum"
func keyUser2NumMapping(userAddress: String) = makeString(["%s%s%s__mapping__user2num", userAddress], SEP)
func keyNum2UserMapping(num: String) = makeString(["%s%s%s__mapping__num2user", num], SEP)

func keyLockParamTotalAmount() = "%s%s__stats__activeTotalLocked"
func keyStatsLocksDurationSumInBlocks() = "%s%s__stats__locksDurationSumInBlocks"
func keyStatsLocksCount() = "%s%s__stats__locksCount"
func keyStatsUsersCount() = "%s%s__stats__activeUsersCount"

# boost integral
func keyUserBoostEmissionLastINTEGRAL(userNum: Int) = makeString(["%s%d__userBoostEmissionLastIntV2", userNum.toString()], SEP)
func keyUserLpBoostEmissionLastINTEGRAL(userNum: Int, lpAssetId: String) = makeString(["%s%d__userBoostEmissionLastIntV2", userNum.toString(), lpAssetId], SEP)
func keyUserMaxBoostINTEGRAL(userNum: Int) = makeString(["%s%d__maxBoostInt", userNum.toString()], SEP)
func keyTotalMaxBoostINTEGRAL() = "%s%s__maxBoostInt__total"
func keyUserBoostAvalaibleToClaimTotal(userNum: Int) = makeString(["%s%d__userBoostAvaliableToClaimTotal", userNum.toString()], SEP)
func keyUserBoostClaimed(userNum: Int) = makeString(["%s%d__userBoostClaimed", userNum.toString()], SEP)

func keyGwxTotal() = "%s%s__gwx__total"

# Voting emission
# User vote
func keyVote(amountAssetId: String, priceAssetId: String, address: Address, epoch: Int) = {
  ["%s%s%s%s%d", "vote", amountAssetId, priceAssetId, address.toString(), epoch.toString()].makeString(SEP)
}
func keyStartHeightByEpoch(epoch: Int) = ["%s%d", "startHeight", epoch.toString()].makeString(SEP)
func keyCurrentEpochUi() = ["%s", "currentEpochUi"].makeString(SEP)

# Initial value is stored on voting emission account
# Following values are stored on this account
func keyVotingResultStaked(lpAssetIdStr: String, epoch: Int) = {
  ["%s%s%d", "votingResultStaked", lpAssetIdStr, epoch.toString()].makeString(SEP)
}

# this
# We need to save integral to handle changing value
func keyVotingResultStakedIntegral(lpAssetIdStr: String, epoch: Int) = {
  ["%s%s%d", "votingResultStakedIntegral", lpAssetIdStr, epoch.toString()].makeString(SEP)
}
# Height at which voting result staked was last changed
func keyVotingResultStakedLastUpdateHeight(lpAssetIdStr: String, epoch: Int) = {
  ["%s%s%d", "votingResultStakedIntegralLastUpdateHeight", lpAssetIdStr, epoch.toString()].makeString(SEP)
}
# Last integral value used by user
# This value is needed to calculate unclaimed boost
func keyVotingResultStakedIntegralLast(lpAssetIdStr: String, address: Address, epoch: Int) = {
  ["%s%s%s%d", "votingResultStakedIntegralLast", lpAssetIdStr, address.toString(), epoch.toString()].makeString(SEP)
}
func keyVoteStakedIntegral(lpAssetIdStr: String, address: Address, epoch: Int) = {
  ["%s%s%s%d", "voteStakedIntegral", lpAssetIdStr, address.toString(), epoch.toString()].makeString(SEP)
}
func keyVoteStakedLastUpdateHeight(lpAssetIdStr: String, address: Address, epoch: Int) = {
  ["%s%s%s%d", "voteStakedIntegralLastUpdateHeight", lpAssetIdStr, address.toString(), epoch.toString()].makeString(SEP)
}
func keyVoteStakedIntegralLast(lpAssetIdStr: String, address: Address, epoch: Int) = {
  ["%s%s%s%d", "voteStakedIntegralLast", lpAssetIdStr, address.toString(), epoch.toString()].makeString(SEP)
}

# staking
func keyStakedByUser(userAddressStr: String, lpAssetIdStr: String) = ["%s%s%s", "staked", userAddressStr, lpAssetIdStr].makeString(SEP)

# GLOBAL VARIABLES
# CONSTRUCTOR IS NOT FAILED BECAUSE GLOBAL VARIABLES ARE NOT USED
let factoryContract = readFactoryAddressOrFail()
let factoryCfg = factoryContract.readFactoryCfgOrFail()
let emissionContract = factoryCfg.getEmissionAddressOrFail()
let stakingContract = factoryCfg.getStakingAddressOrFail()
let gwxRewardContract = factoryCfg.getGwxRewardAddressOrFail()
let lpStakingPoolsContract = ["%s", "lpStakingPoolsContract"].makeString(SEP)
  .getString().valueOrErrorMessage("lp_staking_pools contract address is undefined".wrapErr())
  .addressFromString().valueOrErrorMessage("invalid lp_staking_pools contract address".wrapErr())

let keyVotingEmissionContract = ["%s", "votingEmissionContract"].makeString(SEP)
let votingEmissionContract = factoryContract.getStringValue(keyVotingEmissionContract).addressFromStringValue()
# in voting emission contract storage
let keyVotingEmissionRateContract = ["%s", "votingEmissionRateContract"].makeString(SEP)

let boostCoeff = emissionContract.invoke("getBoostCoeffREADONLY", [], []).exactAs[Int]

func userNumberByAddressOrFail(userAddress: Address) = {
  match this.getString(keyUser2NumMapping(userAddress.toString())) {
    case s: String => s.parseInt().valueOrErrorMessage(wrapErr("invalid user number"))
    case _: Unit => throwErr("invalid user")
  }
}

func getGwxAmountTotal() = {
  this.getInteger(keyGwxTotal()).valueOrElse(0)
}

func getLockedGwxAmount(userAddress: Address) = {
  let functionName = "getLockedGwxAmount"
  let votingEmissionRateContract = {
    match votingEmissionContract.getString(keyVotingEmissionRateContract) {
      case _: Unit => unit
      case s: String => addressFromString(s)
    }
  }.valueOrErrorMessage(wrapErr("invalid voting emission rate address"))
  let lockedVotingEmissionRate = votingEmissionContract.invoke(functionName, [userAddress.toString()], []).exactAs[Int]
  let lockedVotingEmission = votingEmissionRateContract.invoke(functionName, [userAddress.toString()], []).exactAs[Int]

  let locked = max([
    lockedVotingEmissionRate,
    lockedVotingEmission
  ])

  locked
}

func HistoryEntry(type: String, user: String, amount: Int, lockStart: Int, duration: Int, gwxAmount: Int, i: Invocation) = {
  let historyKEY = makeString(["%s%s%s%s__history", type, user, i.transactionId.toBase58String()], SEP)
  let historyDATA = makeString([
    "%d%d%d%d%d%d%d",
    lastBlock.height.toString(),
    lastBlock.timestamp.toString(),
    amount.toString(),
    lockStart.toString(),
    duration.toString(),
    gwxAmount.toString()
  ], SEP)
  StringEntry(historyKEY, historyDATA)
}

func StatsEntry(totalLockedInc: Int, durationInc: Int, lockCountInc: Int, usersCountInc: Int) = {
  let locksDurationSumInBlocksKEY = keyStatsLocksDurationSumInBlocks()
  let locksCountKEY = keyStatsLocksCount()
  let usersCountKEY = keyStatsUsersCount()
  let totalAmountKEY = keyLockParamTotalAmount()

  let locksDurationSumInBlocks = this.getIntOrZero(locksDurationSumInBlocksKEY)
  let locksCount = this.getIntOrZero(locksCountKEY)
  let usersCount = this.getIntOrZero(usersCountKEY)
  let totalAmount = this.getIntOrZero(totalAmountKEY)

  [IntegerEntry(locksDurationSumInBlocksKEY, locksDurationSumInBlocks + durationInc),
  IntegerEntry(locksCountKEY, locksCount + lockCountInc),
  IntegerEntry(usersCountKEY, usersCount + usersCountInc),
  IntegerEntry(totalAmountKEY, totalAmount + totalLockedInc)]
}

func LockParamsEntry(
  userAddress: Address,
  txId: ByteVector|Unit,
  amount: Int,
  start: Int,
  duration: Int,
  gwxAmount: Int,
  wxClaimed: Int
) = {
  [
    StringEntry(
      keyLockParamsRecord(userAddress, txId),
      formatLockParamsRecord(amount, start, duration, gwxAmount, wxClaimed)
    )
  ]
}

func extractOptionalPaymentAmountOrFail(i: Invocation, expectedAssetId: ByteVector) = {
  if (i.payments.size() > 1) then throwErr("only one payment is allowed") else
  if (i.payments.size() == 0) then 0 else
  let pmt = i.payments[0]
  if (pmt.assetId.value() != expectedAssetId) then throwErr("invalid asset id in payment") else
  pmt.amount
}

func getUserGwxAmountTotal(userAddress: Address) = {
  this.getInteger(keyUserGwxAmountTotal(userAddress)).valueOrElse(0)
}

func getVotingEmissionEpochInfo() = {
  let (currentEpochUi, lastFinalizedEpoch) = {
    let currentEpochUi = votingEmissionContract.getInteger(keyCurrentEpochUi()).value()
    let lastFinalizedEpoch = currentEpochUi - 1
    if (lastFinalizedEpoch < 0) then "invalid epoch".throwErr() else (currentEpochUi, lastFinalizedEpoch)
  }

  let currentEpochStartHeight = votingEmissionContract.getInteger(currentEpochUi.keyStartHeightByEpoch()).value()

  (lastFinalizedEpoch, currentEpochStartHeight)
}

func getPoolAssetsByLpAssetId(lpAssetIdStr: String) = {
  let idxAmountAssetId = 4
  let idxPriceAssetId = 5
  let poolCfg = factoryContract.invoke("getPoolConfigByLpAssetIdREADONLY", [lpAssetIdStr], []).exactAs[List[Any]]
  let amountAssetId = poolCfg[idxAmountAssetId].exactAs[String]
  let priceAssetId = poolCfg[idxPriceAssetId].exactAs[String]

  (amountAssetId, priceAssetId)
}

func getUserVoteFinalized(lpAssetIdStr: String, userAddressStr: String) = {
  let userAddress = userAddressStr.addressFromStringValue()
  let (lastFinalizedEpoch, currentEpochStartHeight) = getVotingEmissionEpochInfo()
  let (amountAssetId, priceAssetId) = lpAssetIdStr.getPoolAssetsByLpAssetId()
  let userVoteKey = keyVote(amountAssetId, priceAssetId, userAddress, lastFinalizedEpoch)
  let userVote = votingEmissionContract.getInteger(userVoteKey).valueOrElse(0)
  
  userVote
}

func getUserVoteStaked(lpAssetIdStr: String, userAddressStr: String) = {
  let stakedByUser = stakingContract.getInteger(keyStakedByUser(userAddressStr, lpAssetIdStr)).valueOrElse(0)
  let userVote = lpAssetIdStr.getUserVoteFinalized(userAddressStr)
  
  if (stakedByUser == 0) then 0 else userVote
}

func getVotingResultStaked(lpAssetIdStr: String) = {
  let (lastFinalizedEpoch, currentEpochStartHeight) = getVotingEmissionEpochInfo()
  let votingResultStakedStart = votingEmissionContract.getInteger(lpAssetIdStr.keyVotingResultStaked(lastFinalizedEpoch)).valueOrElse(0)
  let votingResultStaked = this.getInteger(lpAssetIdStr.keyVotingResultStaked(lastFinalizedEpoch)).valueOrElse(votingResultStakedStart)

  votingResultStaked
}

func getVotingResultStakedIntegral(lpAssetIdStr: String) = {
  let (lastFinalizedEpoch, currentEpochStartHeight) = getVotingEmissionEpochInfo()
  let votingResultStaked = lpAssetIdStr.getVotingResultStaked()
  let votingResultStakedIntegralPrev = this.getInteger(
    lpAssetIdStr.keyVotingResultStakedIntegral(lastFinalizedEpoch)
  ).valueOrElse(0)
  let votingResultStakedLastUpdateHeight = this.getInteger(
    lpAssetIdStr.keyVotingResultStakedLastUpdateHeight(lastFinalizedEpoch)
  ).valueOrElse(currentEpochStartHeight)
  let votingResultStakedIntegralDh = height - votingResultStakedLastUpdateHeight
  let votingResultStakedIntegral = votingResultStakedIntegralDh * votingResultStaked + votingResultStakedIntegralPrev

  votingResultStakedIntegral
}

# Voting result staked is changing only when staked vote is changing
# So this function is called in refreshVoteStakedIntegral
func refreshVotingResultStakedIntegral(
  lpAssetIdStr: String,
  stakedVoteDelta: Int
) = {
  let (lastFinalizedEpoch, currentEpochStartHeight) = getVotingEmissionEpochInfo()
  let votingResultStaked = lpAssetIdStr.getVotingResultStaked()
  let votingResultStakedNew = votingResultStaked + stakedVoteDelta
  let votingResultStakedIntegral = lpAssetIdStr.getVotingResultStakedIntegral()

  [
    IntegerEntry(lpAssetIdStr.keyVotingResultStaked(lastFinalizedEpoch), votingResultStakedNew),
    IntegerEntry(lpAssetIdStr.keyVotingResultStakedLastUpdateHeight(lastFinalizedEpoch), height),
    IntegerEntry(lpAssetIdStr.keyVotingResultStakedIntegral(lastFinalizedEpoch), votingResultStakedIntegral)
  ]
}

func getUserVoteStakedIntegral(lpAssetIdStr: String, userAddressStr: String) = {
  let (lastFinalizedEpoch, currentEpochStartHeight) = getVotingEmissionEpochInfo()
  let userAddress = userAddressStr.addressFromStringValue()
  let userVoteStaked = lpAssetIdStr.getUserVoteStaked(userAddressStr)
  let userVoteStakedIntegralPrev = this.getInteger(
    lpAssetIdStr.keyVoteStakedIntegral(userAddress, lastFinalizedEpoch)
  ).valueOrElse(0)
  let userVoteStakedLastUpdateHeight = this.getInteger(
    lpAssetIdStr.keyVoteStakedLastUpdateHeight(userAddress, lastFinalizedEpoch)
  ).valueOrElse(currentEpochStartHeight)
  let userVoteStakedIntegralDh = height - userVoteStakedLastUpdateHeight
  let userVoteStakedIntegral = userVoteStakedIntegralDh * userVoteStaked + userVoteStakedIntegralPrev

  userVoteStakedIntegral
}

func refreshVoteStakedIntegral(
  lpAssetIdStr: String,
  userAddressStr: String,
  edge: Boolean # true: add, false: remove
) = {
  let (lastFinalizedEpoch, currentEpochStartHeight) = getVotingEmissionEpochInfo()
  let userAddress = userAddressStr.addressFromStringValue()

  let userVoteFinalized = lpAssetIdStr.getUserVoteFinalized(userAddressStr)

  let actions = if (userVoteFinalized == 0) then [] else {
    let stakedVoteDelta = if (edge) then userVoteFinalized else -userVoteFinalized
    let votingResultActions = lpAssetIdStr.refreshVotingResultStakedIntegral(stakedVoteDelta)

    let userVoteStakedIntegral = lpAssetIdStr.getUserVoteStakedIntegral(userAddressStr)
    let voteActions = [
      IntegerEntry(lpAssetIdStr.keyVoteStakedLastUpdateHeight(userAddress, lastFinalizedEpoch), height),
      IntegerEntry(lpAssetIdStr.keyVoteStakedIntegral(userAddress, lastFinalizedEpoch), userVoteStakedIntegral)
    ]

    votingResultActions ++ voteActions
  }

  actions
}

func getStakedVotesIntegralsDiff(lpAssetIdStr: String, userAddressStr: String) = {
  let (lastFinalizedEpoch, currentEpochStartHeight) = getVotingEmissionEpochInfo()
  let userAddress = userAddressStr.addressFromStringValue()

  let userVoteStakedIntegralLastKey = lpAssetIdStr.keyVoteStakedIntegralLast(userAddress, lastFinalizedEpoch)
  let userVoteStakedIntegralLast = this.getInteger(userVoteStakedIntegralLastKey).valueOrElse(0)
  let votingResultStakedIntegralLastKey = lpAssetIdStr.keyVotingResultStakedIntegralLast(userAddress, lastFinalizedEpoch)
  let votingResultStakedIntegralLast = this.getInteger(votingResultStakedIntegralLastKey).valueOrElse(0)
  let userVoteStakedIntegral = lpAssetIdStr.getUserVoteStakedIntegral(userAddressStr)
  let votingResultStakedIntegral = lpAssetIdStr.getVotingResultStakedIntegral()
  let userVoteStakedIntegralDiff = userVoteStakedIntegral - userVoteStakedIntegralLast
  let votingResultStakedIntegralDiff = votingResultStakedIntegral - votingResultStakedIntegralLast

  (
    [
      IntegerEntry(userVoteStakedIntegralLastKey, userVoteStakedIntegral),
      IntegerEntry(votingResultStakedIntegralLastKey, votingResultStakedIntegral)
    ],
    userVoteStakedIntegralDiff,
    votingResultStakedIntegralDiff
  )
}

# Actions should be applied if wxEmissionPerBlock or boostCoeff changes
func refreshBoostEmissionIntegral() = {
  let wxEmissionPerBlock = emissionContract.getIntOrFail(keyEmissionRatePerBlockCurrent())
  let boostingV2LastUpdateHeightOption = this.getInteger(keyBoostingV2LastUpdateHeight())
  let boostingV2IngergalOption = this.getInteger(keyBoostingV2Integral())
  let emissionEnd = emissionContract.getIntOrFail(keyEmissionEndBlock())
  let h = if (height > emissionEnd) then emissionEnd else height

  let dh = match boostingV2LastUpdateHeightOption {
    case lastUpdateHeight: Int => max([h - lastUpdateHeight, 0])
    case _: Unit => 0
  }

  let boostEmissionPerBlock = wxEmissionPerBlock * (boostCoeff - 1) / boostCoeff
  let boostEmissionIntegralPrev = boostingV2IngergalOption.valueOrElse(0)
  let boostEmissionIntegral = boostEmissionPerBlock * dh + boostEmissionIntegralPrev

  (
    [
      IntegerEntry(keyBoostingV2Integral(), boostEmissionIntegral),
      IntegerEntry(keyBoostingV2LastUpdateHeight(), height)
    ],
    boostEmissionIntegral
  )
}

func internalClaimWxBoost(lpAssetIdStr: String, userAddressStr: String, readOnly: Boolean) = {
  let userAddress = addressFromString(userAddressStr).valueOrErrorMessage(wrapErr("invalid user address"))

  strict userNum = userNumberByAddressOrFail(userAddress)

  let EMPTYSTR = "empty" # is used from REST
  let poolWeight = if (lpAssetIdStr != EMPTYSTR) then {
    let poolAddressStr = factoryContract.getString(keyFactoryLpAssetToPoolContractAddress(lpAssetIdStr)).valueOrErrorMessage(("unsupported lp asset " + lpAssetIdStr).wrapErr())
    factoryContract.getIntegerValue(poolAddressStr.keyFactoryPoolWeight())
  } else {
    if (readOnly) then 0 else throwErr("not readonly mode: unsupported lp asset " + lpAssetIdStr)
  }

  # BOOST INTEGRAL RECALC
  # updated by claim
  let userLpBoostEmissionLastIntegralKEY = keyUserLpBoostEmissionLastINTEGRAL(userNum, lpAssetIdStr)
  # updated by lock
  let userBoostEmissionLastIntegralKEY = keyUserBoostEmissionLastINTEGRAL(userNum)

  let userBoostEmissionLastIntegral = this.getInteger(userLpBoostEmissionLastIntegralKEY)
    .valueOrElse(this.getIntOrZero(userBoostEmissionLastIntegralKEY))

  let boostEmissionIntegral = refreshBoostEmissionIntegral()._2
  let userBoostEmissionIntegral = boostEmissionIntegral - userBoostEmissionLastIntegral

  if (userBoostEmissionIntegral < 0) then throwErr("wrong calculations") else

  let (stakedVotesIntegralsActions, userVoteIntegralDiff, totalVotesIntegralDiff) = getStakedVotesIntegralsDiff(lpAssetIdStr, userAddressStr)

  let poolUserBoostEmissionIntegral = fraction(userBoostEmissionIntegral, poolWeight, POOLWEIGHTMULT)

  let userBoostAvaliableToClaimTotalNew = if (totalVotesIntegralDiff == 0) then 0 else {
    fraction(poolUserBoostEmissionIntegral, userVoteIntegralDiff, totalVotesIntegralDiff)
  }

  # BOOST INTEGRAL
  let dataState = [
    IntegerEntry(userLpBoostEmissionLastIntegralKEY, boostEmissionIntegral)
  ] ++ stakedVotesIntegralsActions

  let debug = [
    userBoostEmissionLastIntegral.toString(),
    userBoostEmissionIntegral.toString(),
    poolWeight.toString(),
    userVoteIntegralDiff.toString(),
    totalVotesIntegralDiff.toString()
  ].makeString(":")

  (userBoostAvaliableToClaimTotalNew, dataState, debug)
}

func lockActions(i: Invocation, duration: Int) = {
  let assetIdStr = assetId.toBase58String()
  if (i.payments.size() != 1) then throwErr("invalid payment - exact one payment must be attached") else
  let pmt = i.payments[0]
  let pmtAmount = pmt.amount

  if (assetId != pmt.assetId.value()) then throwErr("invalid asset is in payment - " + assetIdStr + " is expected") else

  let nextUserNumKEY = keyNextUserNum()
  let userAddress = i.caller
  let userAddressStr = userAddress.toString()

  let userIsExisting = getString(keyUser2NumMapping(userAddressStr)).isDefined()
  let userNumStr = if (userIsExisting) then {
    getString(keyUser2NumMapping(userAddressStr)).value()
  } else { # new user
    this.getIntOrFail(nextUserNumKEY).toString()
  }
  let userNum = userNumStr.parseIntValue()
  let lockStart = height

  if ((pmtAmount < minLockAmount) && userAddress != lpStakingPoolsContract) then throwErr("amount is less then minLockAmount=" + minLockAmount.toString()) else
  if (duration < minLockDuration) then throwErr("passed duration is less than minLockDuration=" + minLockDuration.toString()) else
  if (duration > maxLockDuration) then throwErr("passed duration is greater than maxLockDuration=" + maxLockDuration.toString()) else
  if (duration % lockStepBlocks != 0) then throwErr("duration must be multiple of lockStepBlocks=" + lockStepBlocks.toString()) else

  let gWxAmountStart = fraction(pmtAmount, duration, maxLockDuration)

  let gwxAmountTotal = getGwxAmountTotal()

  let userBoostEmissionLastIntegralKEY = keyUserBoostEmissionLastINTEGRAL(userNum)
  let boostEmissionIntegral = refreshBoostEmissionIntegral()._2

  let userGwxAmountTotal = getUserGwxAmountTotal(userAddress)

  strict gwxRewardInv = gwxRewardContract.invoke("refreshUserReward", [userAddress.bytes, userNum], [])

  let arr = if (userIsExisting) then [] else [
    IntegerEntry(nextUserNumKEY, userNum + 1),
    StringEntry(keyUser2NumMapping(userAddressStr), userNumStr),
    StringEntry(keyNum2UserMapping(userNumStr), userAddressStr)
  ]
  (arr ++ LockParamsEntry(userAddress, i.transactionId, pmtAmount, lockStart, duration, gWxAmountStart, 0)
  ++ StatsEntry(pmtAmount, duration, 1, if (userIsExisting) then 0 else 1)
  :+ HistoryEntry("lock", userAddressStr, pmtAmount, lockStart, duration, gWxAmountStart, i)
  ++ [
    IntegerEntry(userBoostEmissionLastIntegralKEY, boostEmissionIntegral),
    IntegerEntry(keyGwxTotal(), gwxAmountTotal + gWxAmountStart),
    IntegerEntry(keyUserGwxAmountTotal(userAddress), userGwxAmountTotal + gWxAmountStart)
  ], gWxAmountStart)
}

func getWxWithdrawable(userAddress: Address, txIdOption: ByteVector|Unit) = {
  let userRecordArray = readLockParamsRecordOrFail(
    userAddress,
    txIdOption
  )

  let userAmount = userRecordArray[IdxLockAmount].parseIntValue()
  let lockStart = userRecordArray[IdxLockStart].parseIntValue()
  let lockDuration = userRecordArray[IdxLockDuration].parseIntValue()
  let lockEnd = lockStart + lockDuration
  let wxClaimed = userRecordArray[IdxLockWxClaimed].parseIntValue()

  let t = (height - lockStart) / blocksInPeriod

  let exponent = fraction(
    t.toBigInt(),
    { DECAY_CONSTANT * blocksInPeriod }.toBigInt() * MULT18BI,
    lockDuration.toBigInt()
  )
  let wxWithdrawableTotal = if (height > lockEnd) then {
    userAmount
  } else {
    fraction(
      userAmount.toBigInt(),
      MULT18BI - pow(5.toBigInt(), 1, exponent, SCALE18, SCALE18, DOWN),
      MULT18BI
    ).toInt()
  }
  let wxWithdrawable = wxWithdrawableTotal - wxClaimed

  wxWithdrawable
}

@Callable(i)
func lockRef(duration: Int, referrerAddress: String, signature: ByteVector) = {
  strict suspensionCheck = throwIfSuspended()
  let (lockActionsResult, gWxAmountStart) = i.lockActions(duration)
  let referralAddress = i.caller.toString()
  strict refInv = if (referrerAddress == "" || signature == base58'') then unit else {
    referralsContractAddressOrFail.invoke("createPair", [referralProgramName, referrerAddress, referralAddress, signature], [])
  }
  strict updateRefActivity = mathContract.invoke("updateReferralActivity", [i.caller.toString(), gWxAmountStart], [])

  (lockActionsResult, unit)
}

@Callable(i)
func lock(duration: Int) = {
  strict suspensionCheck = throwIfSuspended()
  let (lockActionsResult, gWxAmountStart) = i.lockActions(duration)
  strict updateRefActivity = mathContract.invoke("updateReferralActivity", [i.caller.toString(), gWxAmountStart], [])

  (lockActionsResult, unit)
}

@Callable(i)
func claimWxBoost(lpAssetIdStr: String, userAddressStr: String) = {
  strict suspensionCheck = throwIfSuspended()
  if (stakingContract != i.caller) then throwErr("permissions denied") else
  let (userBoostAvailable, dataState, debug) = internalClaimWxBoost(lpAssetIdStr, userAddressStr, false)

  (dataState, [userBoostAvailable])
}

@Callable(i)
func claimWxBoostREADONLY(lpAssetIdStr: String, userAddressStr: String) = {
  let (userBoostAvailable, dataState, debug) = internalClaimWxBoost(lpAssetIdStr, userAddressStr, true)
  ([], [userBoostAvailable, debug])
}

@Callable(i)
func unlock(txIdStr: String) = {
  strict suspensionCheck = throwIfSuspended()
  let userAddress = i.caller
  let userAddressStr = userAddress.toString()
  let txIdOption = if (txIdStr == "") then unit else txIdStr.fromBase58String()
  let userRecordArray = readLockParamsRecordOrFail(
    userAddress,
    txIdOption
  )

  let userAmount = userRecordArray[IdxLockAmount].parseIntValue()
  let lockStart = userRecordArray[IdxLockStart].parseIntValue()
  let lockDuration = userRecordArray[IdxLockDuration].parseIntValue()
  let wxClaimed = userRecordArray[IdxLockWxClaimed].parseIntValue()
  let gwxAmount = userRecordArray[IdxLockGwxAmount].parseIntValue()

  let t = (height - lockStart) / blocksInPeriod

  let wxWithdrawable = getWxWithdrawable(
    userAddress,
    txIdOption
  )

  let gWxAmountStart = fraction(userAmount, lockDuration, maxLockDuration)

  let gwxBurned = min([
    fraction(t * blocksInPeriod, gWxAmountStart, maxLockDuration),
    gwxAmount
  ])
  let gwxRemaining = ensurePositive(gwxAmount - gwxBurned, "gwxRemaining")
  let lockedGwxAmount = getLockedGwxAmount(userAddress)

  if (wxWithdrawable <= 0) then throwErr("nothing to unlock") else

  let gwxAmountTotal = getGwxAmountTotal()
  let userGwxAmountTotal = getUserGwxAmountTotal(userAddress)
  let userGwxAmountTotalNew = ensurePositive(userGwxAmountTotal - gwxBurned, "userGwxAmountTotalNew")

  if (userGwxAmountTotalNew < lockedGwxAmount)
    then throwErr("locked gwx amount: " + lockedGwxAmount.toString())
    else
  let userNum = getString(keyUser2NumMapping(userAddressStr))
    .valueOrErrorMessage(wrapErr("invalid user number")).parseIntValue()
  strict gwxRewardInv = gwxRewardContract.invoke("refreshUserReward", [userAddress.bytes, userNum], [])

  LockParamsEntry(userAddress, txIdOption, userAmount, lockStart, lockDuration, gwxRemaining, wxClaimed + wxWithdrawable)
    ++ StatsEntry(-wxWithdrawable, 0, 0, 0)
    :+ HistoryEntry("unlock", userAddressStr, wxWithdrawable, lockStart, lockDuration, gwxBurned, i)
    :+ ScriptTransfer(userAddress, wxWithdrawable, assetId)
    ++ [
      IntegerEntry(keyGwxTotal(), ensurePositive(gwxAmountTotal - gwxBurned, "gwxTotal")),
      IntegerEntry(keyUserGwxAmountTotal(userAddress), userGwxAmountTotalNew)
    ]
}

@Callable(i)
func gwxUserInfoREADONLY(userAddressStr: String) = {
  let userAddress = userAddressStr.addressFromString()
    .valueOrErrorMessage(wrapErr("invalid user address"))

  let gwxAmount = getUserGwxAmountTotal(userAddress)

  ([], [gwxAmount])
}

# for lp_staking_pools
@Callable(i)
func userMaxDurationREADONLY(userAddressStr: String) = {
  ([], ("lock", maxLockDuration))
}

# targetHeight is unused
@Callable(i)
func getUserGwxAmountAtHeightREADONLY(userAddressStr: String, targetHeight: Int) = {
  let userAddress = userAddressStr.addressFromString()
    .valueOrErrorMessage(wrapErr("invalid user address"))
  let gwxAmount = userAddress.getUserGwxAmountTotal()

  ([], gwxAmount)
}

@Callable(i)
func getUserGwxAmount(userAddressStr: String) = {
  let userAddress = userAddressStr.addressFromString()
    .valueOrErrorMessage(wrapErr("invalid user address"))
  let gwxAmount = userAddress.getUserGwxAmountTotal()

  ([], gwxAmount)
}

@Callable(i)
func getGwxTotalREADONLY() = {
  ([], getGwxAmountTotal())
}

# call this function when wxEmissionRate or boostCoeff changes
@Callable(i)
func onBoostEmissionUpdate() = {
  strict suspensionCheck = throwIfSuspended()
  strict checkCaller = i.caller == emissionContract || i.mustManager()
  refreshBoostEmissionIntegral()
}

# Staked vote = 0 if staked amount = 0
# Staked vote = last finalized vote if staked amount ≥ 0
# So, stakedVote = [stakedAmount ≥ 0] * lastFinalizedVote
#                  └ this is the Iverson bracket, not the array's one
# Staked vote updates when staked amount goes from zero to non-zero or vice versa
# Staked vote integral and voting result integral should be updated when it happens
#                       ╭­ edge = true (rising)
# staked amount > 0:    ┌───┐
# staked amount = 0: ───┘   └───
#                           ╰ edge = false (falling)
@Callable(i)
func onStakedVoteUpdate(lpAssetIdStr: String, userAddressStr: String, edge: Boolean) = {
  strict suspensionCheck = throwIfSuspended()
  strict checkCaller = i.caller == stakingContract || i.mustManager()
  let actions = lpAssetIdStr.refreshVoteStakedIntegral(userAddressStr, edge)

  (actions, unit)
}

@Callable(i)
func getVotingResultStakedREADONLY(lpAssetIdStr: String) = {
  ([], lpAssetIdStr.getVotingResultStaked())
}

@Callable(i)
func getVotingResultStakedIntegralREADONLY(lpAssetIdStr: String) = {
  ([], lpAssetIdStr.getVotingResultStakedIntegral())
}

@Callable(i)
func getUserVoteFinalizedREADONLY(lpAssetIdStr: String, userAddressStr: String) = {
  ([], lpAssetIdStr.getUserVoteFinalized(userAddressStr))
}

@Callable(i)
func getUserVoteStakedIntegralREADONLY(lpAssetIdStr: String, userAddressStr: String) = {
  ([], lpAssetIdStr.getUserVoteStakedIntegral(userAddressStr))
}

@Callable(i)
func suspend(v: Boolean) = {
  strict checkCaller = i.mustManager()

  ([
    BooleanEntry(keySuspension, v)
  ], v)
}

@Verifier(tx)
func verify() = {
  let targetPublicKey = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
}
