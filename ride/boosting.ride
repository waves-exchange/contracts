{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# Required state entries:
# * "%s%s__config__referralsContractAddress": String
# * "%s__nextUserNum": Int
# * "%s%s__config__factoryAddress": String
# * "%s__config": String ("%s%d%d%d__<assetId__<minLockAmount>__<minLockDuration>__<maxLockDuration>__<mathContract>")

let SEP = "__"
let SCALE8  = 8
let MULT8   = 100000000
let POOLWEIGHTMULT = MULT8

func wrapErr(msg: String) = ["boosting.ride:", msg].makeString(" ")
func throwErr(msg: String) = msg.wrapErr().throw()

# getStringOrFail
func strf(address: Address, key: String)   = address.getString(key).valueOrErrorMessage("mandatory this." + key + " is not defined")
# getIntOrZero
func ioz(address: Address, key: String)      = address.getInteger(key).valueOrElse(0)
# getIntOrDefault
func iod(address: Address, key: String, defaultVal: Int)      = address.getInteger(key).valueOrElse(defaultVal)
# getIntOrFail
func iof(address: Address, key: String)      = address.getInteger(key).valueOrErrorMessage("mandatory this." + key + " is not defined")
func abs(val: Int) = if (val < 0) then -val else val

# asAnyList
func aal(val: Any) = {
  match val {
    case valAnyLyst: List[Any] => valAnyLyst
    case _ => throw("fail to cast into List[Any]")
  }
}

# asInt
func ai(val: Any) = {
  match val {
    case valInt: Int => valInt
    case _ => throw("fail to cast into Int")
  }
}

func keyReferralsContractAddress()  = ["%s%s", "config", "referralsContractAddress"].makeString(SEP)
let referralsContractAddressOrFail = this.strf(keyReferralsContractAddress()).addressFromStringValue()

let keyReferralProgramName = ["%s%s", "referral", "programName"].makeString(SEP)
let referralProgramNameDefault = "wxlock"
let referralProgramName = this.getString(keyReferralProgramName).valueOrElse(referralProgramNameDefault)

# FACTORY API
# own factory address key
func keyFactoryAddress()  = "%s%s__config__factoryAddress"

let IdxFactoryCfgStakingDapp    = 1
let IdxFactoryCfgBoostingDapp   = 2
let IdxFactoryCfgIdoDapp        = 3
let IdxFactoryCfgTeamDapp       = 4
let IdxFactoryCfgEmissionDapp   = 5
let IdxFactoryCfgRestDapp       = 6
let IdxFactoryCfgSlippageDapp   = 7
let IdxFactoryCfgDaoDapp        = 8
let IdxFactoryCfgMarketingDapp  = 9
let IdxFactoryCfgGwxRewardDapp  = 10
let IdxFactoryCfgBirdsDapp      = 11

func keyFactoryCfg()      = "%s__factoryConfig"
func keyFactoryLp2AssetsMapping(lpAssetStr: String) = makeString(["%s%s%s", lpAssetStr, "mappings__lpAsset2PoolContract"], SEP)
func keyFactoryLpList()   = "%s__lpTokensList" # not used anymore
func keyFactoryLpAssetToPoolContractAddress(lpAssetStr: String) = makeString(["%s%s%s", lpAssetStr, "mappings__lpAsset2PoolContract"], SEP)
func keyFactoryPoolWeight(contractAddress: String) = { ["%s%s", "poolWeight", contractAddress].makeString(SEP) }
func keyFactoryPoolWeightHistory(poolAddress: String, num: Int) = {"%s%s__poolWeight__" + poolAddress + "__" + num.toString()}

func readFactoryAddressOrFail() = this.strf(keyFactoryAddress()).addressFromStringValue()
func readLpList()               = readFactoryAddressOrFail().getString(keyFactoryLpList()).valueOrElse("").split(SEP)
func readFactoryCfgOrFail(factory: Address)     = factory.strf(keyFactoryCfg()).split(SEP)
func getBoostingAddressOrFail(factoryCfg: List[String]) = factoryCfg[IdxFactoryCfgBoostingDapp].addressFromStringValue()
func getEmissionAddressOrFail(factoryCfg: List[String]) = factoryCfg[IdxFactoryCfgEmissionDapp].addressFromStringValue()
func getStakingAddressOrFail(factoryCfg: List[String])  = factoryCfg[IdxFactoryCfgStakingDapp].addressFromStringValue()
func getGwxRewardAddressOrFail(factoryCfg: List[String])  = factoryCfg[IdxFactoryCfgGwxRewardDapp].addressFromStringValue()

func keyManagerPublicKey() = "%s__managerPublicKey"
func keyPendingManagerPublicKey() = {"%s__pendingManagerPublicKey"}

# EMISSION API
func keyEmissionRatePerBlockCurrent() = "%s%s__ratePerBlock__current"
func keyEmissionRatePerBlockMaxCurrent() = "%s%s__ratePerBlockMax__current"
func keyEmissionStartBlock() = "%s%s__emission__startBlock"
func keyBoostingV2LastUpdateHeight() = "%s%s__boostingV2__startBlock"
func keyBoostingV2Integral() = "%s%s__boostingV2__integral"
func keyEmissionDurationInBlocks() = "%s%s__emission__duration"
func keyEmissionEndBlock() = "%s%s__emission__endBlock"

# GWX REWARD (MATH) API
func keyNextPeriod() = "%s__nextPeriod"
func keyGwxRewardEmissionStartHeight() = "%s%s__gwxRewardEmissionPart__startHeight"

# OWN KEYS
let IdxCfgAssetId             = 1
let IdxCfgMinLockAmount       = 2
let IdxCfgMinLockDuration     = 3
let IdxCfgMaxLockDuration     = 4
let IdxCfgMathContract        = 5

func keyConfig() = {"%s__config"}
func readConfigArrayOrFail() = this.strf(keyConfig()).split(SEP)
let mathContract = readConfigArrayOrFail()[IdxCfgMathContract].addressFromStringValue()

func formatConfigS(assetId: String, minLockAmount: String, minLockDuration: String, maxLockDuration: String, mathContract: String) = {
  makeString([
      "%s%d%d%d",
      assetId,                # 1
      minLockAmount,          # 2
      minLockDuration,        # 3
      maxLockDuration,        # 4
      mathContract            # 5
      ],
  SEP)
}

func formatConfig(assetId: String, minLockAmount: Int, minLockDuration: Int, maxLockDuration: Int, mathContract: String) = {
  formatConfigS(
    assetId,                      # 1
    minLockAmount.toString(),     # 2
    minLockDuration.toString(),   # 3
    maxLockDuration.toString(),   # 4
    mathContract                  # 5
  )
}

func managerPublicKeyOrUnit() = match keyManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func pendingManagerPublicKeyOrUnit() = match keyPendingManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func mustManager(i: Invocation) = {
  let pd = "Permission denied".throw()

  match managerPublicKeyOrUnit() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

let IdxLockUserNum      = 1
let IdxLockAmount       = 2
let IdxLockStart        = 3
let IdxLockDuration     = 4
let IdxLockParamK       = 5
let IdxLockParamB       = 6

func keyLockParamsRecord(userAddress: String) = makeString(["%s%s__lock", userAddress], SEP)
func readLockParamsRecordOrFail(userAddress: String) = this.strf(keyLockParamsRecord(userAddress)).split(SEP)

func formatLockParamsRecordS(userNum: String, amount: String, start: String, duration: String, paramK: String, paramB: String, lastUpdTimestamp: String, gwxAmount: String) = {

  makeString([
      "%d%d%d%d%d%d%d%d",   # 0
      userNum,    # 1
      amount,     # 2
      start,      # 3
      duration,   # 4
      paramK,     # 5
      paramB,     # 6
      lastUpdTimestamp, #7
      gwxAmount   # 8
      ],
  SEP)
}

func formatLockParamsRecord(userNum: String, amount: Int, start: Int, duration: Int, paramK: Int, paramB: Int, gwxAmount: Int) = {
  formatLockParamsRecordS(
    userNum,              # 1
    amount.toString(),    # 2
    start.toString(),     # 3
    duration.toString(),  # 4
    paramK.toString(),    # 5
    paramB.toString(),    # 6
    lastBlock.timestamp.toString(), # 7
    gwxAmount.toString()  # 8
  )
}

# mappings
func keyNextUserNum()                                         = "%s__nextUserNum"
func keyUser2NumMapping(userAddress: String)                  = makeString(["%s%s%s__mapping__user2num", userAddress], SEP)
func keyNum2UserMapping(num: String)                          = makeString(["%s%s%s__mapping__num2user", num], SEP)

func keyLockParamUserAmount(userNum: String)                  = makeString(["%s%d%s__paramByUserNum", userNum, "amount"], SEP)
func keyLockParamStartBlock(userNum: String)                  = makeString(["%s%d%s__paramByUserNum", userNum, "start"], SEP)
func keyLockParamDuration(userNum: String)                    = makeString(["%s%d%s__paramByUserNum", userNum, "duration"], SEP)
func keyLockParamK(userNum: String)                           = makeString(["%s%d%s__paramByUserNum", userNum, "k"], SEP)
func keyLockParamB(userNum: String)                           = makeString(["%s%d%s__paramByUserNum", userNum, "b"], SEP)
func keyLockParamByPeriodK(userNum: String, period: String)   = makeString(["%s%d%s%d__paramByPeriod", userNum, "k", period], SEP)
func keyLockParamByPeriodB(userNum: String, period: String)   = makeString(["%s%d%s%d__paramByPeriod", userNum, "b", period], SEP)

# TODO - consider to concat
func keyLockParamTotalAmount()                                = "%s%s__stats__activeTotalLocked"
func keyStatsLocksDurationSumInBlocks()                       = "%s%s__stats__locksDurationSumInBlocks"
func keyStatsLocksCount()                                     = "%s%s__stats__locksCount"
func keyStatsUsersCount()                                     = "%s%s__stats__activeUsersCount"

# boost integral
func keyUserBoostEmissionLastINTEGRAL(userNum: String)        = makeString(["%s%d__userBoostEmissionLastIntV2", userNum], SEP)
func keyUserLpBoostEmissionLastINTEGRAL(userNum: String, lpAssetId: String) = makeString(["%s%d__userBoostEmissionLastIntV2", userNum, lpAssetId], SEP)
func keyUserMaxBoostINTEGRAL(userNum: String)                 = makeString(["%s%d__maxBoostInt", userNum], SEP)
func keyTotalMaxBoostINTEGRAL()                               = "%s%s__maxBoostInt__total"
func keyUserBoostAvalaibleToClaimTotal(userNum: String)       = makeString(["%s%d__userBoostAvaliableToClaimTotal", userNum], SEP)
func keyUserBoostClaimed(userNum: String)                     = makeString(["%s%d__userBoostClaimed", userNum], SEP)

func keyTotalCachedGwx()                               = "%s%s__gwxCached__total"
func keyTotalCachedGwxCorrective() = "%s__gwxCachedTotalCorrective"

# GLOBAL VARIABLES
# CONSTRUCTOR IS NOT FAILED BECAUSE GLOBAL VARIABLES ARE NOT USED
let factoryContract   = readFactoryAddressOrFail()
let factoryCfg        = factoryContract.readFactoryCfgOrFail()
let emissionContract  = factoryCfg.getEmissionAddressOrFail()
let stakingContract   = factoryCfg.getStakingAddressOrFail()
let gwxRewardContract = factoryCfg.getGwxRewardAddressOrFail()

let keyVotingEmissionContract = ["%s", "votingEmissionContract"].makeString(SEP)
let votingEmissionContract = factoryContract.getStringValue(keyVotingEmissionContract).addressFromStringValue()

let boostCoeff = emissionContract.invoke("getBoostCoeffREADONLY", [], []).exactAs[Int]

func getTotalCachedGwx(correct: Boolean) = {
  let keyCurrentEpochUi = ["%s", "currentEpochUi"].makeString(SEP)
  let currentEpochUi = votingEmissionContract.getIntegerValue(keyCurrentEpochUi)

  let keyTargetEpoch = ["%s%s", "totalCachedGwxCorrection__activationEpoch"].makeString(SEP)
  let targetEpochOption = this.getInteger(keyTargetEpoch)

  let totalCachedGwxRaw = this.getInteger(keyTotalCachedGwx()).valueOrElse(0)

  let isCorrectionActivated = targetEpochOption.isDefined() && (currentEpochUi >= targetEpochOption.value())
  let corrective = if (isCorrectionActivated && correct) then {
    this.getInteger(keyTotalCachedGwxCorrective()).valueOrElse(0)
  } else 0

  max([0, totalCachedGwxRaw + corrective])
}

func HistoryEntry(type: String, user: String, amount: Int, lockStart: Int, duration: Int, k: Int, b: Int, i: Invocation) = {
  let historyKEY = makeString(["%s%s%s%s__history", type, user, i.transactionId.toBase58String()], SEP)
  let historyDATA = makeString([
        "%d%d%d%d%d%d%d",
        lastBlock.height.toString(),
        lastBlock.timestamp.toString(),
        amount.toString(),
        lockStart.toString(),
        duration.toString(),
        k.toString(),
        b.toString()],
    SEP)
  StringEntry(historyKEY, historyDATA)
}

func StatsEntry(totalLockedInc: Int, durationInc: Int, lockCountInc: Int, usersCountInc: Int) = {
  let locksDurationSumInBlocksKEY = keyStatsLocksDurationSumInBlocks()
  let locksCountKEY = keyStatsLocksCount()
  let usersCountKEY = keyStatsUsersCount()
  let totalAmountKEY  = keyLockParamTotalAmount()

  let locksDurationSumInBlocks = this.ioz(locksDurationSumInBlocksKEY)
  let locksCount = this.ioz(locksCountKEY)
  let usersCount = this.ioz(usersCountKEY)
  let totalAmount = this.ioz(totalAmountKEY)

  [IntegerEntry(locksDurationSumInBlocksKEY, locksDurationSumInBlocks + durationInc),
  IntegerEntry(locksCountKEY, locksCount + lockCountInc),
  IntegerEntry(usersCountKEY, usersCount + usersCountInc),
  IntegerEntry(totalAmountKEY, totalAmount + totalLockedInc)]
}

# TODO MOVE INTO MATH CONTRACT
func calcGwxAmount(kRaw: Int, bRaw: Int, h: Int) = {
  let SCALE = 1000 # see math contract
  (kRaw * h + bRaw) / SCALE
}

func LockParamsEntry(userAddress: String, userNum: String, amount: Int, start: Int, duration: Int, k: Int, b: Int, period: String) = {

  let userAmountKEY       = keyLockParamUserAmount(userNum)
  let startBlockKEY       = keyLockParamStartBlock(userNum)
  let durationKEY         = keyLockParamDuration(userNum)
  let kKEY                = keyLockParamK(userNum)
  let bKEY                = keyLockParamB(userNum)
  let kByPeriodKEY        = keyLockParamByPeriodK(userNum, period)
  let bByPeriodKEY        = keyLockParamByPeriodB(userNum, period)

  # TODO think about moving to another place
  let gwxAmount = calcGwxAmount(k, b, height)
  [IntegerEntry(userAmountKEY, amount),
    IntegerEntry(startBlockKEY, start),
    IntegerEntry(durationKEY, duration),
    IntegerEntry(kKEY, k),
    IntegerEntry(bKEY, b),
    IntegerEntry(kByPeriodKEY, k),
    IntegerEntry(bByPeriodKEY, b),
    StringEntry( # fixme: it does not work for multi lock. The key should include period
      keyLockParamsRecord(userAddress),
      formatLockParamsRecord(userNum, amount, start, duration, k, b, gwxAmount))]
}

func extractOptionalPaymentAmountOrFail(i: Invocation, expectedAssetId: ByteVector) = {
  if (i.payments.size() > 1)  then throw("only one payment is allowed") else
  if (i.payments.size() == 0) then 0 else
  let pmt = i.payments[0]
  if (pmt.assetId.value() != expectedAssetId) then throw("invalid asset id in payment") else
  pmt.amount
}

func calcUserGwxAmountAtHeight(userAddress: String, targetHeight: Int) = {
  let EMPTY = "empty"
  let user2NumMappingKEY = keyUser2NumMapping(userAddress)
  let userNum = user2NumMappingKEY.getString().valueOrElse(EMPTY)

  let k = keyLockParamK(userNum).getInteger().valueOrElse(0)
  let b = keyLockParamB(userNum).getInteger().valueOrElse(0)

  let gwxAmountCalc = calcGwxAmount(k, b, targetHeight)
  let gwxAmount = if (gwxAmountCalc < 0 ) then 0 else gwxAmountCalc

  gwxAmount
}

func calcCurrentGwxAmount(userAddress: String) = {
  userAddress.calcUserGwxAmountAtHeight(height)
}

func getVotingEmissionEpochInfo() = {
  let keyCurrentEpochUi = ["%s", "currentEpochUi"].makeString(SEP)
  let (currentEpochUi, lastFinalizedEpoch) = {
    let currentEpochUi = votingEmissionContract.getInteger(keyCurrentEpochUi).value()
    let lastFinalizedEpoch = currentEpochUi - 1
    if (lastFinalizedEpoch < 0) then "invalid epoch".throwErr() else (currentEpochUi, lastFinalizedEpoch)
  }

  func keyStartHeightByEpoch(epoch: Int) = ["%s%d", "startHeight", epoch.toString()].makeString(SEP)

  let currentEpochStartHeight = votingEmissionContract.getInteger(currentEpochUi.keyStartHeightByEpoch()).value()

  (lastFinalizedEpoch, currentEpochStartHeight)
}

func getPoolAssetsByLpAssetId(lpAssetIdStr: String) = {
  let idxAmountAssetId = 4
  let idxPriceAssetId = 5
  let poolCfg = factoryContract.invoke("getPoolConfigByLpAssetId", [lpAssetIdStr], []).exactAs[List[Any]]
  let amountAssetId = poolCfg[idxAmountAssetId].exactAs[String]
  let priceAssetId = poolCfg[idxPriceAssetId].exactAs[String]

  (amountAssetId, priceAssetId)
}

# votingEmission
func keyVote(amountAssetId: String, priceAssetId: String, address: Address, epoch: Int) = {
  ["%s%s%s%s%d", "vote", amountAssetId, priceAssetId, address.toString(), epoch.toString()].makeString(SEP)
}
# this and votingEmission
func keyVotingResultStaked(lpAssetIdStr: String, epoch: Int) = {
  ["%s%s%d", "votingResultStaked", lpAssetIdStr, epoch.toString()].makeString(SEP)
}
# this
func keyVotingResultStakedIntegral(lpAssetIdStr: String, epoch: Int) = {
  ["%s%s%d", "votingResultStakedIntegral", lpAssetIdStr, epoch.toString()].makeString(SEP)
}
func keyVotingResultStakedIntegralLastUpdateHeight(lpAssetIdStr: String, epoch: Int) = {
  ["%s%s%d", "votingResultStakedIntegralLastUpdateHeight", lpAssetIdStr, epoch.toString()].makeString(SEP)
}
func keyVoteStakedIntegral(lpAssetIdStr: String, address: Address, epoch: Int) = {
  ["%s%s%s%d", "voteStakedIntegral", lpAssetIdStr, address.toString(), epoch.toString()].makeString(SEP)
}
func keyVoteStakedIntegralLast(lpAssetIdStr: String, address: Address, epoch: Int) = {
  ["%s%s%s%d", "voteStakedIntegralsLast", lpAssetIdStr, address.toString(), epoch.toString()].makeString(SEP)
}
func keyVotingResultStakedIntegralLast(lpAssetIdStr: String, address: Address, epoch: Int) = {
  ["%s%s%s%d", "votingResultStakedIntegralLast", lpAssetIdStr, address.toString(), epoch.toString()].makeString(SEP)
}
func keyVoteStakedIntegralLastUpdateHeight(lpAssetIdStr: String, address: Address, epoch: Int) = {
  ["%s%s%s%d", "voteStakedIntegralLastUpdateHeight", lpAssetIdStr, address.toString(), epoch.toString()].makeString(SEP)
}

# staking
func keyStakedByUser(userAddressStr: String, lpAssetIdStr: String) = ["%s%s%s", "staked", userAddressStr, lpAssetIdStr].makeString(SEP)

func getUserVoteFinalized(lpAssetIdStr: String, userAddressStr: String) = {
  let userAddress = userAddressStr.addressFromStringValue()
  let (lastFinalizedEpoch, currentEpochStartHeight) = getVotingEmissionEpochInfo()
  let (amountAssetId, priceAssetId) = lpAssetIdStr.getPoolAssetsByLpAssetId()
  let userVote = votingEmissionContract.getInteger(keyVote(amountAssetId, priceAssetId, userAddress, lastFinalizedEpoch)).valueOrElse(0)
  
  userVote
}

func getUserVoteStaked(lpAssetIdStr: String, userAddressStr: String) = {
  let stakedByUser = stakingContract.getInteger(keyStakedByUser(userAddressStr, lpAssetIdStr)).valueOrElse(0)
  let userVote = lpAssetIdStr.getUserVoteFinalized(userAddressStr)
  
  if (stakedByUser == 0) then 0 else userVote
}

func getVotingResultStaked(lpAssetIdStr: String) = {
  let (lastFinalizedEpoch, currentEpochStartHeight) = getVotingEmissionEpochInfo()
  let votingResultStakedStart = votingEmissionContract.getInteger(lpAssetIdStr.keyVotingResultStaked(lastFinalizedEpoch)).valueOrElse(0)
  let votingResultStaked = this.getInteger(lpAssetIdStr.keyVotingResultStaked(lastFinalizedEpoch)).valueOrElse(votingResultStakedStart)

  votingResultStaked
}

func refreshVotingResultStakedIntegral(
  lpAssetIdStr: String,
  stakedVoteDelta: Int
) = {
  let (lastFinalizedEpoch, currentEpochStartHeight) = getVotingEmissionEpochInfo()
  let votingResultStaked = lpAssetIdStr.getVotingResultStaked()
  let votingResultStakedNew = votingResultStaked + stakedVoteDelta
  let votingResultStakedIntegralPrev = this.getInteger(lpAssetIdStr.keyVotingResultStakedIntegral(lastFinalizedEpoch)).valueOrElse(0)
  let votingResultStakedIntegralLastUpdateHeight = this.getInteger(lpAssetIdStr.keyVotingResultStakedIntegralLastUpdateHeight(lastFinalizedEpoch)).valueOrElse(currentEpochStartHeight)
  let votingResultStakedIntegralDh = height - votingResultStakedIntegralLastUpdateHeight
  let votingResultStakedIntegral = votingResultStakedIntegralDh * votingResultStaked + votingResultStakedIntegralPrev

  (
    [
      IntegerEntry(lpAssetIdStr.keyVotingResultStaked(lastFinalizedEpoch), votingResultStakedNew),
      IntegerEntry(lpAssetIdStr.keyVotingResultStakedIntegralLastUpdateHeight(lastFinalizedEpoch), height),
      IntegerEntry(lpAssetIdStr.keyVotingResultStakedIntegral(lastFinalizedEpoch), votingResultStakedIntegral)
    ],
    votingResultStakedIntegral
  )
}

func refreshVoteStakedIntegral(
  lpAssetIdStr: String,
  userAddressStr: String,
  edge: Boolean # true: add, false: remove
) = {
  let (lastFinalizedEpoch, currentEpochStartHeight) = getVotingEmissionEpochInfo()
  let userAddress = userAddressStr.addressFromStringValue()

  let idxAmountAssetId = 4
  let idxPriceAssetId = 5
  let poolCfg = factoryContract.invoke("getPoolConfigByLpAssetId", [lpAssetIdStr], []).exactAs[List[Any]]
  let amountAssetId = poolCfg[idxAmountAssetId].exactAs[String]
  let priceAssetId = poolCfg[idxPriceAssetId].exactAs[String]

  let userVote = votingEmissionContract.getInteger(keyVote(amountAssetId, priceAssetId, userAddress, lastFinalizedEpoch)).valueOrElse(0)

  let actions = if (userVote == 0) then [] else {
    let stakedVoteDelta = if (edge) then userVote else -userVote
    let (votingResultActions, votingResultStakedIntegral) = lpAssetIdStr.refreshVotingResultStakedIntegral(stakedVoteDelta)

    let userVoteStaked = if (edge) then 0 else userVote 
    let userVoteStakedIntegralPrev = this.getInteger(lpAssetIdStr.keyVoteStakedIntegral(userAddress, lastFinalizedEpoch)).valueOrElse(0)
    let userVoteStakedIntegralLastUpdateHeight = this.getInteger(lpAssetIdStr.keyVoteStakedIntegralLastUpdateHeight(userAddress, lastFinalizedEpoch)).valueOrElse(currentEpochStartHeight)
    let userVoteStakedIntegralDh = height - userVoteStakedIntegralLastUpdateHeight
    let userVoteStakedIntegral = userVoteStakedIntegralDh * userVoteStaked + userVoteStakedIntegralPrev
    let voteActions = [
      IntegerEntry(lpAssetIdStr.keyVoteStakedIntegralLastUpdateHeight(userAddress, lastFinalizedEpoch), height),
      IntegerEntry(lpAssetIdStr.keyVoteStakedIntegral(userAddress, lastFinalizedEpoch), userVoteStakedIntegral)
    ]

    votingResultActions ++ voteActions
  }

  actions
}

func getStakedVotesIntegralsDiff(lpAssetIdStr: String, userAddressStr: String) = {
  let (lastFinalizedEpoch, currentEpochStartHeight) = getVotingEmissionEpochInfo()
  let userAddress = userAddressStr.addressFromStringValue()

  let userVoteStaked = lpAssetIdStr.getUserVoteStaked(userAddressStr)
  let votingResultStaked = lpAssetIdStr.getVotingResultStaked()
  let userVoteStakedIntegralPrev = this.getInteger(lpAssetIdStr.keyVoteStakedIntegral(userAddress, lastFinalizedEpoch)).valueOrElse(0)
  let votingResultStakedIntegralPrev = this.getInteger(lpAssetIdStr.keyVotingResultStakedIntegral(lastFinalizedEpoch)).valueOrElse(0)
  let userVoteStakedIntegralLastUpdateHeight = this.getInteger(lpAssetIdStr.keyVoteStakedIntegralLastUpdateHeight(userAddress, lastFinalizedEpoch)).valueOrElse(currentEpochStartHeight)
  let votingResultStakedIntegralLastUpdateHeight = this.getInteger(lpAssetIdStr.keyVotingResultStakedIntegralLastUpdateHeight(lastFinalizedEpoch)).valueOrElse(currentEpochStartHeight)
  let userVoteStakedIntegralLast = this.getInteger(lpAssetIdStr.keyVoteStakedIntegralLast(userAddress, lastFinalizedEpoch)).valueOrElse(0)
  let votingResultStakedIntegralLast = this.getInteger(lpAssetIdStr.keyVotingResultStakedIntegralLast(userAddress, lastFinalizedEpoch)).valueOrElse(0)
  let userVoteStakedIntegralDh = height - userVoteStakedIntegralLastUpdateHeight
  let votingResultStakedIntegralDh = height - votingResultStakedIntegralLastUpdateHeight
  let userVoteStakedIntegral = userVoteStakedIntegralDh * userVoteStaked + userVoteStakedIntegralPrev
  let votingResultStakedIntegral = votingResultStakedIntegralDh * votingResultStaked + votingResultStakedIntegralPrev
  let userVoteStakedIntegralDiff = userVoteStakedIntegral - userVoteStakedIntegralLast
  let votingResultStakedIntegralDiff = votingResultStakedIntegral - votingResultStakedIntegralLast

  (
    [
      IntegerEntry(lpAssetIdStr.keyVoteStakedIntegralLast(userAddress, lastFinalizedEpoch), userVoteStakedIntegral),
      IntegerEntry(lpAssetIdStr.keyVotingResultStakedIntegralLast(userAddress, lastFinalizedEpoch), votingResultStakedIntegral)
    ],
    userVoteStakedIntegralDiff,
    votingResultStakedIntegralDiff
  )
}

# Actions should be applied if wxEmissionPerBlock or boostCoeff changes
func refreshBoostEmissionIntegral() = {
  let wxEmissionPerBlock = emissionContract.iof(keyEmissionRatePerBlockCurrent())
  let boostingV2LastUpdateHeightOption = this.getInteger(keyBoostingV2LastUpdateHeight())
  let boostingV2IngergalOption = this.getInteger(keyBoostingV2Integral())
  let emissionEnd = emissionContract.iof(keyEmissionEndBlock())
  let h = if (height > emissionEnd) then emissionEnd else height

  let dh = match boostingV2LastUpdateHeightOption {
    case lastUpdateHeight: Int => max([h - lastUpdateHeight, 0])
    case _: Unit => 0
  }

  let boostEmissionPerBlock = wxEmissionPerBlock * (boostCoeff - 1) / boostCoeff
  let boostEmissionIntegralPrev = boostingV2IngergalOption.valueOrElse(0)
  let boostEmissionIntegral = boostEmissionPerBlock * dh + boostEmissionIntegralPrev

  (
    [
      IntegerEntry(keyBoostingV2Integral(), boostEmissionIntegral),
      IntegerEntry(keyBoostingV2LastUpdateHeight(), height)
    ],
    boostEmissionIntegral
  )
}

func internalClaimWxBoost(lpAssetIdStr: String, userAddressStr: String, readOnly: Boolean) = {
  let userRecordOption = this.getString(keyLockParamsRecord(userAddressStr))
  if (userRecordOption == unit) then (0, [], "userRecord::is::empty") else

  let userRecordArray = userRecordOption.value().split(SEP)
  let userNumStr = userRecordArray[IdxLockUserNum]

  let EMPTYSTR = "empty" # is used from REST
  let poolWeight = if (lpAssetIdStr != EMPTYSTR) then {
    let poolAddressStr = factoryContract.getString(keyFactoryLp2AssetsMapping(lpAssetIdStr)).valueOrErrorMessage("unsupported lp asset " + lpAssetIdStr)
    factoryContract.getIntegerValue(poolAddressStr.keyFactoryPoolWeight())
  } else {
    if (readOnly) then 0 else throw("not readonly mode: unsupported lp asset " + lpAssetIdStr)
  }

  # BOOST INTEGRAL RECALC
  # updated by claim
  let userLpBoostEmissionLastIntegralKEY = keyUserLpBoostEmissionLastINTEGRAL(userNumStr, lpAssetIdStr)
  # updated by lock
  let userBoostEmissionLastIntegralKEY = keyUserBoostEmissionLastINTEGRAL(userNumStr)

  let userBoostEmissionLastIntegral = this.getInteger(userLpBoostEmissionLastIntegralKEY)
    .valueOrElse(this.ioz(userBoostEmissionLastIntegralKEY))

  let boostEmissionIntegral = refreshBoostEmissionIntegral()._2
  let userBoostEmissionIntegral = boostEmissionIntegral - userBoostEmissionLastIntegral

  if (userBoostEmissionIntegral < 0) then throw("wrong calculations") else

  let (stakedVotesIntegralsActions, userVoteIntegralDiff, totalVotesIntegralDiff) = getStakedVotesIntegralsDiff(lpAssetIdStr, userAddressStr)

  let poolUserBoostEmissionIntegral = fraction(userBoostEmissionIntegral, poolWeight, POOLWEIGHTMULT)

  let userBoostAvaliableToClaimTotalNew = if (totalVotesIntegralDiff == 0) then 0 else {
    fraction(poolUserBoostEmissionIntegral, userVoteIntegralDiff, totalVotesIntegralDiff)
  }

  # BOOST INTEGRAL
  let dataState = [
    IntegerEntry(userLpBoostEmissionLastIntegralKEY, boostEmissionIntegral)
  ] ++ stakedVotesIntegralsActions

  let debug = [
    userBoostEmissionLastIntegral.toString(),
    userBoostEmissionIntegral.toString(),
    poolWeight.toString(),
    userVoteIntegralDiff.toString(),
    totalVotesIntegralDiff.toString()
  ].makeString(":")

  (userBoostAvaliableToClaimTotalNew, dataState, debug)
}

func lockActions(i: Invocation, duration: Int) = {
  let cfgArray          = readConfigArrayOrFail()
  let assetIdStr        = cfgArray[IdxCfgAssetId]
  let assetId           = assetIdStr.fromBase58String()
  let minLockAmount     = cfgArray[IdxCfgMinLockAmount].parseIntValue()
  let minLockDuration   = cfgArray[IdxCfgMinLockDuration].parseIntValue()
  let maxLockDuration   = cfgArray[IdxCfgMaxLockDuration].parseIntValue()

  if (i.payments.size() != 1) then throw("invalid payment - exact one payment must be attached") else
  let pmt = i.payments[0]
  let pmtAmount = pmt.amount

  if (assetId != pmt.assetId.value()) then throw("invalid asset is in payment - " + assetIdStr + " is expected") else

  let nextUserNumKEY  = keyNextUserNum()
  let userAddressStr  = i.caller.toString()

  let userIsExisting = getString(keyUser2NumMapping(userAddressStr)).isDefined()
  let userNumStr = if (userIsExisting) then {
    getString(keyUser2NumMapping(userAddressStr)).value()
  } else { # new user
    this.iof(nextUserNumKEY).toString()
  }
  let userNum = userNumStr.parseIntValue()
  let lockStart = height

  let startBlockKEY   = keyLockParamStartBlock(userNumStr)
  let durationKEY     = keyLockParamDuration(userNumStr)

  let userAmountKEY   = keyLockParamUserAmount(userNumStr)

  if (pmtAmount < minLockAmount) then throw("amount is less then minLockAmount=" + minLockAmount.toString()) else
  if (duration < minLockDuration) then throw("passed duration is less then minLockDuration=" + minLockDuration.toString()) else
  if (duration > maxLockDuration) then throw("passed duration is greater then maxLockDuration=" + maxLockDuration.toString()) else
  if (userIsExisting && (this.iof(startBlockKEY) + this.iof(durationKEY)) >= lockStart) then throw("there is an active lock - consider to use increaseLock") else
  if (this.ioz(userAmountKEY) > 0) then throw("there are locked WXs - consider to use increaseLock " + userAmountKEY) else

  let coeffX8 = fraction(duration, MULT8, maxLockDuration)
  let gWxAmountStart = fraction(pmtAmount, coeffX8, MULT8)

  let gWxParamsResultList = invoke(mathContract, "calcGwxParamsREADONLY", [gWxAmountStart, lockStart, duration], []).aal()
  # TODO check the following macros: gWxParamsInvokeResult[0].exactAs[Int]
  let k = gWxParamsResultList[0].ai()
  let b = gWxParamsResultList[1].ai()
  let period = gWxParamsResultList[2].ai().toString()

  let totalCachedGwxRaw = getTotalCachedGwx(false)

  let userBoostEmissionLastIntegralKEY = keyUserBoostEmissionLastINTEGRAL(userNumStr)
  let boostEmissionIntegral = refreshBoostEmissionIntegral()._2

  let arr = if (userIsExisting) then [] else [
    IntegerEntry(nextUserNumKEY, userNum + 1),
    StringEntry(keyUser2NumMapping(userAddressStr), userNumStr),
    StringEntry(keyNum2UserMapping(userNumStr), userAddressStr)
  ]
  (arr ++ LockParamsEntry(userAddressStr, userNumStr, pmtAmount, lockStart, duration, k, b, period)
  ++ StatsEntry(pmtAmount, duration, 1, if (userIsExisting) then 0 else 1)
  :+ HistoryEntry("lock", userAddressStr, pmtAmount, lockStart, duration, k, b, i)
  ++ [
    IntegerEntry(userBoostEmissionLastIntegralKEY, boostEmissionIntegral),
    IntegerEntry(keyTotalCachedGwx(), totalCachedGwxRaw + gWxAmountStart)
  ], gWxAmountStart)
}

@Callable(i)
func constructor(factoryAddressStr: String, lockAssetIdStr: String, minLockAmount: Int, minDuration: Int, maxDuration: Int, mathContract: String) = {
  strict checkCaller = i.mustManager()

  [IntegerEntry(keyNextUserNum(), 0),
    StringEntry(
        keyConfig(),
        formatConfig(lockAssetIdStr, minLockAmount, minDuration, maxDuration, mathContract)),
    StringEntry(keyFactoryAddress(), factoryAddressStr)
  ]
    ++ StatsEntry(0, 0, 0, 0)
}

@Callable(i)
func lockRef(duration: Int, referrerAddress: String, signature: ByteVector) = {
  let (lockActionsResult, gWxAmountStart) = i.lockActions(duration)
  let referralAddress = i.caller.toString()
  strict refInv = if (referrerAddress == "" || signature == base58'') then unit else {
    referralsContractAddressOrFail.invoke("createPair", [referralProgramName, referrerAddress, referralAddress, signature], [])
  }
  strict updateRefActivity = mathContract.invoke("updateReferralActivity", [i.caller.toString(), gWxAmountStart], [])

  (lockActionsResult, unit)
}

@Callable(i)
func lock(duration: Int) = {
  let (lockActionsResult, gWxAmountStart) = i.lockActions(duration)
  strict updateRefActivity = mathContract.invoke("updateReferralActivity", [i.caller.toString(), gWxAmountStart], [])

  (lockActionsResult, unit)
}

@Callable(i)
func increaseLock(deltaDuration: Int) = {
  let cfgArray          = readConfigArrayOrFail()
  let assetIdStr        = cfgArray[IdxCfgAssetId]
  let assetId           = assetIdStr.fromBase58String()
  let minLockDuration   = cfgArray[IdxCfgMinLockDuration].parseIntValue()
  let maxLockDuration   = cfgArray[IdxCfgMaxLockDuration].parseIntValue()

  let pmtAmount = extractOptionalPaymentAmountOrFail(i, assetId)

  let userAddressStr  = i.caller.toString()
  let userRecordArray   = readLockParamsRecordOrFail(userAddressStr)

  let userNumStr          = userRecordArray[IdxLockUserNum]
  let userAmount          = userRecordArray[IdxLockAmount].parseIntValue()
  let lockStart           = userRecordArray[IdxLockStart].parseIntValue()
  let lockDuration        = userRecordArray[IdxLockDuration].parseIntValue()
  let lockEnd             = lockStart + lockDuration
  let remainingDuration   = max([lockEnd - height, 0])

  let userAmountNew       = userAmount + pmtAmount
  let lockDurationNew     = remainingDuration + deltaDuration

  if (deltaDuration < 0) then throw("duration is less then zero") else
  if (lockDurationNew < minLockDuration) then throw("lockDurationNew is less then minLockDuration=" + minLockDuration.toString()) else
  if (lockDurationNew > maxLockDuration) then throw("deltaDuration + existedLockDuration is greater then maxLockDuration=" + maxLockDuration.toString()) else
  #if (lockEnd <= height && userAmount > 0) then throw("there is an expired lock - need to unlock before new lock") else

  let coeffX8 = fraction(lockDurationNew, MULT8, maxLockDuration)
  let gWxAmountStart = fraction(userAmountNew, coeffX8, MULT8)

  strict updateRefActivity = mathContract.invoke("updateReferralActivity", [i.caller.toString(), gWxAmountStart], [])

  let lockStartNew = height
  let gWxParamsResultList = invoke(mathContract, "calcGwxParamsREADONLY", [gWxAmountStart, lockStartNew, lockDurationNew], []).aal()
  # TODO check the following macros: gWxParamsInvokeResult[0].exactAs[Int]
  let k = gWxParamsResultList[0].ai()
  let b = gWxParamsResultList[1].ai()
  let period = gWxParamsResultList[2].ai().toString()

  let currUserGwx = calcCurrentGwxAmount(userAddressStr)
  let gwxDiff = gWxAmountStart - currUserGwx
  if (gwxDiff < 0) then throw("gwxDiff is less then 0: " + gwxDiff.toString()) else
  let totalCachedGwxRaw = getTotalCachedGwx(false)
  let totalCachedGwxCorrected = getTotalCachedGwx(true)

  LockParamsEntry(userAddressStr, userNumStr, userAmountNew, lockStartNew, lockDurationNew, k, b, period)
    ++ StatsEntry(pmtAmount, deltaDuration, 0, 0)
    :+ HistoryEntry("lock", userAddressStr, pmtAmount, lockStart, lockDurationNew, k, b, i)
    ++ [
      IntegerEntry(keyTotalCachedGwx(), totalCachedGwxRaw + gwxDiff)
    ]
}

@Callable(i)
func claimWxBoost(lpAssetIdStr: String, userAddressStr: String) = {
  if (stakingContract != i.caller) then throw("permissions denied") else
  let (userBoostAvailable, dataState, debug) = internalClaimWxBoost(lpAssetIdStr, userAddressStr, false)

  (dataState, [userBoostAvailable])
}

@Callable(i)
func claimWxBoostREADONLY(lpAssetIdStr: String, userAddressStr: String) = {
  let (userBoostAvailable, dataState, debug) = internalClaimWxBoost(lpAssetIdStr, userAddressStr, true)
  ([], [userBoostAvailable, debug])
}

@Callable(i)
func unlock(userAddress: String) = {
  let userRecordArray   = readLockParamsRecordOrFail(userAddress)

  let userNumStr          = userRecordArray[IdxLockUserNum]
  let userAmount          = userRecordArray[IdxLockAmount].parseIntValue()
  let lockStart           = userRecordArray[IdxLockStart].parseIntValue()
  let lockDuration        = userRecordArray[IdxLockDuration].parseIntValue()
  let lockEnd             = lockStart + lockDuration

  let cfgArray          = readConfigArrayOrFail()
  let assetId           = cfgArray[IdxCfgAssetId].fromBase58String()

  if (lockEnd >= height) then throw("wait " + lockEnd.toString() + " to unlock") else
  if (userAmount <= 0) then throw("nothing to unlock") else

  let period = mathContract.getInteger(keyNextPeriod()).valueOrElse(0)

  LockParamsEntry(userAddress, userNumStr, 0, lockStart, lockDuration, 0, 0, period.toString())
    ++ StatsEntry(-userAmount, 0, 0, -1) # fixme: -1 only if single lock from user existed
    :+ HistoryEntry("unlock", userAddress, userAmount, lockStart, lockDuration, 0, 0, i)
    :+ ScriptTransfer(userAddress.addressFromStringValue(), userAmount, assetId)
}

@Callable(i)
func gwxUserInfoREADONLY(userAddress: String) = {
    let gwxAmount = calcCurrentGwxAmount(userAddress)

    ([], [gwxAmount])
}

@Callable(i)
func getUserGwxAmountAtHeightREADONLY(userAddress: String, targetHeight: Int) = {
  let gwxAmount = userAddress.calcUserGwxAmountAtHeight(targetHeight)

  ([], gwxAmount)
}

@Callable(i)
func getTotalCachedGwxREADONLY() = {
  ([], getTotalCachedGwx(true))
}

# call this function when wxEmissionRate or boostCoeff changes
@Callable(i)
func onBoostEmissionUpdate() = {
  # TODO: check caller
  refreshBoostEmissionIntegral()
}

# Staked vote = 0 if staked amount = 0
# Staked vote = last finalized vote if staked amount ≥ 0
# So, stakedVote = [stakedAmount ≥ 0] * lastFinalizedVote
#                  └ this is the Iverson bracket, not the array's one
# Staked vote updates when staked amount goes from zero to non-zero or vice versa
# Staked vote integral and voting result integral should be updated when it happens
#                       ╭­ edge = true (rising)
# staked amount > 0:    ┌───┐
# staked amount = 0: ───┘   └───
#                           ╰ edge = false (falling)
@Callable(i)
func onStakedVoteUpdate(lpAssetIdStr: String, userAddressStr: String, edge: Boolean) = {
  # TODO: check caller
  let actions = lpAssetIdStr.refreshVoteStakedIntegral(userAddressStr, edge)

  ([], unit)
}

@Callable(i)
func getVotingResultStakedREADONLY(lpAssetIdStr: String) = {
  ([], lpAssetIdStr.getVotingResultStaked())
}

@Callable(i)
func getUserVoteFinalizedREADONLY(lpAssetIdStr: String, userAddressStr: String) = {
  ([], lpAssetIdStr.getUserVoteFinalized(userAddressStr))
}

@Callable(i)
func setManager(pendingManagerPublicKey: String) = {
  strict checkCaller = i.mustManager()
  strict checkManagerPublicKey = pendingManagerPublicKey.fromBase58String()

  [StringEntry(keyPendingManagerPublicKey(), pendingManagerPublicKey)]
}

@Callable(i)
func confirmManager() = {
  let pm = pendingManagerPublicKeyOrUnit()
  strict hasPM = pm.isDefined() || throw("No pending manager")
  strict checkPM = i.callerPublicKey == pm.value() || throw("You are not pending manager")

  [
    StringEntry(keyManagerPublicKey(), pm.value().toBase58String()),
    DeleteEntry(keyPendingManagerPublicKey())
  ]
}

@Verifier(tx)
func verify() = {
  let targetPublicKey = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
}
