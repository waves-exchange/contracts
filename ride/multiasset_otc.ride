{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

func keyManagerPublicKey() = "%s__managerPublicKey"

#collecting keys
func collectWithdrawDelayKey(assetA: String, assetB: String) = {
    makeString(["%s%s%s__withdrawDelay", assetA, assetB], "__")
}

func collectDepositFeePermilleKey(assetA: String, assetB: String) = {
    makeString(["%s%s%s__depositFeePermille", assetA, assetB], "__")
}

func collectWithdrawFeePermilleKey(assetA: String, assetB: String) = {
    makeString(["%s%s%s__withdrawFeePermille", assetA, assetB], "__")
}

func collectMinAmountDepositKey(assetA: String, assetB: String) = {
    makeString(["%s%s%s__minAmountDeposit", assetA, assetB], "__")
}

func collectAssetsPairStatusKey(assetA: String, assetB: String) = {
    makeString(["%s%s%s__assetsPairStatus", assetA, assetB], "__")
}

func collectMinAmountWithdrawKey(assetA: String, assetB: String) = {
    makeString(["%s%s%s__minAmountWithdraw", assetA, assetB], "__")
}

func collectBalanceKey(assetA: String, assetB: String, userAddress: String) = {
    makeString(["%s%s%s%s__balance", assetA, assetB, userAddress], "__")
}

func collectTotalCommissionsCollectedDepositKey(assetA: String, assetB: String) = {
    makeString(["%s%s%s%s__totalCommissionsCollected__deposit", assetA, assetB], "__")
}

func collectTotalCommissionsCollectedWithdrawKey(assetA: String, assetB: String) = {
    makeString(["%s%s%s%s__totalCommissionsCollected__withdraw", assetA, assetB], "__")
}

func collectAssetLockTimeKey(assetA: String, assetB: String, userAddress: String) = {
    makeString(["%s%s%s%s__assetLockTime", assetA, assetB, userAddress], "__")
}

func collectProcessInProgressKey(userAddress: String, assetA: String, assetB: String, heightInKey: Int) = {
    makeString(["%s%s%s%s__withdrawProcess__inProgress", userAddress, assetA, assetB, heightInKey.toString()], "__")
}

func collectProcessDoneKey(userAddress: String, assetA: String, assetB: String, heightInKey: Int) = {
    makeString(["%s%s%s%s__withdrawProcess__done", userAddress, assetA, assetB, heightInKey.toString()], "__")
}

#converting a manager's public key to a ByteVector
func managerPublicKeyOrUnit() = match keyManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

#checking on the manager
func mustManager(i: Invocation) = {
  let pd = "Permission denied".throw()

  match managerPublicKeyOrUnit() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

#registering a new pair of assets
@Callable(i)
func registerAsset(assetA: String, assetB: String, withdrawDelay: Int, depositFee: Int, withdrawFee: Int, minAmountDeposit: Int, minAmountWithdraw: Int) = {
    strict checkCaller = invoke.mustManager()

    let withdrawDelayKey = collectWithdrawDelayKey(assetA, assetB)
    let depositFeePermilleKey = collectDepositFeePermilleKey(assetA, assetB)
    let withdrawFeePermilleKey = collectWithdrawFeePermilleKey(assetA, assetB)
    let minAmountDepositKey = collectMinAmountDepositKey(assetA, assetB)
    let minAmountWithdrawKey = collectMinAmountWithdrawKey(assetA, assetB)

    [
        IntegerEntry(withdrawDelayKey, withdrawDelay),
        IntegerEntry(depositFeePermilleKey, depositFee),
        IntegerEntry(withdrawFeePermilleKey, withdrawFee),
        IntegerEntry(minAmountDepositKey, minAmountDeposit),
        IntegerEntry(minAmountWithdrawKey, minAmountWithdraw)
    ]
}

#exchange asset A for B
@Callable(i)
func swapAssetsAToB(assetB: String) = {
    let payment = invoke.payments[0].value()
    let assetA = payment.assetId.value().toBase58String()

    let userAddress = invoke.caller.toString()
    let minAmountDeposit = collectMinAmountDepositKey(assetA, assetB).getInteger().valueOrErrorMessage("This asset pair does not exist.")
    let toDeposit = payment.amount

    let depositFeePermilleKey = collectDepositFeePermilleKey(assetA, assetB)
    let depositFee = this.getInteger(depositFeePermilleKey).valueOrElse(0)
    let fee = toDeposit / 1000 * depositFee
    let currentUserBalance = collectBalanceKey(assetA, assetB, userAddress).getInteger().valueOrElse(0)

    let totalCommissions = collectTotalCommissionsCollectedDepositKey(assetA, assetB).getInteger().valueOrElse(0)

    let asset = assetB.value().fromBase58String()

    if (collectAssetsPairStatusKey(assetA, assetB).getInteger() != 0) then throw("The couple's deposit is blocked.") else
    if (payment.amount < minAmountDeposit) then throw("Swap amount fail, amount is to small.") else

    [
        IntegerEntry(collectBalanceKey(assetA, assetB, userAddress), currentUserBalance + payment.amount - fee),
        IntegerEntry(collectTotalCommissionsCollectedDepositKey(assetA, assetB), totalCommissions + fee),
        ScriptTransfer(invoke.caller, toDeposit, asset)
    ]
}

#initialize the exchange of asset B for A
@Callable(i)
func initializationSwapAssetsBToA(assetA: String, assetB: String) = {
    let payment = invoke.payments[0].value()
    let amount = payment.amount
    let userAddress = invoke.caller.toString()

    let minAmountDeposit = collectMinAmountWithdrawKey(assetA, assetB).getInteger().valueOrErrorMessage("This asset pair does not exist.")

    let assetLockHeight = height + collectWithdrawDelayKey(assetA, assetB).getInteger().valueOrElse(0)

    let currentUserBalance = collectBalanceKey(assetA, assetB, userAddress).getInteger().valueOrErrorMessage("This user balance does not exist.")

    let totalCommissions = collectTotalCommissionsCollectedDepositKey(assetA, assetB).getInteger().valueOrElse(0)

    let withdrawFeePermilleKey = collectWithdrawFeePermilleKey(assetA, assetB)
    let withdrawFee = withdrawFeePermilleKey.getInteger().valueOrElse(0)
    let fee = amount / 1000 * withdrawFee

    [
        IntegerEntry(collectAssetLockTimeKey(assetA, assetB, userAddress), assetLockHeight),
        IntegerEntry(collectBalanceKey(assetA, assetB, userAddress), currentUserBalance - amount - fee),
        IntegerEntry(collectProcessInProgressKey(userAddress, assetA, assetB, assetLockHeight), amount - fee),
        IntegerEntry(collectTotalCommissionsCollectedWithdrawKey(assetA, assetB), totalCommissions + fee)
    ]
}

#withdraw assets initialized at the specified height
@Callable(i)
func withdrawAsset(assetA: String, assetB: String, heightInKey: Int) = {
    let userAddress = invoke.caller.toString()

    let assetLockTime = collectAssetLockTimeKey(assetA, assetB, userAddress).getInteger().valueOrElse(0)

    let toWithdraw = collectProcessInProgressKey(userAddress, assetA, assetB, heightInKey).getInteger().valueOrElse(0)

    let asset = assetA.value().fromBase58String()

    if (assetLockTime < height) then throw("Withdrawal is possible after "+toString(heightInKey)+" height or you have already withdrawn.") else

    [
        DeleteEntry(collectProcessInProgressKey(userAddress, assetA, assetB, heightInKey)),
        IntegerEntry(collectProcessDoneKey(userAddress, assetA, assetB, heightInKey), toWithdraw),
        IntegerEntry(collectBalanceKey(assetA, assetB, userAddress), toWithdraw),
        ScriptTransfer(invoke.caller, toWithdraw, asset)
    ]
}

#withdraws the collected commission to the manager's address
@Callable(i)
func withdrawFee(assetA: String, assetB: String) = {
    strict checkCaller = invoke.mustManager()

    let toWithdrawA = collectTotalCommissionsCollectedDepositKey(assetA, assetB).getInteger().valueOrElse(0)
    let withdrawAssetA = assetA.value().fromBase58String()

    let toWithdrawB = collectTotalCommissionsCollectedWithdrawKey(assetA, assetB).getInteger().valueOrElse(0)
    let withdrawAssetB = assetB.value().fromBase58String()

    [
        IntegerEntry(collectTotalCommissionsCollectedDepositKey(assetA, assetB), 0),
        ScriptTransfer(invoke.caller, toWithdrawA, withdrawAssetA),
        IntegerEntry(collectTotalCommissionsCollectedWithdrawKey(assetA, assetB), 0),
        ScriptTransfer(invoke.caller, toWithdrawB, withdrawAssetB)
    ]
}

@Verifier(tx)
func verify () = {
  let targetPublicKey = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
}
