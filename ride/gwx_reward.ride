{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let revisionNum = ""
let SEP = "__"
let MAXDEPTH = 17 # 17 * 6 = 112 users
let USERDEPTH = 26
let SCALE = 1000
let MULT8 = 1_0000_0000
let zeroBigInt = 0.toBigInt()
let processingStageTotal = 0
let processingStageShares = 1
let maxDepthDefault = 30

func getNumberByKey(key: String) = getInteger(this, key).valueOrElse(0)

func getNumberOrFail(key: String) = getInteger(this, key)
  .valueOrErrorMessage("mandatory this." + key + " is not defined")

func getStringByKey(key: String) = getString(this, key).valueOrElse("")

func getStringOrFail(key: String) =
  getString(key).valueOrErrorMessage("mandatory this." + key + " is not defined")

func abs(val: BigInt) = if (val < zeroBigInt) then -val else val

let keyMaxDepth = "%s__maxDepth"

# FACTORY API
# own factory address key
func keyFactoryAddress()  = "%s%s__config__factoryAddress"

# GLOBAL VARIABLES
# CONSTRUCTOR IS NOT FAILED BECAUSE GLOBAL VARIABLES ARE NOT USED
let factoryAddressStr = getStringOrFail(keyFactoryAddress())
let factoryContract   = factoryAddressStr.addressFromStringValue()


# EMISSION API
# own emission address key
func keyEmissionAddress() = "%s%s__config__emissionAddress"

# GLOBAL VARIABLES
# CONSTRUCTOR IS NOT FAILED BECAUSE GLOBAL VARIABLES ARE NOT USED
let emissionAddressStr = getStringOrFail(keyEmissionAddress())
let emissionContract   = emissionAddressStr.addressFromStringValue()


# ***********************
# Config
# ***********************
# index 0 corresponds %s%s%s metadata
let IdxCfgAssetId             = 1
let IdxCfgPacemakerAddress    = 2
let IdxCfgBoostingContract    = 3
let IdxCfgMaxDepth            = 4

func keyConfig() = "%s__config"

func readConfigArrayOrFail() =
  getStringOrFail(keyConfig()).split(SEP)

func formatConfig(wxAssetIdStr: String, matcherPacemakerAddressStr: String, boostingContractAddressStr: String, maxDepth: Int) = {
  makeString([
      "%s%s%s%d",
      wxAssetIdStr,                # 1
      matcherPacemakerAddressStr,  # 2
      boostingContractAddressStr,  # 3
      maxDepth.toString()          # 4
    ], SEP)
}

# ***********************
# KEYS
# ***********************

func keyGwxRewardEmissionStartHeight() = "%s%s__gwxRewardEmissionPart__startHeight"

# boosting contract state key, increments every lock() of unique user
func keyUsersCount() = "%s__nextUserNum"

# emission contract key
func keyRatePerBlockCurrent() = "%s%s__ratePerBlock__current"

# factory contract key
func keyPoolWeightVirtual() = "%s%s__poolWeight__GWXvirtualPOOL"

# user to be processed next time within nextProcessedPeriod
func keyNextProcessedUser() = "%s__nextProcessedUser"

# latest finalized period (next matcher/emission payment will go to nextPeriod)
func keyLatestPeriod() = "%s__latestPeriod"

# period to place incoming payment next time (incremented by deposit() callable)
func keyNextPeriod() = "%s__nextPeriod"

# stage of processing 0|Unit - calculate total weight, 1 - calculate shares
func keyProcessingStage() = "%s__processingStage"

# period to be processed next time (incomplete)
func keyNextProcessedPeriod() = "%s__nextProcessedPeriod"

# next (unclaimed yet) period for user
func keyNextUnlaimedPeriodOfUser(userIndex: Int) =
  makeString(["%s%d__nextClaimedPeriod", userIndex.toString()], SEP)

# period to get K and B values for given user during weight calculation
func keyLastProcessedPeriodOfUser(userIndex: Int) =
  makeString(["%s%d__lastProcessedPeriod", userIndex.toString()], SEP)

func keyHeightForPeriod(period: Int) =
  makeString(["%s%d__startHeightForPeriod", period.toString()], SEP)

# amount of WX to distribute between all users (as emission 5% reward) for period
func keyAuxEmissionRewardForPeriod(period: Int) =
  makeString(["%s%d__auxEmissionReward", period.toString()], SEP)

# amount of WX to distribute between all users (as matcher comissions reward) for period
func keyTotalAmountForPeriod(period: Int) =
  makeString(["%s%d__totalAmountForPeriod", period.toString()], SEP)

# rewards from matcher and from emission for last finalized period
func keyLastPayoutInfo() = "%s__lastPayoutInfo"

func PeriodPayoutInfo(period: Int, matcherReward: Int, emissionReward: Int) =
  makeString(["%d%d%d", period.toString(), matcherReward.toString(), emissionReward.toString()], SEP)

# rewards from matcher and from emission for given period
func keyPayoutHistoryInfo(period: Int) =
  makeString(["%s%s%d__payouts__history", period.toString()], SEP)

# sum of users weights for period
func keyTotalWeightForPeriod(period: Int) =
  makeString(["%s%d__totalWeightForPeriod", period.toString()], SEP)

# user's K value for period
func keyUserKValueForPeriod(period: Int, userIndex: Int) =
  makeString(["%s%d%s%d__paramByPeriod", userIndex.toString(), "k", period.toString()], SEP)

# user's B value for period
func keyUserBValueForPeriod(period: Int, userIndex: Int) =
  makeString(["%s%d%s%d__paramByPeriod", userIndex.toString(), "b", period.toString()], SEP)

func keyUserWeightForPeriod(period: Int, userIndex: Int) =
  makeString(["%s%d%s%d__paramByPeriod", userIndex.toString(), "weight", period.toString()], SEP)

func keyReferralsContractAddress()  = "%s%s__config__referralsContractAddress"

func HistoryEntry(type: String, user: String, amountFromMatcher: Int, amountFromEmission: Int, currentPeriod: Int, latestPeriod: Int, i: Invocation) = {
  let historyKEY = makeString(["%s%s%s%s__history", type, user, i.transactionId.toBase58String()], SEP)
  let historyDATA = makeString([
        "%d%d%d%d%d%d",
        lastBlock.height.toString(),
        lastBlock.timestamp.toString(),
        amountFromMatcher.toString(),
        amountFromEmission.toString(),
        currentPeriod.toString(),
        latestPeriod.toString()],
    SEP)
  StringEntry(historyKEY, historyDATA)
}

func keyManagerPublicKey() = "%s__managerPublicKey"
func keyPendingManagerPublicKey() = {"%s__pendingManagerPublicKey"}

func managerPublicKeyOrUnit() = match keyManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func pendingManagerPublicKeyOrUnit() = match keyPendingManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func mustManager(i: Invocation) = {
  let pd = "Permission denied".throw()

  match managerPublicKeyOrUnit() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

# user's weight = k * height + b, scaled by 10^8
func calcUserWeight(boostingContractAddress: Address, heightForPeriod: Int, period: Int, userIndex: Int) = {
  let kLast = keyLastProcessedPeriodOfUser(userIndex)
  let kKey = keyUserKValueForPeriod(period, userIndex)
  let kRaw = getInteger(boostingContractAddress, kKey)
  let kUserWeight = period.keyUserWeightForPeriod(userIndex)
  if (kRaw.isDefined()) then {
    let k = kRaw.value()
    let b = getInteger(boostingContractAddress, keyUserBValueForPeriod(period, userIndex)).value()
    let w = k * heightForPeriod + b
    if (w > 0) then (w / SCALE, [IntegerEntry(kLast, period), IntegerEntry(kUserWeight, w)]) else (0, [])
  } else { # use last saved period
    let p = getInteger(this, kLast)
    if (p.isDefined() && p.value() <= period) then {
      let pv = p.value()
      let k = getInteger(boostingContractAddress, keyUserKValueForPeriod(pv, userIndex)).value()
      let b = getInteger(boostingContractAddress, keyUserBValueForPeriod(pv, userIndex)).value()
      let w = k * heightForPeriod + b
      if (w > 0) then (w / SCALE, [IntegerEntry(kUserWeight, w)]) else (0, [])
    } else {
      (0, [])
    }
  }
}

func calcUserWeightForClaim(boostingContractAddress: Address, heightForPeriod: Int, period: Int, userIndex: Int) = {
  let kUserWeight = period.keyUserWeightForPeriod(userIndex)
  let userWeightOrUnit = kUserWeight.getInteger()
  match userWeightOrUnit {
    case _: Unit => 0
    case w: Int => w / SCALE
  }
}

func getUserIndexByAddress(boostingContractAddressStr: String, userAddress: String) = {
  let key = makeString(["%s%s%s", "mapping", "user2num", userAddress], SEP)
  parseIntValue(getString(Address(boostingContractAddressStr.fromBase58String()), key)
    .valueOrErrorMessage("User address " + userAddress + " is not found in boosting contract data, key=" + key))
}

# period index to place incoming payment next time
func nextPeriod() =
  getNumberByKey(keyNextPeriod())


func invokeProcess(boostingContract: ByteVector, period: Int, user: Int, depth: Int, weight: Int) = {
  strict result = invoke(this, "processNextBatch", [boostingContract, period, user, depth, weight], [])
  match (result) {
    case r: (Int, Int, Int) => r # period, user, weight
    case _ => throw("Incorrect invoke result")
  }
}

# process next batch of up to 6 users starting from currentPeriod and currentUser (inclusive)
# return: ([IntegerEntry(totalWeightKey, totalWeight)], nextProcessingStage, nextProcessedUser, totalWeight)
func processNextBatchInternal(boostingContract: ByteVector, currentPeriod: Int, currentUser: Int, depth: Int, totalWeight: Int) = {
  let boostingContractAddress = Address(boostingContract)
  let latestPeriod = getNumberByKey(keyLatestPeriod())
  let usersCount = getInteger(boostingContractAddress, keyUsersCount()).valueOrElse(0)
  # at least 1 processing should be done
  let totalWeightKey = keyTotalWeightForPeriod(currentPeriod)
  let heightForPeriod = getNumberByKey(keyHeightForPeriod(currentPeriod))
  if (depth > 0 && currentPeriod <= latestPeriod) then {
    let t0 = calcUserWeight(boostingContractAddress, heightForPeriod, currentPeriod, currentUser)
    let weight0 = totalWeight + t0._1
    if (currentUser + 1 < usersCount) then {
      let t1 = calcUserWeight(boostingContractAddress, heightForPeriod, currentPeriod, currentUser + 1)
      let weight1 = weight0 + t1._1
      if (currentUser + 2 < usersCount) then {
        let t2 = calcUserWeight(boostingContractAddress, heightForPeriod, currentPeriod, currentUser + 2)
        let weight2 = weight1 + t2._1
        if (currentUser + 3 < usersCount) then {
          let t3 = calcUserWeight(boostingContractAddress, heightForPeriod, currentPeriod, currentUser + 3)
          let weight3 = weight2 + t3._1
          if (currentUser + 4 < usersCount) then {
            let t4 = calcUserWeight(boostingContractAddress, heightForPeriod, currentPeriod, currentUser + 4)
            let weight4 = weight3 + t4._1
            if (currentUser + 5 < usersCount) then {
              let t5 = calcUserWeight(boostingContractAddress, heightForPeriod, currentPeriod, currentUser + 5)
              let weight5 = weight4 + t5._1
              if (currentUser + 6 < usersCount) then { # more than 6 users left in the current period
                let r5 = invokeProcess(boostingContract, currentPeriod, currentUser + 6, depth - 1, weight5)
                (t0._2 ++ t1._2 ++ t2._2 ++ t3._2 ++ t4._2 ++ t5._2, r5._1, r5._2, r5._3)
              } else { # exactly 6 users left in the current period
                ([IntegerEntry(totalWeightKey, weight5)] ++ t0._2 ++ t1._2 ++ t2._2 ++ t3._2 ++ t4._2 ++ t5._2, processingStageShares, 0, 0)
              }
            } else { # exactly 5 users left in the current period
              ([IntegerEntry(totalWeightKey, weight4)] ++ t0._2 ++ t1._2 ++ t2._2 ++ t3._2 ++ t4._2, processingStageShares, 0, 0)
            }
          } else { # exactly 4 users left in the current period
            ([IntegerEntry(totalWeightKey, weight3)] ++ t0._2 ++ t1._2 ++ t2._2 ++ t3._2, processingStageShares, 0, 0)
          }
        } else { # exactly 3 users left in the current period
          ([IntegerEntry(totalWeightKey, weight2)] ++ t0._2 ++ t1._2 ++ t2._2, processingStageShares, 0, 0)
        }
      } else { # exactly 2 users left in the current period
        ([IntegerEntry(totalWeightKey, weight1)] ++ t0._2 ++ t1._2, processingStageShares, 0, 0)
      }
    } else { # exactly 1 users left in the current period (0 users case is impossible)
      ([IntegerEntry(totalWeightKey, weight0)] ++ t0._2, processingStageShares, 0, 0)
    }
  } else { # depth == 0 or no more periods
    if (currentUser == 0) then { # weight already saved at previous period
      ([], processingStageTotal, 0, 0)
    } else {
      ([IntegerEntry(totalWeightKey, totalWeight)], processingStageTotal, currentUser, 0)
    }
  }
}

func invokeClaim(boostingContract: ByteVector, period: Int, user: Int, depth: Int, totalFromMatcher: Int, totalFromEmission: Int) = {
  strict result = invoke(this, "claimNextBatch", [boostingContract, period, user, depth, totalFromMatcher, totalFromEmission], [])
  match (result) {
    case r: (Int, Int, Int) => r # period, totalFromMatcher, totalFromEmission
    case _ => throw("Incorrect invoke result")
  }
}

# Called internally (recursively)
func claimInternal(boostingContract: ByteVector, currentPeriod: Int, currentUser: Int, depth: Int, userAccumulatedMatcher: Int, userAccumulatedEmission: Int) = {
  let boostingContractAddress = Address(boostingContract)
  let latestPeriod = getNumberByKey(keyNextProcessedPeriod())
  # at least 1 processing should be done
  let totalWeight = getNumberByKey(keyTotalWeightForPeriod(currentPeriod))
  let heightForPeriod = getNumberByKey(keyHeightForPeriod(currentPeriod))
  let userWeight = calcUserWeightForClaim(boostingContractAddress, heightForPeriod, currentPeriod, currentUser)
  let userAmountMatcherForPeriod = fraction(getNumberByKey(keyTotalAmountForPeriod(currentPeriod)), userWeight, totalWeight)
  let userAmountEmissionForPeriod = fraction(getNumberByKey(keyAuxEmissionRewardForPeriod(currentPeriod)), userWeight, totalWeight)
  if (depth <= 0 || currentPeriod + 1 >= latestPeriod) then {
    (currentPeriod + 1, userAccumulatedMatcher + userAmountMatcherForPeriod, userAccumulatedEmission + userAmountEmissionForPeriod)
  } else { # try next period
    invokeClaim(boostingContract, currentPeriod + 1, currentUser, depth - 1, userAccumulatedMatcher + userAmountMatcherForPeriod, userAccumulatedEmission + userAmountEmissionForPeriod)
  }
}

func commonClaimReward(userAddress: String, startPeriod: Int|Unit) = {
  let cfgArray = readConfigArrayOrFail()
  let userIdx = getUserIndexByAddress(cfgArray[IdxCfgBoostingContract], userAddress) # will throw if no such user
  let currentPeriod = if (startPeriod != unit) then startPeriod.value() else getNumberByKey(keyNextUnlaimedPeriodOfUser(userIdx)) # period being currently claimed
  let nextProcessedPeriod = getNumberByKey(keyNextProcessedPeriod())
  if (currentPeriod >= nextProcessedPeriod) then throw("Nothing to claim") else
  let boostingContract = cfgArray[IdxCfgBoostingContract].fromBase58String()
  let (period, amountFromMatcher, amountFromEmission) = claimInternal(boostingContract, currentPeriod, userIdx, USERDEPTH, 0, 0)
  (period, amountFromMatcher, amountFromEmission, userIdx, cfgArray, nextProcessedPeriod)
}

# Called internally (recursively)
@Callable(i)
func processNextBatch(boostingContract: ByteVector, currentPeriod: Int, currentUser: Int, depth: Int, totalWeight: Int) = {
  if (i.caller != this) then throw("Should be called by this script only") else
  let tpl = processNextBatchInternal(boostingContract, currentPeriod, currentUser, depth, totalWeight)
  (
    tpl._1, # actions
    (tpl._2, tpl._3, tpl._4) # period, user, weightAccumulatedForPeriod
  )
}

# Called by anyone. Process finalized periods only (no more than one period per call)
@Callable(i)
func processPendingPeriodsAndUsers() = {
  let processingStage = keyProcessingStage().getInteger().valueOrElse(processingStageTotal)
  let currentPeriod = getNumberByKey(keyNextProcessedPeriod()) # period with reward being currently distributed
  if (currentPeriod > getNumberByKey(keyLatestPeriod())) then throw("Nothing to process") else
  let cfgArray = readConfigArrayOrFail()
  let depth = cfgArray[IdxCfgMaxDepth].parseIntValue()
  if (depth > MAXDEPTH) then throw("Depth exceeds MAXDEPTH") else
  let boostingContract = cfgArray[IdxCfgBoostingContract].fromBase58String()
  let currentUser = getNumberByKey(keyNextProcessedUser()) # user to start with
  let totalWeight = getNumberByKey(keyTotalWeightForPeriod(currentPeriod))
  if (processingStage == processingStageTotal) then {
    let r = processNextBatchInternal(boostingContract, currentPeriod, currentUser, depth, totalWeight)
    r._1 # actions to execute
      :+ IntegerEntry(keyProcessingStage(), r._2) # processingStage
      :+ IntegerEntry(keyNextProcessedUser(), r._3) # user
  } else if (processingStage == processingStageShares) then {
    let r = processNextBatchInternal(boostingContract, currentPeriod, currentUser, depth, totalWeight)
    r._1 # actions to execute
      :+ IntegerEntry(keyNextProcessedPeriod(), r._2) # period
  } else "invalid processing stage".throw()
}

@Callable(i)
func finalizeHelper() = {
  (nil, unit)
}

@Callable(i)
func finalizeWrapper(counter: Int) = {
  let maxDepth = this.getInteger(keyMaxDepth).valueOrElse(maxDepthDefault)
  strict result = this.invoke("finalizeHelper", [], []).exactAs[Boolean]
  if (!result && counter == maxDepth) then {
    "Current voting is not over yet".throw()
  } else {
    if (counter < maxDepth) then {
      ([], this.invoke("finalizeWrapper", [counter - 1], []))
    } else {
      ([], unit)
    }
  }
}

@Callable(i)
func finalize() = {
  let maxDepth = this.getInteger(keyMaxDepth).valueOrElse(maxDepthDefault)

  ([], this.invoke("finalizeWrapper", [maxDepth], []))
}

# Deposit total WX reward for next period. Also requests 5% emission reward from emission contract
# This total reward should be distributed
#  between all the users according to their gWX shares (weights)
# Called by matcher pacemaker
@Callable(i)
func deposit() = {
  let cfgArray = readConfigArrayOrFail()
  if (i.caller != Address(cfgArray[IdxCfgPacemakerAddress].fromBase58String())) then throw("Wrong caller address") else
  let assetId = i.payments[0].value().assetId.value()
  if (assetId != cfgArray[IdxCfgAssetId].fromBase58String()) then throw("Wrong payment asset") else
  let period = nextPeriod()
#  strict call = invoke(this, "processPendingPeriodsAndUsers", [], []) # optional

  let deltaH = height - getNumberOrFail(keyGwxRewardEmissionStartHeight())
  let emissionRate = getInteger(emissionContract, keyRatePerBlockCurrent()) # 38_0517_5038 = 38 WX per block
    .valueOrErrorMessage("mandatory emission_contract." + keyRatePerBlockCurrent() + " is not defined")
  let weight = getInteger(factoryContract, keyPoolWeightVirtual()) # 0_0500_0000 = 5%
    .valueOrErrorMessage("mandatory factory_contract." + keyPoolWeightVirtual() + " is not defined")
  let auxAmount = fraction(deltaH * weight, emissionRate, MULT8)
  strict em = invoke(emissionContract, "emit", [auxAmount], []) # request auxAmount WX from emission contract

  let matcherPart = i.payments[0].value().amount
  let payoutInfo = PeriodPayoutInfo(period, matcherPart, auxAmount)
  [
    IntegerEntry(keyLatestPeriod(), period),
    IntegerEntry(keyHeightForPeriod(period), height), # save period start height
    IntegerEntry(keyAuxEmissionRewardForPeriod(period), auxAmount), # amount to distribute between users (emission part)
    IntegerEntry(keyGwxRewardEmissionStartHeight(), height), # update emission height (for deltaH calculation)
    IntegerEntry(keyTotalAmountForPeriod(period), matcherPart), # amount to distribute between users (matcher part)
    IntegerEntry(keyNextPeriod(), period + 1), # finalize period (increment period to be processed next time)
    StringEntry(keyLastPayoutInfo(), payoutInfo),
    StringEntry(keyPayoutHistoryInfo(period), payoutInfo)
  ]
}

# Called internally (recursively)
@Callable(i)
func claimNextBatch(boostingContract: ByteVector, currentPeriod: Int, currentUser: Int, depth: Int, totalFromMatcher: Int, totalFromEmission: Int) = {
  if (i.caller != this) then throw("Should be called by this script only") else
  let periodAndTotals = claimInternal(boostingContract, currentPeriod, currentUser, depth, totalFromMatcher, totalFromEmission)
  (
    [], # actions
    periodAndTotals
  )
}

# Send all WX earned to caller
# called by user
@Callable(i)
func claimReward() = {
  let address = i.caller.toString()
  let (period, amountFromMatcher, amountFromEmission, userIdx, cfgArray, nextProcessedPeriod) = commonClaimReward(address, unit)
  ([
    IntegerEntry(keyNextUnlaimedPeriodOfUser(userIdx), period),
    ScriptTransfer(i.caller, amountFromMatcher + amountFromEmission, cfgArray[IdxCfgAssetId].fromBase58String()),
    HistoryEntry("claim", address, amountFromMatcher, amountFromEmission, period, nextProcessedPeriod, i)
  ], [amountFromMatcher, amountFromEmission])
}

# returns total claimable reward by user address
@Callable(i)
func claimRewardREADONLY(address: String) = {
  let claimResults = commonClaimReward(address, unit)
  let amount = claimResults._2 + claimResults._3 # both from matcher and from emission
  ([], amount)
}

# returns total claimable reward by user address
@Callable(i)
func claimRewardPaginatedREADONLY(address: String, startPeriod: Int) = {
  let (period, fromMatcher, fromEmission) = commonClaimReward(address, if (startPeriod < 0) then unit else startPeriod)
  let amount = fromMatcher + fromEmission # both from matcher and from emission
  ([], (amount, period))
}

# returns claimable rewards by user address (total and detailed by type)
@Callable(i)
func claimRewardDetailedREADONLY(address: String) = {
  let (ignored, fromMatcher, fromEmission) = commonClaimReward(address, unit)
  ([], makeString(["%d%d%d", toString(fromMatcher + fromEmission), fromMatcher.toString(), fromEmission.toString()], SEP))
}

# returns claimable rewards by user address (total and detailed by type)
@Callable(i)
func claimRewardDetailedPaginatedREADONLY(address: String, startPeriod: Int) = {
  let (period, fromMatcher, fromEmission) = commonClaimReward(address, if (startPeriod < 0) then unit else startPeriod)
  ([], (makeString(["%d%d%d", toString(fromMatcher + fromEmission), fromMatcher.toString(), fromEmission.toString()], SEP), period))
}

# returns -1 if there were no payments via deposit() call
@Callable(i)
func latestFinalizedPeriodREADONLY(address: String) = {
  ([], getInteger(this, keyLatestPeriod()).valueOrElse(-1))
}

# returns %d%d%d__${latestFinalizedPeriod}__${matcherPart}__${emissionPart}
@Callable(i)
func latestFinalizedPeriodInfoREADONLY(address: String) = {
  ([], getStringByKey(keyLastPayoutInfo()))
}

# ***********************
# GWX MATH
# ***********************
@Callable(i)
func calcGwxParamsREADONLY(gwxAmountStart: Int, lockStartHeight: Int, lockDurationBlocks: Int) = {
  let lockEndHeight = lockStartHeight + lockDurationBlocks
  let scale8ParamK = -fraction(gwxAmountStart, SCALE, lockDurationBlocks)
  let scale8ParamB = fraction(gwxAmountStart, SCALE, lockDurationBlocks) * lockEndHeight
  ([], [scale8ParamK, scale8ParamB, nextPeriod()])
}

@Callable(i)
func calcGwxAmountStartREADONLY(wxLockAmount: Int, lockDuration: Int, maxLockDuration: Int) = {
  let coeffX8 = fraction(lockDuration, MULT8, maxLockDuration)
  let gWxAmountStart = fraction(wxLockAmount, coeffX8, MULT8)
  ([], [gWxAmountStart])
}

# Constructors should be called sequentially: constructor(), then constructorV2(), then constructorV3() etc
@Callable(i)
func constructor(wxAssetIdStr: String, matcherPacemakerAddressStr: String, boostingContractAddressStr: String, maxDepth: Int) = {
  if (this != i.caller) then throw("not authorized") else

  [StringEntry(keyConfig(), formatConfig(wxAssetIdStr, matcherPacemakerAddressStr, boostingContractAddressStr, maxDepth))]
}

@Callable(i)
func constructorV2(factoryAddress: String) = {
  if (this != i.caller) then throw("not authorized") else

  [StringEntry(keyFactoryAddress(), factoryAddress)]
}

@Callable(i)
func constructorV3(emissionAddress: String) = {
  if (this != i.caller) then throw("not authorized") else
  let initLatestPeriod = if (getInteger(this, keyLatestPeriod()).isDefined()) then [] else [IntegerEntry(keyLatestPeriod(), -1)]

  initLatestPeriod :+ StringEntry(keyEmissionAddress(), emissionAddress)
}

@Callable(i)
func constructorV4(referralsContractAddress: String) = {
  strict checkCaller = i.mustManager()

  [StringEntry(keyReferralsContractAddress(), referralsContractAddress)]
}

# save starting height of reward from emission 5%
@Callable(i)
func onEmissionForGwxStart() = {
  if (i.caller != factoryContract) then throw("permissions denied") else
  [IntegerEntry(keyGwxRewardEmissionStartHeight(), height)]
}

@Callable(i)
func latestPeriodEmissionRewardsREADONLY(address: String) = {
  let period = nextPeriod()
  ([], [getNumberByKey(keyAuxEmissionRewardForPeriod(period))])
}

# LP Math

# D invariant calculation iteratively for 2 tokens
#
# A * sum(x_i) * n^n + D = A * D * n^n + D^(n+1) / (n^n * prod(x_i))
#
# Converging solution:
# D[j+1] = (A * n^n * sum(x_i) - D[j]^(n+1) / (n^n prod(x_i))) / (A * n^n - 1)
@Callable(i)
func calcD(
  x1BigIntStr: String,
  x2BigIntStr: String,
  ampBigIntStr: String,
  aPrecisionBigIntStr: String,
  targetPrecisionBigIntStr: String
) = {
  let nCoins = 2.toBigInt()
  let aPrecision = aPrecisionBigIntStr.parseBigIntValue()
  let targetPrecision = targetPrecisionBigIntStr.parseBigIntValue()
  let x1 = x1BigIntStr.parseBigIntValue()
  let x2 = x2BigIntStr.parseBigIntValue()
  let amp = ampBigIntStr.parseBigIntValue() * aPrecision
  let s = x1 + x2
  if (s == zeroBigInt) then {
    ([], zeroBigInt.toString())
  } else {
    let ann = amp * nCoins
    let arr = [1, 2, 3, 4, 5, 6, 7]
    func calc(acc: (BigInt, BigInt|Unit), cur: Int) = {
      let (d, dPrev) = acc
      # dp0 = d
      # dp1 = dp0 * d / (x1 * nCoins)
      # dp2 = dp1 * d / (x2 * nCoins) = (dp0 * d / (x1 * nCoins)) * d / (x2 * nCoins) = d^3 / (x1 * x2 * nCoins^2)
      let dp = d * d * d / (x1 * x2 * nCoins * nCoins)
      let dNext = (ann * s / aPrecision + dp * nCoins) * d / ((ann - aPrecision) * d / aPrecision + (nCoins + 1.toBigInt()) * dp)
      (dNext, d)
    }
    let (dNext, dPrev) = FOLD<7>(arr, (s, unit), calc)
    let dDiff = abs(dNext - dPrev.value())
    if (dDiff <= targetPrecision) then {
      ([], dNext.toString())
    } else throw("D calculation error, dDiff = " + dDiff.toString())
  }
}

@Callable(i)
func setManager(pendingManagerPublicKey: String) = {
  strict checkCaller = i.mustManager()
  strict checkManagerPublicKey = pendingManagerPublicKey.fromBase58String()

  [StringEntry(keyPendingManagerPublicKey(), pendingManagerPublicKey)]
}

@Callable(i)
func confirmManager() = {
  let pm = pendingManagerPublicKeyOrUnit()
  strict hasPM = pm.isDefined() || throw("No pending manager")
  strict checkPM = i.callerPublicKey == pm.value() || throw("You are not pending manager")

  [
    StringEntry(keyManagerPublicKey(), pm.value().toBase58String()),
    DeleteEntry(keyPendingManagerPublicKey())
  ]
}

@Verifier(tx)
func verify() = {
  let targetPublicKey = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
}

