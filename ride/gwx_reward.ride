{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# Required state entries:
# * "%s__config": String ("%s%s%s__<wxAssetIdStr>__<matcherPacemakerAddressStr>__<boostingContractAddressStr>")
# * "%s%s__config__factoryAddress": String
# * "%s%s__config__emissionAddress": String
# * "%s%s__config__referralsContractAddress": String
# * "%s__latestPeriod": Integer

# TODO: seems like we can use keyGwxRewardEmissionStartHeight for integral start height

let SEP = "__"
let SCALE = 1000
let MULT8 = 1_0000_0000
let MULT8BI = MULT8.toBigInt()
let zeroBigInt = 0.toBigInt()
let processingStageTotal = 0
let processingStageShares = 1
let MULT18 = 1_000_000_000_000_000_000
let MULT18BI = MULT18.toBigInt()

let wavesString = "WAVES"

func wrapErr(msg: String) = ["gwx_reward.ride:", msg].makeString(" ")
func throwErr(msg: String) = msg.wrapErr().throw()

func getNumberByKey(key: String) = this.getInteger(key).valueOrElse(0)
func getNumberOrFail(key: String) = this.getInteger(key).valueOrErrorMessage(wrapErr("mandatory this." + key + " is not defined"))
func getStringByKey(key: String) = this.getString(key).valueOrElse("")
func getStringOrFail(key: String) = this.getString(key).valueOrErrorMessage(wrapErr("mandatory this." + key + " is not defined"))

func parseAssetId(input: String) = {
  if (input == wavesString) then unit else input.fromBase58String()
}

func abs(val: Int) = if (val < 0) then -val else val
func absBigInt(val: BigInt) = if (val < zeroBigInt) then -val else val

let keyMaxDepth = "%s__maxDepth"
let maxDepthDefault = 30
let maxDepth = this.getInteger(keyMaxDepth).valueOrElse(maxDepthDefault)

# FACTORY API
# own factory address key
func keyFactoryAddress() = "%s%s__config__factoryAddress"

# GLOBAL VARIABLES
let factoryAddressStr = getStringOrFail(keyFactoryAddress())
let factoryContract = factoryAddressStr.addressFromStringValue()

# EMISSION API
# own emission address key
func keyEmissionAddress() = "%s%s__config__emissionAddress"

func keyVotingEmissionContract() = ["%s", "votingEmissionContract"].makeString(SEP)
let votingEmissionContract = factoryContract.getStringValue(keyVotingEmissionContract()).addressFromStringValue()

# Boosting
func keyNumToUserMapping(num: Int) = ["%s%s%s", "mapping", "num2user", num.toString()].makeString(SEP)

# Referrals
let keyReferralProgramName = ["%s%s", "referral", "programName"].makeString(SEP)
let referralProgramNameDefault = "wxlock"
let referralProgramName = this.getString(keyReferralProgramName).valueOrElse(referralProgramNameDefault)

let keyReferralMinGWxAmount = ["%s%s", "referral", "minGWxAmount"].makeString(SEP)
let referralMinGWxAmountDefault = 500 * MULT8
let referralMinGWxAmount = this.getInteger(keyReferralMinGWxAmount).valueOrElse(referralMinGWxAmountDefault)

let keyReferrerRewardPermille = ["%s%s", "referral", "referrerRewardPermille"].makeString(SEP)
# 50‰ = 5%
let referrerRewardPermilleDefault = 50
let referrerRewardPermille = this.getInteger(keyReferrerRewardPermille).valueOrElse(referrerRewardPermilleDefault)

let keyReferralRewardPermille = ["%s%s", "referral", "referralRewardPermille"].makeString(SEP)
# 50‰ = 5%
let referralRewardPermilleDefault = 50
let referralRewardPermille = this.getInteger(keyReferralRewardPermille).valueOrElse(referralRewardPermilleDefault)

func keyReferrer(referralAddress: String) = ["%s%s%s", "referrer", referralProgramName, referralAddress].makeString(SEP)

func keyUnclaimedReferral(
  programName: String,
  claimerAddress: String
) = makeString(["%s%s%s", "unclaimedReferral", programName, claimerAddress], SEP)

# GLOBAL VARIABLES
# CONSTRUCTOR IS NOT FAILED BECAUSE GLOBAL VARIABLES ARE NOT USED
let emissionAddressStr = getStringOrFail(keyEmissionAddress())
let emissionContract = emissionAddressStr.addressFromStringValue()


# ***********************
# Config
# ***********************
# index 0 corresponds %s%s%s metadata
let IdxCfgAssetId             = 1
let IdxCfgPacemakerAddress    = 2
let IdxCfgBoostingContract    = 3
let IdxCfgMaxDepth            = 4

func keyConfig() = "%s__config"

func getEmissionAddress() = this.getString(
  keyEmissionAddress()
).valueOrErrorMessage(
  "mandatory this." + keyEmissionAddress() + " is not defined"
).addressFromStringValue()


let emissionAddress = getEmissionAddress()
let wxAssetIdStr = emissionAddress.getString(keyConfig()).value().split(SEP)[1]
let wxAssetId = wxAssetIdStr.fromBase58String()

func readConfigArrayOrFail() = getStringOrFail(keyConfig()).split(SEP)

func formatConfig(wxAssetIdStr: String, matcherPacemakerAddressStr: String, boostingContractAddressStr: String, maxDepth: Int) = {
  makeString([
      "%s%s%s%d",
      wxAssetIdStr,                # 1
      matcherPacemakerAddressStr,  # 2
      boostingContractAddressStr,  # 3
      maxDepth.toString()          # 4
    ], SEP)
}

func boostingContractOrFail() = {
  let cfgArray = readConfigArrayOrFail()
  cfgArray[IdxCfgBoostingContract].addressFromString().valueOrErrorMessage("boosting contract address is not defined")
}

# ***********************
# KEYS
# ***********************

func keyGwxRewardEmissionStartHeight() = "%s%s__gwxRewardEmissionPart__startHeight"

# boosting contract state key, increments every lock() of unique user
func keyUsersCount() = "%s__nextUserNum"
func keyUser2NumMapping(userAddress: Address) = makeString(["%s%s%s__mapping__user2num", userAddress.toString()], SEP)

# emission contract key
func keyRatePerBlockCurrent() = "%s%s__ratePerBlock__current"
func keyGwxHoldersRewardCurrent() = "%s%s__gwxHoldersReward__current"
func keyGwxHoldersRewardNext() = "%s%s__gwxHoldersReward__next"

# factory contract key
func keyPoolWeightVirtual() = "%s%s__poolWeight__GWXvirtualPOOL"

func keyUserUnclaimed(userIndex: Int) =
  ["%s%d", "userUnclaimed", userIndex.toString()].makeString(SEP)

func keyReferralsContractAddress()  = ["%s%s", "config", "referralsContractAddress"].makeString(SEP)
let referralsContractAddressOrFail = keyReferralsContractAddress().getStringOrFail().addressFromStringValue()

func keyTradingRewardHistory(user: String, i: Invocation) = {
  makeString(["%s%s%s%s", "tradingReward", "history", user, i.transactionId.toBase58String()], SEP)
}

func keyTradingReward(userAddress: String) = {
  makeString(["%s%s", "tradingReward", userAddress], SEP)
}

func keyMaxRecipients() = ["%s", "maxRecipients"].makeString(SEP)

func HistoryEntry(type: String, user: String, amount: Int, i: Invocation) = {
  let historyKEY = makeString(["%s%s%s%s__history", type, user, i.transactionId.toBase58String()], SEP)
  let historyDATA = makeString([
        "%d%d%d%d%d%d",
        lastBlock.height.toString(),
        lastBlock.timestamp.toString(),
        amount.toString()],
    SEP)
  StringEntry(historyKEY, historyDATA)
}

func keyManagerPublicKey() = "%s__managerPublicKey"
func keyManagerVaultAddress() = "%s__managerVaultAddress"

func getManagerVaultAddressOrThis() = {
  match keyManagerVaultAddress().getString() {
    case s:String => s.addressFromStringValue()
    case _=> this
  }
}

func managerPublicKeyOrUnit() = {
  let managerVaultAddress = getManagerVaultAddressOrThis()
  match managerVaultAddress.getString(keyManagerPublicKey()) {
    case s: String => s.fromBase58String()
    case _: Unit => unit
  }
}

func mustManager(i: Invocation) = {
  let pd = "Permission denied".throw()

  match managerPublicKeyOrUnit() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

func getUserIndexByAddress(boostingContractAddressStr: String, userAddress: String) = {
  let key = makeString(["%s%s%s", "mapping", "user2num", userAddress], SEP)
  parseIntValue(getString(Address(boostingContractAddressStr.fromBase58String()), key)
    .valueOrErrorMessage("User address " + userAddress + " is not found in boosting contract data, key=" + key))
}

func getTradingReward(userAddress: String) = {
  this.getInteger(userAddress.keyTradingReward()).valueOrElse(0)
}

func keyRewardPerGwxIntegral() = ["%s", "rewardPerGwxIntegral"].makeString(SEP)

func getGwxAmountTotalOption() = {
  let keyGwxTotal = "%s%s__gwx__total"
  boostingContractOrFail().getInteger(keyGwxTotal)
}

func getUserGwxAmountTotalOption(userAddress: Address) = {
  func keyUserGwxAmountTotal(userAddress: Address) = makeString([
    "%s%s__gwxAmountTotal",
    userAddress.toString()
  ], SEP)
  boostingContractOrFail().getInteger(keyUserGwxAmountTotal(userAddress))
}

# call when reward or total gwx amount are changed
func _refreshRewardPerGwxIntegral() = {
  # rewardPerGwx = dh * emissionPerBlock / totalGwxAmount + rewardPerGwxPrevious
  let rewardPerGwxIntegralPrevious = {
    match this.getString(keyRewardPerGwxIntegral()) {
      case s: String => s.parseBigInt()
      case _: Unit => unit
    }
  }.valueOrElse(zeroBigInt)
  let rewardPerGwxIntegralLastHeight = this.getInteger(keyGwxRewardEmissionStartHeight())
    .valueOrErrorMessage(wrapErr("invalid " + keyGwxRewardEmissionStartHeight()))
  let emissionRate = emissionContract.getInteger(keyRatePerBlockCurrent())
    .valueOrErrorMessage(wrapErr("invalid " + keyRatePerBlockCurrent()))
  let gwxHoldersRewardCurrent = emissionContract.getInteger(keyGwxHoldersRewardCurrent())
    .valueOrElse(0)
  let gwxAmountTotal = getGwxAmountTotalOption().valueOrElse(0)
  let dh = { height - rewardPerGwxIntegralLastHeight }.toBigInt()
  let gwxAmountTotalBI = gwxAmountTotal.toBigInt()
  let rewardPerGwxIntegral = rewardPerGwxIntegralPrevious + if (gwxAmountTotalBI == zeroBigInt) then zeroBigInt else fraction(
    dh,
    emissionRate.toBigInt() * gwxHoldersRewardCurrent.toBigInt() * MULT18BI,
    gwxAmountTotalBI * MULT8BI
  )

  (
    [
      IntegerEntry(keyGwxRewardEmissionStartHeight(), height),
      StringEntry(keyRewardPerGwxIntegral(), rewardPerGwxIntegral.toString())
    ],
    rewardPerGwxIntegral
  )
}

func keyRewardPerGwxIntegralUserLast(userAddress: Address) = ["%s%s", "rewardPerGwxIntegralUserLast", userAddress.toString()].makeString(SEP)

# call when user total gwx amount is changed
func _refreshUserReward(userAddress: Address, userNum: Int) = {
  let (rewardPerGwxIntegralActions, rewardPerGwxIntegral) = _refreshRewardPerGwxIntegral()

  let rewardPerGwxIntegralUserLast = {
    match this.getString(keyRewardPerGwxIntegralUserLast(userAddress)) {
      case s: String => s.parseBigInt().valueOrErrorMessage(wrapErr("invalid user last integral"))
      case _: Unit => rewardPerGwxIntegral
    }
  }

  let userIdxOption = boostingContractOrFail().getString(keyUser2NumMapping(userAddress))
  let userUnclaimed = keyUserUnclaimed(userNum).getInteger().valueOrElse(0)

  # userReward = userGwxAmount * (rewardPerGwxIntegral - rewardPerGwxIntegralUserLast) + userRewardPrevious - userRewardClaimed
  let userGwxAmount = getUserGwxAmountTotalOption(userAddress).valueOrElse(0)
  let userReward = fraction(userGwxAmount.toBigInt(), rewardPerGwxIntegral - rewardPerGwxIntegralUserLast, MULT18BI).toInt() + userUnclaimed

  (
    [
      StringEntry(
        keyRewardPerGwxIntegralUserLast(userAddress),
        rewardPerGwxIntegral.toString()
      )
    ] ++ rewardPerGwxIntegralActions,
    userReward
  )
}

func commonClaimReward(userAddressStr: String) = {
  let userAddress = addressFromString(userAddressStr).valueOrErrorMessage(wrapErr("invalid user address"))
  let cfgArray = readConfigArrayOrFail()
  let userNum = getUserIndexByAddress(cfgArray[IdxCfgBoostingContract], userAddressStr) # will throw if no such user
  let (actions, reward) = _refreshUserReward(userAddress, userNum)
  
  (
    reward,
    [
      IntegerEntry(userNum.keyUserUnclaimed(), 0)
    ] ++ actions
  )
}

@Callable(i)
func refreshUserReward(userAddressBytes: ByteVector, userNum: Int) = {
  strict checkCaller = i.caller == boostingContractOrFail() || throwErr("permission denied")

  let (actions, reward) = _refreshUserReward(Address(userAddressBytes), userNum)

  ([
    IntegerEntry(userNum.keyUserUnclaimed(), reward)
  ] ++ actions, reward)
}

@Callable(i)
func tradeRewardInternal(
  paymentAmountLeftOver: Int,
  userAddresses: List[String],
  rewards: List[Int],
  currentIter: Int
) = {
  if (currentIter == userAddresses.size()) then ([]) else

  strict checks = [
    i.caller == this || "Permission denied".throwErr(),
    paymentAmountLeftOver >= rewards[currentIter] || "insufficient payment assetId".throwErr()
  ]

  strict tradeRewardInternal = this.invoke(
    "tradeRewardInternal",
    [ 
      paymentAmountLeftOver - rewards[currentIter],
      userAddresses,
      rewards,
      currentIter+1
    ],
    []
  )

  let tradingRewardHistoryKey = keyTradingRewardHistory(
    userAddresses[currentIter],
    i
  )

  let userAddress = addressFromStringValue(userAddresses[currentIter])

  ([
    IntegerEntry(tradingRewardHistoryKey, rewards[currentIter]),
    IntegerEntry(userAddresses[currentIter].keyTradingReward(), rewards[currentIter])
  ], tradeRewardInternal)
}

@Callable(i)
func updateReferralActivity(userAddress: String, gWxAmountStart: Int) = {
  let referrer = referralsContractAddressOrFail.getString(userAddress.keyReferrer())
  strict activeReferralInv = if (referrer == unit) then unit else {
    referralsContractAddressOrFail.invoke("updateReferralActivity", [referralProgramName, userAddress, gWxAmountStart >= referralMinGWxAmount], [])
  }

  (nil, unit)
}

@Callable(i)
func processPendingPeriodsAndUsers() = {
  (nil, throwErr("deprecated"))
}

# Send all WX earned to caller
# called by user
@Callable(i)
func claimReward() = {
  let cfgArray = readConfigArrayOrFail()
  let userAddress = i.caller
  let userAddressStr = userAddress.toString()
  let (amount, actions) = commonClaimReward(userAddressStr)
  strict checkAmount = amount > 0 || "nothing to claim".throw()

  let userGwxAmount = boostingContractOrFail().invoke("getUserGwxAmount", [userAddressStr], []).exactAs[Int]
  let referrer = referralsContractAddressOrFail.getString(userAddressStr.keyReferrer())
  strict activeReferralInv = if (referrer == unit) then unit else {
    referralsContractAddressOrFail.invoke("updateReferralActivity", [referralProgramName, userAddress, userGwxAmount >= referralMinGWxAmount], [])
  }
  strict referralInv = if (referrer == unit || userGwxAmount < referralMinGWxAmount) then unit else {
    let referrerReward = amount.fraction(referrerRewardPermille, SCALE)
    let referralReward = amount.fraction(referralRewardPermille, SCALE)
    referralsContractAddressOrFail.invoke("incUnclaimed", [referralProgramName, userAddress, referrerReward, referralReward], [])
  }

  strict emit = emissionContract.invoke("emit", [amount], [])

  strict claimedReferral = referralsContractAddressOrFail.invoke("claim", [referralProgramName], []).exactAs[Int]
  let totalAmount = amount + claimedReferral
  (
    [
      ScriptTransfer(i.caller, amount, wxAssetId),
      HistoryEntry("claim", userAddressStr, totalAmount, i)
    ] ++ actions,
    totalAmount
  )
}

# returns total claimable reward by user address
@Callable(i)
func claimRewardREADONLY(address: String) = {
  let (amount, actions) = commonClaimReward(address)
  let referralUnclaimed = referralsContractAddressOrFail.getInteger(keyUnclaimedReferral(referralProgramName, address)).valueOrElse(0)
  let totalAmount = amount + referralUnclaimed

  ([], totalAmount)
}

# save starting height of reward from emission 5%
@Callable(i)
func onEmissionForGwxStart() = {
  if (i.caller != factoryContract) then throw("permissions denied") else
  [IntegerEntry(keyGwxRewardEmissionStartHeight(), height)]
}

@Callable(i)
func tradeReward(userAddresses: List[String], rewards: List[Int]) = {
  let argsComparison = userAddresses.size() == rewards.size()
  let maxRecipients = keyMaxRecipients().getInteger().valueOrElse(0)
  let payment = i.payments[0]
  let paymentAssetId = payment.assetId
  let paymentAmount = payment.amount

  strict checks = [
    userAddresses.size() <= maxRecipients || "Too many recipients".throwErr(),
    argsComparison || "Arguments size mismatch".throwErr(),
    paymentAssetId == wxAssetId || "Wrong asset payment".throwErr()
  ]

  strict tradeRewardInternal = this.invoke(
    "tradeRewardInternal",
    [
      paymentAmount,
      userAddresses,
      rewards,
      0
    ],
    []
  )

  (nil, tradeRewardInternal)
}

@Callable(i)
func claimTradingReward() = {
  let userAddress = i.caller
  let userAddressString = userAddress.toString()
  let reward = userAddressString.getTradingReward()
  if (reward > 0) then {
    ([
      ScriptTransfer(userAddress, reward, wxAssetId),
      IntegerEntry(keyTradingReward(userAddressString), 0)
    ], reward)
  } else "nothing to claim".throwErr()
}

@Callable(i)
func claimTradingRewardREADONLY(userAddress: String) = {
  (nil, userAddress.getTradingReward())
}

@Verifier(tx)
func verify() = {
  let targetPublicKey = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
}
