{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let separator = "__"

func keyWxAssetId() = ["%s", "wxAssetId"].makeString(separator)

let keyBackendPublicKey = makeString(["%s", "backendPublicKey"], separator)

func keyExistsReferrerToReferral(
  programName: String,
  referrerAddress: String,
  referralAddress: String
) = ["%s%s%s%s", "existsReferrerToReferral", programName, referrerAddress, referralAddress].makeString(separator)
func keyClaimedReferrer(
  programName: String,
  claimerAddress: String
) = makeString(["%s%s%s%s", "claimedReferrer", programName, claimerAddress], separator)
func keyClaimedReferral(
  programName: String,
  claimerAddress: String
) = makeString(["%s%s%s%s", "claimedReferral", programName, claimerAddress], separator)
func keyUnclaimedReferrer(
  programName: String,
  claimerAddress: String
) = makeString(["%s%s%s%s", "unclaimedReferrer", programName, claimerAddress], separator)
func keyUnclaimedReferral(
  programName: String,
  claimerAddress: String
) = makeString(["%s%s%s%s", "unclaimedReferral", programName, claimerAddress], separator)
func keyReferrer(
  programName: String,
  referralAddress: String
) = makeString(["%s%s%s", "referrer", programName, referralAddress], separator)
func keyProgramName(programName: String) = makeString(["%s%s", "programName", programName], separator)
func keyTotalReferralCount(
  programName: String,
  referrerAddress: String
) = makeString(["%s%s%s", "totalReferralCount", programName, referrerAddress], separator)
func keyActiveReferralCount(
  programName: String,
  referrerAddress: String
) = makeString(["%s%s%s", "activeReferralCount", programName, referrerAddress], separator)
func keyIsReferralActive(
  programName: String,
  referralAddress: String
) = makeString(["%s%s%s", "activeReferral", programName, referralAddress], separator)

func keyClaimedTotal(programName: String)           = ["%s%s", "claimedTotal", programName].makeString(separator)
func keyRewardsTotal(programName: String)           = ["%s%s", "rewardsTotal", programName].makeString(separator)
func keyRewardAssetId(programName: String)          = ["%s%s", "rewardAssetId", programName].makeString(separator)
func keyTreasuryContract(programName: String)       = ["%s%s", "treasuryContract", programName].makeString(separator)
func keyImplementationContract(programName: String) = {
  ["%s%s", "implementationContract", programName].makeString(separator)
}
func keyAllRefferalPrograms(address: String) = ["%s%s", "allReferralPrograms", address].makeString(separator)
func keyClaimedTotalProgram(programName: String) = ["%s%s", "claimedTotalProgram", programName].makeString(separator)
func keyUnclaimedTotal(address: String) = ["%s%s", "unclaimedTotalAddress", address].makeString(separator)
func keyLastBulkClaimCallBlock(address: String) = ["%s%s", "lastBulkClaimCallBlock", address].makeString(separator)

func keyManagerPublicKey() = "%s__managerPublicKey"
func keyPendingManagerPublicKey() = "%s__pendingManagerPublicKey"

func keyClaimHistory(
  programName: String,
  userAddress: String,
  transactionId: String,
  type: String
) = ["%s%s%s%s%s", "history", type, programName, userAddress, transactionId].makeString(separator)
func formatClaimHistory(amount: Int) = ["%d%d%d", lastBlock.height.toString(), lastBlock.timestamp.toString(), amount.toString()].makeString(separator)

func throwErr(msg: String) = ["referral.ride:", msg].makeString(" ").throw()

func managerPublicKeyOrUnit() = match keyManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func pendingManagerPublicKeyOrUnit() = match keyPendingManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func mustManager(i: Invocation) = {
  let pd = "permission denied".throwErr()

  match managerPublicKeyOrUnit() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

@Callable(i)
func claimBulkInternal(claimer: String, programNames: List[String], currentIter: Int) = {
  strict checkCaller = i.caller == this || "permission denied".throwErr()
  if (currentIter == programNames.size()) then ([]) else

  let programName       = programNames[currentIter]
  let programUnclaimed  = programName.keyUnclaimedReferrer(claimer).getInteger().valueOrElse(0)
  let claimHistoryKey   = programName.keyClaimHistory(
    claimer,
    i.transactionId.toBase58String(),
    "claimBulk"
  )

  strict inv = this.invoke(
    "claimBulkInternal",
    [
      claimer,
      programNames,
      currentIter+1
    ],
    []
  )

  let claimedTotal      = programName.keyClaimedTotal().getInteger().valueOrElse(0)
  let treasuryContract  = programName.keyTreasuryContract().getString().value().addressFromString().value()
  let rewardAssetId     = programName.keyRewardAssetId().getString().value().fromBase58String()
  let claimerUnclaimed  = programName.keyUnclaimedReferrer(claimer).getInteger().valueOrElse(0)

  strict balanceBefore  = this.assetBalance(rewardAssetId).value()
  strict res            = treasuryContract.invoke("withdrawReferralReward", [claimerUnclaimed], [])
  strict balanceAfter   = this.assetBalance(rewardAssetId).value()
  strict balanceDiff    = balanceAfter - balanceBefore
  strict checkBalance   = balanceDiff == claimerUnclaimed || "insufficient balance on referral contract".throwErr()

  (
    [
      ScriptTransfer(claimer.addressFromStringValue(), programUnclaimed, rewardAssetId),
      StringEntry(claimHistoryKey, programUnclaimed.formatClaimHistory())
    ]
  )
}

@Callable(i)
func incUnclaimedWithPaymentInternal(
  paymentAmounts: List[Int],
  programName: String,
  referrerAddresses: List[String],
  currentIter: Int,
  resAmount: Int
) = {
  strict checkCaller = i.caller == this || "permission denied".throwErr()

  let argsComparison = paymentAmounts.size() == referrerAddresses.size()
  strict check = argsComparison || "lists in args must be same size".throwErr()
  if (currentIter == paymentAmounts.size()) then ([], resAmount) else

  let referrerUnclaimed = programName.keyUnclaimedReferrer(referrerAddresses[currentIter]).getInteger().valueOrElse(0)
  let rewardsTotal = programName.keyRewardsTotal().getInteger().valueOrElse(0)

  let newReferrerUnclaimed = referrerUnclaimed + paymentAmounts[currentIter]
  let newResAmount = resAmount + paymentAmounts[currentIter]

  strict inv = this.invoke(
    "incUnclaimedWithPaymentInternal",
    [
      paymentAmounts,
      programName,
      referrerAddresses,
      currentIter+1,
      newResAmount
    ], []
  )

  ([
    IntegerEntry(programName.keyUnclaimedReferrer(referrerAddresses[currentIter]), newReferrerUnclaimed),
    IntegerEntry(programName.keyRewardsTotal(), rewardsTotal + paymentAmounts[currentIter])
  ], inv)
}

@Callable(i)
func createReferralProgram(programName: String, treasuryContract: String, implementationContract: String, rewardAssetId: String) = {
  strict checkCaller = i.mustManager()
  strict checkProgramName = programName.keyProgramName().getBoolean() == unit || "program name already exists".throwErr()
  let programNameIsValid = !programName.contains(separator) && !programName.contains(" ")
  strict checkProgramExists = programNameIsValid || "invalid program name".throwErr()
  strict checkRewardAsset = rewardAssetId.fromBase58String().assetInfo() != unit || "invalid reward asset id".throwErr()

  ([
    BooleanEntry(programName.keyProgramName(), true),
    StringEntry(programName.keyTreasuryContract(), treasuryContract),
    StringEntry(programName.keyImplementationContract(), implementationContract),
    StringEntry(programName.keyRewardAssetId(), rewardAssetId),
    IntegerEntry(programName.keyRewardsTotal(), 0)
  ], unit)
}

@Callable(i)
func createPair(
  programName: String,
  referrerAddress: String,
  referralAddress: String,
  signature: ByteVector
) = {
  strict checkProgramExists = programName.keyProgramName().getBoolean().valueOrElse(false) || "program does not exist".throwErr()
  strict pairReferrerToReferralExistCheck = programName.keyExistsReferrerToReferral(
    referrerAddress, referralAddress
  ).getBoolean() == unit || "pair already exists".throwErr()
  strict noRefSelf = referrerAddress != referralAddress || "cannot refer to self".throwErr()

  let pair = [programName, referrerAddress, referralAddress].makeString(":").toBytes()
  let backendPublicKey = keyBackendPublicKey.getString().value().fromBase58String()
  strict validateSignature = sigVerify(pair, signature, backendPublicKey) || "bad signature".throwErr()

  let totalReferralCount = programName.keyTotalReferralCount(referrerAddress).getInteger().valueOrElse(0)
  let newTotalReferralCount = totalReferralCount + 1

  let allReferrerPrograms = referrerAddress.keyAllRefferalPrograms().getString().valueOrElse("")
  let newAllReferrerPrograms = if allReferrerPrograms == "" then {
    programName
  } else {
    makeString([allReferrerPrograms, programName], separator)
  }
  
  let allReferralPrograms = referralAddress.keyAllRefferalPrograms().getString().valueOrElse("")
  let newAllReferralPrograms = if allReferralPrograms == "" then {
    programName
  } else {
    makeString([allReferralPrograms, programName], separator)
  }

  ([
    BooleanEntry(programName.keyExistsReferrerToReferral(referrerAddress, referralAddress), true),
    IntegerEntry(programName.keyTotalReferralCount(referrerAddress), newTotalReferralCount),
    StringEntry(programName.keyReferrer(referralAddress), referrerAddress),
    StringEntry(referrerAddress.keyAllRefferalPrograms(), newAllReferrerPrograms),
    StringEntry(referralAddress.keyAllRefferalPrograms(), newAllReferralPrograms)
  ], unit)
}

@Callable(i)
func updateReferralActivity(
  programName: String,
  referralAddress: String,
  isActive: Boolean
) = {
  let implementationContract  = programName.keyImplementationContract().getString().value()
  let isReferralActive        = programName.keyIsReferralActive(referralAddress).getBoolean() != unit
  let referrerAddress         = programName.keyReferrer(referralAddress).getString().value()

  strict checkCaller = i.caller.toString() == implementationContract || "permission denied".throwErr()

  let update = if isReferralActive == isActive then {
    ([], unit)
  } else {
    let update = if isActive == true then {
      let newActiveReferralCount = programName.keyActiveReferralCount(referrerAddress).getInteger().valueOrElse(0) + 1
      ([
        BooleanEntry(programName.keyIsReferralActive(referralAddress), true),
        IntegerEntry(programName.keyActiveReferralCount(referrerAddress), newActiveReferralCount)
      ], unit)
    } else {
      let newActiveReferralCount = programName.keyActiveReferralCount(referrerAddress).getInteger().valueOrElse(0) - 1
      ([
        DeleteEntry(programName.keyIsReferralActive(referralAddress)),
        IntegerEntry(programName.keyActiveReferralCount(referrerAddress), newActiveReferralCount)
      ], unit)
    }
    update
  }

  update
}

@Callable(i)
func incUnclaimed(
  programName: String,
  referralAddress: String,
  referrerReward: Int,
  referralReward: Int
) = {
  let implementationContract = programName.keyImplementationContract().getString().value()
  strict checkCaller = i.caller.toString() == implementationContract || "permission denied".throwErr()

  let referrerAddress   = programName.keyReferrer(referralAddress).getString().value()
  let referrerUnclaimed = programName.keyUnclaimedReferrer(referrerAddress).getInteger().valueOrElse(0)
  let referralUnclaimed = programName.keyUnclaimedReferral(referralAddress).getInteger().valueOrElse(0)
  let rewardsTotal = programName.keyRewardsTotal().getInteger().valueOrElse(0)

  let newReferrerUnclaimed = referrerUnclaimed + referrerReward
  let newReferralUnclaimed = referralUnclaimed + referralReward

  ([
    IntegerEntry(programName.keyUnclaimedReferrer(referrerAddress), newReferrerUnclaimed),
    IntegerEntry(programName.keyUnclaimedReferral(referralAddress), newReferralUnclaimed),
    IntegerEntry(programName.keyRewardsTotal(), rewardsTotal + referrerReward + referralReward)
  ], unit)
}

@Callable(i)
func incUnclaimedWithPayment(programName: String, referrerAddresses: List[String]) = {
  func map(accum: List[Int], next: AttachedPayment) = accum :+ next.amount
  let payments = FOLD<10>(i.payments, [], map)

  strict resAmount = this.invoke(
    "incUnclaimedWithPaymentInternal",
    [
      payments,
      programName,
      referrerAddresses,
      0,
      0
    ], []
  ).exactAs[Int]

  let treasuryContract = programName.keyTreasuryContract().getString().value().addressFromStringValue()
  let rewardAssetId    = programName.keyRewardAssetId().getString().value().fromBase58String()

  [
    ScriptTransfer(treasuryContract, resAmount, rewardAssetId)
  ]
}

@Callable(i)
func claim(programName: String) = {
  strict checkProgramExists = programName.keyProgramName().getBoolean().valueOrElse(false) || "program does not exist".throwErr()
  let isImplementationContract = i.caller.toString() == keyImplementationContract(programName).getString().value()
  let (userAddressStr, claimerClaimed, claimerUnclaimed, keyClaimed, keyUnclaimed, claimHistoryKey) = if (isImplementationContract) then {
    let user = i.originCaller.toString()
    (
      user,
      programName.keyClaimedReferral(user).getInteger().valueOrElse(0),
      programName.keyUnclaimedReferral(user).getInteger().valueOrElse(0),
      programName.keyClaimedReferral(user),
      programName.keyUnclaimedReferral(user),
      programName.keyClaimHistory(user, i.transactionId.toBase58String(), "claimReferral")
    )
  } else {
    let user = i.caller.toString()
    (
      user,
      programName.keyClaimedReferrer(user).getInteger().valueOrElse(0),
      programName.keyUnclaimedReferrer(user).getInteger().valueOrElse(0),
      programName.keyClaimedReferrer(user),
      programName.keyUnclaimedReferrer(user),
      programName.keyClaimHistory(user, i.transactionId.toBase58String(), "claimReferrer")
    )
  }
  let claimedTotal      = programName.keyClaimedTotal().getInteger().valueOrElse(0)
  let treasuryContract  = programName.keyTreasuryContract().getString().value().addressFromString().value()
  let rewardAssetId     = programName.keyRewardAssetId().getString().value().fromBase58String()

  if (isImplementationContract && claimerUnclaimed == 0) then {
	  ([], 0)
  } else {
    strict checkCanClaim  = claimerUnclaimed > 0 || "nothing to claim".throwErr()

    let newClaimerClaimed = claimerClaimed + claimerUnclaimed
    let newClaimedTotal   = claimedTotal + claimerUnclaimed

    strict balanceBefore  = this.assetBalance(rewardAssetId).value()
    strict res            = treasuryContract.invoke("withdrawReferralReward", [claimerUnclaimed], [])
    strict balanceAfter   = this.assetBalance(rewardAssetId).value()
    strict balanceDiff    = balanceAfter - balanceBefore
    strict checkBalance   = balanceDiff == claimerUnclaimed || "insufficient balance on referral contract".throwErr()

    ([
      IntegerEntry(keyClaimed, newClaimerClaimed),
      IntegerEntry(programName.keyClaimedTotal(), newClaimedTotal),
      IntegerEntry(keyUnclaimed, 0),
      ScriptTransfer(userAddressStr.addressFromStringValue(), claimerUnclaimed, rewardAssetId),
      StringEntry(
        claimHistoryKey,
        claimerUnclaimed.formatClaimHistory()
      )
    ], claimerUnclaimed)
  }
}

@Callable(i)
func claimBulk() = {
  let callerProgramsStr = i.caller.toString().keyAllRefferalPrograms().getString()
  let callerAddress = i.caller.toString()
  let lastCall = callerAddress.keyLastBulkClaimCallBlock().getInteger().valueOrElse(height)
  let waitBlocks = height - lastCall - 3

  strict lastCallCheck = lastCall > height - 3 || [
    "wait",
    waitBlocks.toString(),
    "blocks"
  ].makeString(" ").throwErr()
  strict programsExists = callerProgramsStr.isDefined() || "no referral programs".throwErr()

  let callerPrograms = callerProgramsStr.value().split("__")

  strict bulkClaim = this.invoke(
    "claimBulkInternal",
    [
      callerAddress,
      callerPrograms,
      0
    ], []
  )

  ([IntegerEntry(callerAddress.keyLastBulkClaimCallBlock(), height)], bulkClaim)
}

@Callable(i)
func claimREADONLY(programName: String, userAddress: String) = {
  let claimerClaimed    = programName.keyClaimedReferrer(userAddress).getInteger().valueOrElse(0)
  let claimerUnclaimed  = programName.keyUnclaimedReferrer(userAddress).getInteger().valueOrElse(0)

  ([], [claimerUnclaimed, claimerClaimed])
}

@Callable(i)
func setManager(pendingManagerPublicKey: String) = {
  strict checkCaller            = i.mustManager()
  strict checkManagerPublicKey  = pendingManagerPublicKey.fromBase58String()

  [StringEntry(keyPendingManagerPublicKey(), pendingManagerPublicKey)]
}

@Callable(i)
func confirmManager() = {
  let pm = pendingManagerPublicKeyOrUnit()
  strict hasPM    = pm.isDefined() || "no pending manager".throwErr()
  strict checkPM  = i.callerPublicKey == pm.value() || "you are not pending manager".throwErr()

  [
    StringEntry(keyManagerPublicKey(), pm.value().toBase58String()),
    DeleteEntry(keyPendingManagerPublicKey())
  ]
}

@Verifier(tx)
func verify() = {
  let targetPublicKey = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
}
