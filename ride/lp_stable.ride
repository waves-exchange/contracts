{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# TODO:
#
#  add callable to remove existing pool
#  add restriction on min deposit amount
#  AMU: move "WAVES" into spec variable
#  AMU: add safe cast method instead of copy/past: inAmAssetId.valueOrElse("WAVES".fromBase58String()).toBase58String()

# Description:
#   Contract represents single liquidity pool for specific asset pair, e.g. BTC-USDN
#
#   Actors:
#      1. LP
#      2. Factory
#      3. Matcher
#
#   Actor LP could do do the following:
#      1. Enter the pool
#      2. Exit the pool
#
#   Factory LP could do do the following:
#      1. Activate the pool
#      2. Halt pool operations partially of completelly
#
#   Matcher LP could do do the following:
#      1. Perform exchange operations with pool assets
#
#   New Pool deployment flow:
#      0. Factory contract has BLAKE2b-256 hash of the Pool contract.
#      1. Pool contract is deployed to the blockchain (factory address is injected into it)
#      2. Factory calls 'activate' callable and activate pool in case all prerequisites passed (assset pairs are not registered, contract hash matches actual)

#-----------------
# GLOBAL VARIABLES
#-----------------
let scale8 = 100_000_000
let scale8BigInt = 100_000_000.toBigInt()
let scale18 = 1_000_000_000_000_000_000.toBigInt()
let zeroBigInt = 0.toBigInt()
let big0 = 0.toBigInt()
let big1 = 1.toBigInt()
let big2 = 2.toBigInt()
let big3 = 3.toBigInt()
let big4 = 4.toBigInt()
let slippage4D = (scale8 - scale8 * 1 / scale8).toBigInt() # 9999999 or error of 0.0000001
let wavesString = "WAVES"

let Amult = "100"
let Dconv = "1" # D convergence

let SEP = "__"
let EMPTY = ""
let PoolActive               = 1   # ACTIVE, pool without restrictions
let PoolPutDis               = 2   # PUT DISABLED, pool with put operation disabled
let PoolMatcherDis           = 3   # MATCHER DISABLED, pool with matcher operations disabled
let PoolShutdown             = 4   # SHUTDOWN, pool operations halted
# data indexes from pool config stored in factory
let idxPoolAddress                           = 1
let idxPoolSt                               = 2
let idxLPAsId                                = 3
let idxAmAsId                                = 4
let idxPrAsId                                = 5
let idxAmtAsDcm                              = 6
let idxPriceAsDcm                            = 7
let idxIAmtAsId                              = 8
let idxIPriceAsId                            = 9
# data indexes from factory config
let idxFactStakCntr       = 1
let idxFactoryRestCntr    = 6
let idxFactSlippCntr      = 7
let idxFactGwxRewCntr     = 10

let feeDefault = fraction(10, scale8, 10_000)
#-------------------------
# WX COMMON LIBRARY
#-------------------------
func t1(origVal: Int, origScaleMult: Int)        = fraction(origVal.toBigInt(), scale18, origScaleMult.toBigInt())
func t1BigInt(origVal: BigInt, origScaleMult: BigInt)        = fraction(origVal, scale18, origScaleMult)
func f1(val: BigInt, resultScaleMult: Int)       = fraction(val, resultScaleMult.toBigInt(), scale18).toInt()
func fromX18Round(
  val: BigInt,
  resultScaleMult: Int,
  round: Ceiling|Floor
) = fraction(val, resultScaleMult.toBigInt(), scale18, round).toInt()

func t2(origVal: BigInt, origScaleMult: Int) = fraction(origVal, scale18, origScaleMult.toBigInt()) 
func f2(val: BigInt, resultScaleMult: Int) = fraction(val, resultScaleMult.toBigInt(), scale18)

# cast passed amount to specified 'resScale' scale value from 'curScale' scale value
func ts(amt: Int, resScale: Int, curScale: Int)  = fraction(amt, resScale, curScale)

func abs(val: BigInt) = if (val < zeroBigInt) then -val else val
func absBigInt(val: BigInt) = if (val < zeroBigInt) then -val else val

#-------------------------
# KEYS ON CURRENT CONTRACT
#-------------------------
func fc() = {"%s__factoryContract"}
func mpk() = {"%s__managerPublicKey"}
func pmpk() = {"%s__pendingManagerPublicKey"}
func pl() = {"%s%s__price__last"}
func ph(h: Int, t: Int) = {makeString(["%s%s%d%d__price__history", h.toString(), t.toString()], SEP)}
# keyPutActionByUser
func pau(ua: String, txId: String) = "%s%s%s__P__" + ua + "__" + txId
# keyGetActionByUser
func gau(ua: String, txId: String) = "%s%s%s__G__" + ua + "__" + txId
func aa() = {"%s__amountAsset"}
func pa() = {"%s__priceAsset"}
# keyAmplificator
func amp() = {"%s__amp"}
func ada() = "%s__addonAddr"

let keyFee = "%s__fee"
let fee = this.getInteger(keyFee).valueOrElse(feeDefault)

let keyDLp = ["%s", "dLp"].makeString(SEP)
let keyDLpRefreshedHeight = ["%s", "dLpRefreshedHeight"].makeString(SEP)
let keyDLpRefreshDelay = ["%s", "refreshDLpDelay"].makeString(SEP)
let dLpRefreshDelayDefault = 30
let dLpRefreshDelay = this.getInteger(keyDLpRefreshDelay).valueOrElse(dLpRefreshDelayDefault)

#------------------------
# KEYS ON OTHER CONTRACTS
#------------------------
# from factory
# keyFactoryConfig
func fcfg() = {"%s__factoryConfig"}
# keyMatcherPub
func mtpk() = "%s%s__matcher__publicKey"
# keyPoolConfig
func pc(iAmtAs: String, iPrAs: String) = {"%d%d%s__" + iAmtAs + "__" + iPrAs + "__config"}
# keyMappingsBaseAsset2internalId
func mba(bAStr: String) = {"%s%s%s__mappings__baseAsset2internalId__" + bAStr}
# keyAllPoolsShutdown
func aps() = {"%s__shutdown"}
func keyAllowedLpStableScriptHash() = "%s__allowedLpStableScriptHash"
func keyFeeCollectorAddress() = "%s__feeCollectorAddress"

#------------------------
# FAILURES
#------------------------
func throwOrderError(
  orderValid: Boolean,
  orderValidInfo: String,
  senderValid: Boolean,
  matcherValid: Boolean
) = {
  throw("order validation failed: orderValid=" + orderValid.toString() + " (" + orderValidInfo + ")" + " senderValid=" + senderValid.toString() + " matcherValid=" + matcherValid.toString())
}

#------------------------
# GLOBAL FUNCTIONS
#------------------------

# getStringOrFail
func strf(addr: Address, key: String) = addr.getString(key).valueOrErrorMessage(makeString(["mandatory ", addr.toString(), ".", key, " not defined"], ""))
# getIntOrFail
func intf(addr: Address, key: String) = addr.getInteger(key).valueOrErrorMessage(makeString(["mandatory ", addr.toString(), ".", key, " not defined"], ""))

func throwErr(msg: String) = ["lp_stable.ride:", msg].makeString(" ").throw()
func fmtErr(msg: String) = ["lp_stable.ride:", msg].makeString(" ")

# factoryContract
let fca = addressFromStringValue(strf(this, fc()))

let inFee = fca.invoke("getInFeeREADONLY", [this.toString()], []).exactAs[Int]
let outFee = fca.invoke("getOutFeeREADONLY", [this.toString()], []).exactAs[Int]

let A = strf(this, amp())

# isGlobalShutdown
# check that global shutdown is take place
func igs() = {
  fca.getBoolean(aps()).valueOrElse(false)
}

# getMatcherPubOrFail
func mp() = {
  fca.strf(mtpk()).fromBase58String()
}

let feeCollectorAddress = fca.strf(keyFeeCollectorAddress()).addressFromStringValue()

# getPoolConfig
# function used to gather all pool data from factory
func gpc() = {
  let amtAs = strf(this, aa())
  let priceAs = strf(this, pa())
  let iPriceAs = intf(fca, mba(priceAs))
  let iAmtAs = intf(fca, mba(amtAs))
  strf(fca, pc(iAmtAs.toString(), iPriceAs.toString())).split(SEP)
}

func parseAssetId(input: String) = {
  if (input == wavesString) then unit else input.fromBase58String()
}

func assetIdToString(input: ByteVector|Unit) = {
  if (input == unit) then wavesString else input.value().toBase58String()
}

func parsePoolConfig(poolConfig: List[String]) = {
  (
    poolConfig[idxPoolAddress].addressFromStringValue(),
    poolConfig[idxPoolSt].parseIntValue(),
    poolConfig[idxLPAsId].fromBase58String(),
    poolConfig[idxAmAsId].parseAssetId(),
    poolConfig[idxPrAsId].parseAssetId(),
    poolConfig[idxAmtAsDcm].parseIntValue(),
    poolConfig[idxPriceAsDcm].parseIntValue(),
    poolConfig[idxIAmtAsId].fromBase58String(),
    poolConfig[idxIPriceAsId].fromBase58String()
  )
}

let poolConfigParsed = gpc().parsePoolConfig()
let (
  cfgPoolAddress,
  cfgPoolStatus,
  cfgLpAssetId,
  cfgAmountAssetId,
  cfgPriceAssetId,
  cfgAmountAssetDecimals,
  cfgPriceAssetDecimals,
  cfgInAmountAssedId,
  cfgInPriceAssetId
) = poolConfigParsed

# getFactoryConfig
func gfc() = {
  strf(fca, fcfg()).split(SEP)
}

let factoryConfig = gfc()
let stakingContract = factoryConfig[idxFactStakCntr].addressFromString().valueOrErrorMessage("Invalid staking contract address")
let slipageContract = factoryConfig[idxFactSlippCntr].addressFromString().valueOrErrorMessage("Invalid slipage contract address")
let gwxContract = factoryConfig[idxFactGwxRewCntr].addressFromString().valueOrErrorMessage("Invalid gwx contract address")
let restContract = factoryConfig[idxFactoryRestCntr].addressFromString().valueOrErrorMessage("Invalid gwx contract address")

func dataPutActionInfo(inAmtAssetAmt: Int, inPriceAssetAmt: Int, outLpAmt: Int, price: Int, slipByUser: Int, slippageReal: Int, txHeight: Int, txTimestamp: Int, slipageAmAmt: Int, slipagePrAmt: Int) = {
  makeString(["%d%d%d%d%d%d%d%d%d%d", inAmtAssetAmt.toString(), inPriceAssetAmt.toString(), outLpAmt.toString(), price.toString(), slipByUser.toString(), slippageReal.toString(), txHeight.toString(), txTimestamp.toString(), slipageAmAmt.toString(), slipagePrAmt.toString()], SEP)
}

func dataGetActionInfo(outAmtAssetAmt: Int, outPriceAssetAmt: Int, inLpAmt: Int, price: Int, txHeight: Int, txTimestamp: Int) = {
  makeString( ["%d%d%d%d%d%d", outAmtAssetAmt.toString(), outPriceAssetAmt.toString(), inLpAmt.toString(), price.toString(), txHeight.toString(), txTimestamp.toString()], SEP)
}

func getAccBalance(assetId: String) = {
  if(assetId == "WAVES") then wavesBalance(this).available else assetBalance(this, fromBase58String(assetId))
}

# calcPriceBigInt
func cpbi(prAmtX18: BigInt, amAmtX18: BigInt) = {
  fraction(prAmtX18, scale18, amAmtX18)
}

func cpbir(prAmtX18: BigInt, amAmtX18: BigInt, round: Ceiling|Floor) = {
  fraction(prAmtX18, scale18, amAmtX18, round)
}

# validateAbsDiff
func vad(A1: BigInt, A2: BigInt, slippage: BigInt) = {
  let diff = fraction(A1 - A2, scale8BigInt, A2)
  let pass = (slippage - abs(diff)) > zeroBigInt
  if (!pass) then throw("Big slpg: " + diff.toString()) else
  (pass, min([A1, A2]))
}

# validateD
func vd(D1: BigInt, D0: BigInt, slpg: BigInt) = {
  let diff = fraction(D0, scale8BigInt, D1)
  let fail = diff < slpg
  if (fail || D1 < D0) then throw(D0.toString() + " " + D1.toString() + " " + diff.toString() + " " + slpg.toString()) else
  fail
}

# privateCalcPrice
# cast assets and calc price
func pcp(amAssetDcm: Int, prAssetDcm: Int, amAmt: Int, prAmt: Int) = {
    let amtAsAmtX18 = amAmt.t1(amAssetDcm)
    let prAsAmtX18 = prAmt.t1(prAssetDcm)
    cpbi(prAsAmtX18, amtAsAmtX18)
}

# used only in stats endpoint, so result values are in scale8 as required
func calcPrices(amAmt: Int, prAmt: Int, lpAmt: Int) = {
  let amtAsDcm = cfgAmountAssetDecimals
  let prAsDcm = cfgPriceAssetDecimals

  let priceX18 = pcp(amtAsDcm, prAsDcm, amAmt, prAmt)

  let amAmtX18 = amAmt.t1(amtAsDcm)
  let prAmtX18 = prAmt.t1(prAsDcm)
  let lpAmtX18 = lpAmt.t1(scale8)

  let lpPrInAmAsX18 = cpbi(amAmtX18, lpAmtX18)
  let lpPrInPrAsX18 = cpbi(prAmtX18, lpAmtX18)

  [priceX18, lpPrInAmAsX18, lpPrInPrAsX18]
}

# public API which is used by backend
func calculatePrices(amAmt: Int, prAmt: Int, lpAmt: Int) = {
    let p = calcPrices(amAmt, prAmt, lpAmt)
    [p[0].f1(scale8),
        p[1].f1(scale8),
        p[2].f1(scale8)]
}

func takeFee(amount: Int, fee: Int) = {
  let feeAmount = if (fee == 0) then 0 else fraction(amount, fee, scale8)
  (amount - feeAmount, feeAmount)
}

func getD(xp: List[BigInt]) = {
  let xp0 = xp[0]
  let xp1 = xp[1]
  let s = xp0 + xp1
  if (s == big0) then big0 else {
    let a = A.parseIntValue()
    let ann = a * 2
    let p = fraction(xp0, xp1, big1)
    let xp0_xp1_n_n = fraction(p, big4, big1)
    let ann_s = fraction(ann.toBigInt(), s, big1)
    let ann_1 = (ann - 1).toBigInt()
    func calcDNext(d: BigInt) = {
      let dd = fraction(d, d, big1)
      let ddd = fraction(dd, d, big1)
      let dp = fraction(ddd, big1, xp0_xp1_n_n)
      fraction(
        ann_s + fraction(dp, big2, big1),
        d,
        fraction(ann_1, d, big1) + fraction(big3, dp, big1)
      )
    }
    func calc(acc: (BigInt, Boolean), i: Int) = {
      if (acc._2) then acc else {
        let d = acc._1
        let dNext = d.calcDNext()
        let dDiffRaw = dNext - d.value()
        let dDiff = if (dDiffRaw < big0) then -dDiffRaw else dDiffRaw
        if (dDiff <= big1) then {
          (dNext, true)
        } else {
          (dNext, false)
        }
      }
    }
    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
    let (d, found) = FOLD<15>(arr, (s, false), calc)
    if (found) then {
      d
    } else {
      { "D calculation error, D = " + d.toString() }.throw()
    }
  }
}

# estimateGetOperation
func ego(txId58: String, pmtAssetId: String, pmtLpAmt: Int, userAddress: Address) = {
  let lpId   = cfgLpAssetId
  let amId   = cfgAmountAssetId.value().toBase58String()
  let prId   = cfgPriceAssetId.value().toBase58String()
  let amDcm  = cfgAmountAssetDecimals
  let prDcm  = cfgPriceAssetDecimals
  let sts    = cfgPoolStatus.toString()

  let lpEmiss = assetInfo(lpId).valueOrErrorMessage("Wrong LP id").quantity

  # validation block
  if (lpId.toBase58String() != pmtAssetId) then throw("Wrong pmt asset") else

  let amBalance = getAccBalance(amId)
  let amBalanceX18 = amBalance.t1(amDcm)

  let prBalance = getAccBalance(prId)
  let prBalanceX18 = prBalance.t1(prDcm)

  let curPriceX18 = cpbi(prBalanceX18, amBalanceX18)
  let curPrice = curPriceX18.f1(scale8)

  let pmtLpAmtX18 = pmtLpAmt.t1(scale8)
  let lpEmissX18 = lpEmiss.t1(scale8)
  # calculations
  let outAmAmtX18 = fraction(amBalanceX18, pmtLpAmtX18, lpEmissX18)
  let outPrAmtX18 = fraction(prBalanceX18, pmtLpAmtX18, lpEmissX18)

  # cast amounts to asset decimals
  let outAmAmt = outAmAmtX18.fromX18Round(amDcm, FLOOR)
  let outPrAmt = outPrAmtX18.fromX18Round(prDcm, FLOOR)

  let state = if (txId58 == "") then [] else
  [
    ScriptTransfer(userAddress, outAmAmt, if (amId == "WAVES") then unit else amId.fromBase58String()),
    ScriptTransfer(userAddress, outPrAmt, if (prId == "WAVES") then unit else prId.fromBase58String()),

    StringEntry(
          gau(userAddress.toString(), txId58),
          dataGetActionInfo(outAmAmt, outPrAmt, pmtLpAmt, curPrice, height, lastBlock.timestamp)),
    IntegerEntry(pl(), curPrice),
    IntegerEntry(ph(height, lastBlock.timestamp), curPrice)
  ]

  ( outAmAmt,     # 1
    outPrAmt,     # 2
    amId,         # 3
    prId,         # 4
    amBalance,    # 5
    prBalance,    # 6
    lpEmiss,   # 7
    curPriceX18,  # 8
    sts,   # 9
    state         # 10
  )
}

# estimatePutOperation
func epo(txId58: String,
                          slippage: Int,
                          inAmAmt: Int,
                          inAmId: ByteVector|Unit,
                          inPrAmt: Int,
                          inPrId: ByteVector|Unit,
                          userAddress: String,
                          isEval: Boolean,
                          emitLp: Boolean,
                          isOneAsset: Boolean,
                          validateSlippage: Boolean,
                          pmtAmt: Int,
                          pmtId: String) = {
    let lpId      = cfgLpAssetId
    let amIdStr   = cfgAmountAssetId.value().toBase58String()
    let prIdStr   = cfgPriceAssetId.value().toBase58String()
    let inAmIdStr = cfgInAmountAssedId
    let inPrIdStr = cfgInPriceAssetId
    let amtDcm    = cfgAmountAssetDecimals
    let priceDcm  = cfgPriceAssetDecimals
    let sts       = cfgPoolStatus.toString()

    let lpEm = assetInfo(lpId).valueOrErrorMessage("Wr lp as").quantity

    # get current balances from acc
    let amBalance = if(isEval) then getAccBalance(amIdStr) else
                                                              if(isOneAsset && pmtId == amIdStr) then getAccBalance(amIdStr) - pmtAmt else
                                                                                            if(isOneAsset) then getAccBalance(amIdStr) else getAccBalance(amIdStr) - inAmAmt
    let prBalance = if(isEval) then getAccBalance(prIdStr) else
                                                              if(isOneAsset && pmtId == prIdStr) then getAccBalance(prIdStr) - pmtAmt  else
                                                                                            if(isOneAsset) then getAccBalance(prIdStr) else getAccBalance(prIdStr) - inPrAmt

    #if(true) then throw("lpEmission = "+ lpEmission.toString() +
    #                    " amBalance = " + amBalance.toString() +
    #                    " prBalance = " + prBalance.toString() +
    #                    " getAccBalance(amIdStr) = " + getAccBalance(amIdStr).toString() +
    #                    " etAccBalance(prIdStr) = " + getAccBalance(prIdStr).toString()) else

    # cast amounts to the lp decimals
    let inAmAssetAmtX18 = inAmAmt.t1(amtDcm)
    let inPrAssetAmtX18 = inPrAmt.t1(priceDcm)

    # calc user expected price
    let userPriceX18 = cpbi(inPrAssetAmtX18, inAmAssetAmtX18)

    # calc pool price
    let amBalanceX18 = amBalance.t1(amtDcm)
    let prBalanceX18 = prBalance.t1(priceDcm)

    let D0 = [amBalanceX18, prBalanceX18].getD()

    # case of the initial or first deposit
    # result is a tuple containing the following:
    # 1. lp amount that user got
    # 2. amtAsset amount that goes to Pool liquidity
    # 3. priceAsset amount that goes to Pool liquidity
    # 4. pool price after PUT operation
    let r = if(lpEm == 0) then {
      let D1 = [amBalanceX18 + inAmAssetAmtX18, prBalanceX18 + inPrAssetAmtX18].getD()

      strict checkD = D1 > D0 || "D1 should be greater than D0".throw()
        let curPriceX18 = zeroBigInt
        let slippageX18 = zeroBigInt
        # calc initial deposit by geometric mean
        # let lpAmtX18 = pow(inAmAssetAmtX18 * inPrAssetAmtX18, 0, 5.toBigInt(), 1, 0, DOWN)
        let lpAmtX18 = D1
        (
          lpAmtX18.f1(scale8),
          inAmAssetAmtX18.f1(amtDcm),
          inPrAssetAmtX18.f1(priceDcm),
          cpbi(prBalanceX18 + inPrAssetAmtX18, amBalanceX18 + inAmAssetAmtX18),
          slippageX18
        )
    } else {
            let curPriceX18 = cpbi(prBalanceX18, amBalanceX18)
            let slippageRealX18 = fraction(abs(curPriceX18 - userPriceX18), scale18, curPriceX18)
            let slippageX18 = slippage.t1(scale8)
            # validate slippage
            if (validateSlippage && curPriceX18 != zeroBigInt && slippageRealX18 > slippageX18) then throw("Price slippage " + slippageRealX18.toString() + " > " + slippageX18.toString()) else

            let lpEmissionX18 = lpEm.t1(scale8)
            # calculate amount of price asset needed to deposit pool by current price and user's amountAsset amount

            let prViaAmX18 = fraction(inAmAssetAmtX18, cpbir(prBalanceX18, amBalanceX18, CEILING), scale18, CEILING)
            let amViaPrX18 = fraction(inPrAssetAmtX18, scale18, cpbir(prBalanceX18, amBalanceX18, FLOOR), CEILING)

            # calculate amount and price assets to perform pool deposit in proportion to current pool price
            let expectedAmts= if (prViaAmX18 > inPrAssetAmtX18)
                    then (amViaPrX18, inPrAssetAmtX18)
                    else (inAmAssetAmtX18, prViaAmX18)

            let expAmtAssetAmtX18   = expectedAmts._1
            let expPriceAssetAmtX18 = expectedAmts._2
            # calculate LP amount that user
            # let lpAmtX18 = fraction(lpEmissionX18, expPriceAssetAmtX18, prBalanceX18, FLOOR)
            let D1 = [amBalanceX18 + expAmtAssetAmtX18, prBalanceX18 + expPriceAssetAmtX18].getD()

            strict checkD = D1 > D0 || "D1 should be greater than D0".throw()
            let lpAmtX18 = fraction(lpEmissionX18, D1 - D0, D0)
            (
              lpAmtX18.fromX18Round(scale8, FLOOR),
              expAmtAssetAmtX18.fromX18Round(amtDcm, CEILING),
              expPriceAssetAmtX18.fromX18Round(priceDcm, CEILING),
              curPriceX18,
              slippageX18
            )
        }

    let calcLpAmt         = r._1
    let calcAmAssetPmt    = r._2
    let calcPrAssetPmt    = r._3
    let curPrice          = r._4.f1(scale8)
    let slippageCalc      = r._5.f1(scale8)

    if(calcLpAmt <= 0) then throw("LP <= 0") else

    let emitLpAmt = if (!emitLp) then 0 else calcLpAmt
    let amDiff = inAmAmt - calcAmAssetPmt
    let prDiff = inPrAmt - calcPrAssetPmt

    let (writeAmAmt, writePrAmt) = if(isOneAsset && pmtId == amIdStr)
                                  then (pmtAmt, 0)
                                        else if(isOneAsset && pmtId == prIdStr)
                                            then (0, pmtAmt)
                                                  else (calcAmAssetPmt, calcPrAssetPmt)

    let commonState = [
      IntegerEntry(pl(), curPrice),
      IntegerEntry(ph(height, lastBlock.timestamp), curPrice),
      StringEntry(
          pau(userAddress, txId58),
          dataPutActionInfo(writeAmAmt, writePrAmt, emitLpAmt, curPrice, slippage, slippageCalc, height, lastBlock.timestamp, amDiff, prDiff))
    ]

    (
      calcLpAmt,                # 1.
      emitLpAmt,                # 2.
      curPrice,                 # 3.
      amBalance,                # 4.
      prBalance,                # 5.
      lpEm,                     # 6.
      lpId,                     # 7.
      sts,               # 8.
      commonState,              # 9.
      amDiff,                   # 10.
      prDiff,                   # 11.
      inAmId,                   # 12
      inPrId                    # 13
    )
}

func getYD(xp: List[BigInt], i: Int, D: BigInt) = {
  let n = big2
  let x = xp[if (i == 0) then 1 else 0]
  let aPrecision = Amult.parseBigIntValue()
  let a = A.parseBigIntValue() * aPrecision
  let s = x
  let ann = a * n
  let c = D * D / (x * n) * D * aPrecision / (ann * n)
  let b = s + D * aPrecision / ann - D
  func calc(acc: (BigInt, Int|Unit), cur: Int) = {
    let (y, found) = acc
    if (found != unit) then acc else {
      let yNext = (y * y + c) / (big2 * y + b)
      let yDiff = absBigInt(yNext - y.value())
      if (yDiff <= big1) then {
        (yNext, cur)
      } else {
        (yNext, unit)
      }
    }
  }
  let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
  let (y, found) = FOLD<15>(arr, (D, unit), calc)
  if (found != unit) then {
    y
  } else {
    { "Y calculation error, Y = " + y.toString() }.throw()
  }
}

func calcDLp(amountBalance: BigInt, priceBalance: BigInt, lpEmission: BigInt) = {
  let updatedDLp = fraction(
    [
      amountBalance.t1BigInt(cfgAmountAssetDecimals.toBigInt()),
      priceBalance.t1BigInt(cfgPriceAssetDecimals.toBigInt())
    ].getD(),
    scale18,
    lpEmission
  )

  if (lpEmission == big0) then big0 else updatedDLp
}

func calcCurrentDLp(amountAssetDelta: BigInt, priceAssetDelta: BigInt, lpAssetEmissionDelta: BigInt) = {
  let amountAssetBalance = cfgAmountAssetId.assetIdToString().getAccBalance().toBigInt() - amountAssetDelta
  let priceAssetBalance = cfgPriceAssetId.assetIdToString().getAccBalance().toBigInt() - priceAssetDelta
  let lpAssetEmission = assetInfo(cfgLpAssetId).value().quantity.toBigInt() - lpAssetEmissionDelta

  let currentDLp = calcDLp(amountAssetBalance, priceAssetBalance, lpAssetEmission)

  currentDLp
}

func refreshDLpInternal(amountAssetBalanceDelta: Int, priceAssetBalanceDelta: Int, lpAssetEmissionDelta: Int) = {
  let amountAssetBalance = cfgAmountAssetId.assetIdToString().getAccBalance() + amountAssetBalanceDelta
  let priceAssetBalance = cfgPriceAssetId.assetIdToString().getAccBalance() + priceAssetBalanceDelta
  # TODO: can be moved outside functions
  let lpAssetEmission = assetInfo(cfgLpAssetId).value().quantity + lpAssetEmissionDelta

  let updatedDLp = calcDLp(amountAssetBalance.toBigInt(), priceAssetBalance.toBigInt(), lpAssetEmission.toBigInt())

  let actions = [
    IntegerEntry(keyDLpRefreshedHeight, height),
    StringEntry(keyDLp, updatedDLp.toString())
  ]

  (actions, updatedDLp)
}

func validateUpdatedDLp(oldDLp: BigInt, updatedDLp: BigInt) = {
  updatedDLp >= oldDLp || "updated DLp lower than current DLp".throwErr()
}

func validateMatcherOrderAllowed(order: Order) = {
  let amountAssetBalance = cfgAmountAssetId.assetIdToString().getAccBalance()
  let priceAssetBalance = cfgPriceAssetId.assetIdToString().getAccBalance()
  let amountAssetAmount = order.amount
  # TODO: check order.priceMode when available
  let priceAssetAmount = fraction(order.amount, order.price, scale8, FLOOR)
  let (amountAssetBalanceDelta, priceAssetBalanceDelta) = if (order.orderType == Buy) then {
    (amountAssetAmount, -priceAssetAmount)
  } else {
    (-amountAssetAmount, priceAssetAmount)
  }

  # validate status
  if (igs() || cfgPoolStatus == PoolMatcherDis || cfgPoolStatus == PoolShutdown) then throw("Admin blocked") else

  # validate pairs
  if (order.assetPair.amountAsset != cfgAmountAssetId || order.assetPair.priceAsset != cfgPriceAssetId) then throw("Wr assets") else

  let dLp = this.getString(keyDLp).valueOrElse("0").parseBigIntValue()
  let (unusedActions, dLpNew) = refreshDLpInternal(amountAssetBalanceDelta, priceAssetBalanceDelta, 0)
  let isOrderValid = dLpNew >= dLp

  let info = [
    "dLp=", dLp.toString(),
    " dLpNew=", dLpNew.toString(),
    " amountAssetBalance=", amountAssetBalance.toString(),
    " priceAssetBalance=", priceAssetBalance.toString(),
    " amountAssetBalanceDelta=", amountAssetBalanceDelta.toString(),
    " priceAssetBalanceDelta=", priceAssetBalanceDelta.toString(),
    " height=", height.toString()
  ].makeString("")

  (isOrderValid, info)
}

# commonGet
func cg(i: Invocation) = {
  if (i.payments.size() != 1) then throw("1 pmnt exp") else

  let pmt         = i.payments[0].value()
  let pmtAssetId  = pmt.assetId.value()
  let pmtAmt      = pmt.amount

  let r = ego(i.transactionId.toBase58String(), pmtAssetId.toBase58String(), pmtAmt, i.caller)
  let outAmAmt    = r._1
  let outPrAmt    = r._2
  let sts  = r._9.parseIntValue()
  let state       = r._10

  if(igs() || sts == PoolShutdown) then throw("Admin blocked: " + sts.toString()) else

  (outAmAmt,
  outPrAmt,
  pmtAmt,
  pmtAssetId,
  state
  )
}

# commonPut
func cp(caller: String,
              txId: String,
              amAsPmt: AttachedPayment,
              prAsPmt: AttachedPayment,
              slippage: Int,
              emitLp: Boolean,
              isOneAsset: Boolean,
              validateSlippage: Boolean,
              pmtAmt: Int,
              pmtId: String) = {

    let r = epo(txId, # i.transactionId.toBase58String()
                      slippage,
                      amAsPmt.value().amount,
                      amAsPmt.value().assetId,
                      prAsPmt.value().amount,
                      prAsPmt.value().assetId,
                      caller,     #i.caller.toString()
                      txId == "",
                      emitLp,
                      isOneAsset,
                      validateSlippage,
                      pmtAmt,
                      pmtId)

    let sts  = r._8.parseIntValue()
    if(igs() || sts == PoolPutDis || sts == PoolShutdown) then throw("Blocked:" + sts.toString()) else
    r
}

func calcPutOneTkn(
  pmtAmtRaw: Int,
  pmtAssetId: String,
  userAddress: String,
  txId: String,
  withTakeFee: Boolean
) = {
  let amId = cfgAmountAssetId.value().toBase58String()
  let prId = cfgPriceAssetId.value().toBase58String()
  let lpId = cfgLpAssetId
  let amtDcm = cfgAmountAssetDecimals
  let priceDcm = cfgPriceAssetDecimals

  let lpAssetEmission = lpId.assetInfo().valueOrErrorMessage("invalid lp asset").quantity.toBigInt()
  strict chechEmission = lpAssetEmission > big0 || "initial deposit requires all coins".throw()

  let amBalance = amId.getAccBalance()
  let prBalance = prId.getAccBalance()

  let (amBalanceOld, prBalanceOld) =
    if (txId == "") then (amBalance, prBalance) else {
      if (pmtAssetId == amId) then {
        if (amBalance < pmtAmtRaw) then "invalid payment amount".throw() else
          (amBalance - pmtAmtRaw, prBalance)
      } else if (pmtAssetId == prId) then {
        if (prBalance < pmtAmtRaw) then "invalid payment amount".throw() else
          (amBalance, prBalance - pmtAmtRaw)
      } else "wrong pmtAssetId".throw()
    }
  
  let (amAmountRaw, prAmountRaw) = if (pmtAssetId == amId) then {
    (pmtAmtRaw, 0)
  } else if (pmtAssetId == prId) then {
    (0, pmtAmtRaw)
  } else "invalid payment".throw()

  let (amAmount, prAmount, feeAmount) = if (withTakeFee) then {
    (
      amAmountRaw.takeFee(inFee)._1,
      prAmountRaw.takeFee(inFee)._1,
      pmtAmtRaw.takeFee(inFee)._2
    )
  } else {
    (
      amAmountRaw,
      prAmountRaw,
      0
    )
  }

  let amBalanceNew = amBalanceOld + amAmount
  let prBalanceNew = prBalanceOld + prAmount

  # check D1 > D0
  let D0 = [amBalanceOld.t1(cfgAmountAssetDecimals), prBalanceOld.t1(cfgPriceAssetDecimals)].getD()
  let D1 = [amBalanceNew.t1(cfgAmountAssetDecimals), prBalanceNew.t1(cfgPriceAssetDecimals)].getD()

  strict checkD = D1 > D0 || throw()

  let lpAmount = lpAssetEmission.fraction(D1 - D0, D0, FLOOR)

  let curPrice = cpbi(prBalanceNew.t1(priceDcm), amBalanceNew.t1(amtDcm)).f1(scale8)

  let commonState = [
    IntegerEntry(pl(), curPrice),
    IntegerEntry(ph(height, lastBlock.timestamp), curPrice),
    StringEntry(
      pau(userAddress, txId),
      dataPutActionInfo(amAmountRaw, prAmountRaw, lpAmount.toInt(), curPrice, 0, 0, height, lastBlock.timestamp, 0, 0)
    )
  ]

  let poolProportion = prBalanceOld.fraction(scale8, amBalanceOld)
  let amountAssetPart = fraction(pmtAmtRaw, scale8, poolProportion + scale8)
  let priceAssetPart = pmtAmtRaw - amountAssetPart
  let lpAmtBoth = fraction(lpAssetEmission, priceAssetPart.toBigInt(), prBalanceOld.toBigInt())
  let bonus = fraction(lpAmount - lpAmtBoth, scale8BigInt, lpAmtBoth).toInt()
  
  (lpAmount.toInt(), commonState, feeAmount, bonus)
}

func getOneTknV2Internal(
  outAssetId: String,
  minOutAmount: Int,
  payments: List[AttachedPayment],
  caller: Address,
  originCaller: Address,
  transactionId: ByteVector
) = {
  let lpId = cfgLpAssetId.value().toBase58String()
  let amId = cfgAmountAssetId.value().toBase58String()
  let prId = cfgPriceAssetId.value().toBase58String()
  let amDecimals = cfgAmountAssetDecimals
  let prDecimals = cfgPriceAssetDecimals
  let poolStatus = cfgPoolStatus

  let userAddress = if (caller == restContract) then originCaller else caller

  let pmt = payments[0].value()
  let pmtAssetId = pmt.assetId.value()
  let pmtAmt = pmt.amount

  strict currentDLp = calcCurrentDLp(big0, big0, big0)

  let txId58 = transactionId.toBase58String()

  if (lpId != pmtAssetId.toBase58String()) then throw("Wrong LP") else

  let amBalance = amId.getAccBalance()
  let prBalance = prId.getAccBalance()

  strict (totalGet, feeAmount) = this.invoke("getOneTknV2READONLY", [outAssetId, pmtAmt], []).exactAs[(Int, Int)]

  let totalAmount = if (minOutAmount > 0 && totalGet < minOutAmount) then {
    ["amount to receive is less than ", minOutAmount.toString()].makeString("").throwErr()
  } else totalGet

  let (outAm, outPr, amBalanceNew, prBalanceNew) = if (outAssetId == amId) then {
    (totalAmount, 0, amBalance - totalAmount - feeAmount, prBalance)
  } else if (outAssetId == prId) then {
    (0, totalAmount, amBalance, prBalance - totalAmount - feeAmount)
  } else {
    "invalid out asset id".throw()
  }

  let curPrX18 = cpbi(prBalanceNew.t1(prDecimals), amBalanceNew.t1(amDecimals))
  let curPr = curPrX18.f1(scale8)

  let outAssetIdOrWaves = if (outAssetId == "WAVES") then unit else outAssetId.fromBase58String()
  let sendFeeToMatcher = if (feeAmount > 0) then [ScriptTransfer(feeCollectorAddress, feeAmount, outAssetIdOrWaves)] else []

  strict state = [
    ScriptTransfer(userAddress, totalAmount, outAssetIdOrWaves),
    StringEntry(
      gau(userAddress.toString(), txId58),
      dataGetActionInfo(outAm, outPr, pmtAmt, curPr, height, lastBlock.timestamp)),
    IntegerEntry(pl(), curPr),
    IntegerEntry(ph(height, lastBlock.timestamp), curPr)
  ] ++ sendFeeToMatcher

  strict burn = invoke(fca,
    "burn",
    [pmtAmt],
    [AttachedPayment(pmtAssetId, pmtAmt)]
  )

  let (amountAssetBalanceDelta, priceAssetBalanceDelta) = {
    let feeAmountForCalc = if (this == feeCollectorAddress) then 0 else feeAmount
    let outInAmountAsset = if (outAssetId.parseAssetId() == cfgAmountAssetId) then true else false
    if (outInAmountAsset) then (-(totalGet + feeAmountForCalc), 0) else (0, -(totalGet + feeAmountForCalc))
  }
  let (refreshDLpActions, updatedDLp) = refreshDLpInternal(amountAssetBalanceDelta, priceAssetBalanceDelta, 0)

  strict isUpdatedDLpValid = validateUpdatedDLp(currentDLp, updatedDLp)

  (state ++ refreshDLpActions, totalAmount)
}

# managerPublicKeyOrUnit
func m() = match mpk().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

# pendingManagerPublicKeyOrUnit
func pm() = match pmpk().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

let pd = "Permission denied".throw()

func isManager(i: Invocation) = {
  match m() {
    case pk: ByteVector => i.callerPublicKey == pk
    case _: Unit => i.caller == this
  }
}

# mustManager
func mm(i: Invocation) = {
  match m() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

func getY(isReverse: Boolean, D: BigInt, poolAmountInBalance: BigInt) = {
  let poolConfig = gpc()
  let amId = poolConfig[idxAmAsId]
  let prId = poolConfig[idxPrAsId]
  let n = big2
  let aPrecision = Amult.parseBigIntValue()
  let a = A.parseBigIntValue() * aPrecision
  let xp = if (isReverse == false) then { 
    [amId.getAccBalance().toBigInt() + poolAmountInBalance, prId.getAccBalance().toBigInt()]
  } else {
    [prId.getAccBalance().toBigInt() + poolAmountInBalance, amId.getAccBalance().toBigInt()]
  }

  let x = xp[0]
  let s = x
  let ann = a * n

  let c = D * D / (x * n) * D * aPrecision / (ann * n)
  let b = s + D * aPrecision / ann - D
  func calc(acc: (BigInt, Int|Unit), cur: Int) = {
      let (y, found) = acc
      if (found != unit) then acc else {
        let yNext = (y * y + c) / (big2 * y + b)
        let yDiff = absBigInt(yNext - y.value())
        if (yDiff <= big1) then {
          (yNext, cur)
        } else {
          (yNext, unit)
        }
      }
    }
    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
    let (y, found) = FOLD<15>(arr, (D, unit), calc)
    if (found != unit) then {
      y
    } else {
      { "Y calculation error, Y = " + y.toString() }.throw()
    }
}

@Callable(i)
func calculateAmountOutForSwapREADONLY(cleanAmountIn: Int, isReverse: Boolean) = {
   let (assetOut, poolAmountInBalance) = if (isReverse == false) then {
    let assetOut = this.strf(pa())
    let poolAmountInBalance = getAccBalance(this.strf(aa())).toBigInt() + cleanAmountIn.toBigInt()
    (assetOut, poolAmountInBalance)
  } else {
    let assetOut = this.strf(aa())
    let poolAmountInBalance = getAccBalance(this.strf(pa())).toBigInt() + cleanAmountIn.toBigInt()
    (assetOut, poolAmountInBalance) 
  }

  let poolConfig = gpc()
  let amId = poolConfig[idxAmAsId]
  let prId = poolConfig[idxPrAsId]
  let xp = [amId.getAccBalance().toBigInt(), prId.getAccBalance().toBigInt()]
  
  let D = xp.getD()
  let y = getY(isReverse, D, cleanAmountIn.toBigInt())

  let dy = getAccBalance(assetOut).toBigInt() - y - toBigInt(1) # -1 just in case there were some rounding errors

  let totalGetRaw = [0, dy.toInt()].max()

  let newXp = if (isReverse == false) then {
    [amId.getAccBalance().toBigInt() + cleanAmountIn.toBigInt(), prId.getAccBalance().toBigInt() - dy]
  } else { 
    [amId.getAccBalance().toBigInt() - dy, prId.getAccBalance().toBigInt() + cleanAmountIn.toBigInt()]
  }
  let newD = newXp.getD()
  strict checkD = newD >= D || makeString(["new D is fewer error", D.toString(), newD.toString()], "__").throw()
  
  (nil, totalGetRaw)
}

@Callable(i)
func calculateAmountOutForSwapAndSendTokens(cleanAmountIn: Int, isReverse: Boolean, amountOutMin: Int, addressTo: String) = {
  let swapContact = invoke(
    fca,
    "getSwapContractREADONLY", 
    [], 
    []
  ).exactAs[String]
  strict checks = [
    i.payments[0].value().amount >= cleanAmountIn || "Wrong amount".throwErr(),
    i.caller == addressFromStringValue(swapContact) || "Permission denied".throwErr()
  ]
  let pmt = i.payments[0].value()
  let assetIn = if(pmt.assetId == unit) then "WAVES".toBytes().toBase58String() else pmt.assetId.value().toBase58String()

  let (assetOut, poolAmountInBalance) = if (isReverse == false) then {
    let assetOut = this.strf(pa())
    let poolAmountInBalance = getAccBalance(assetIn) - i.payments[0].value().amount
    (assetOut, poolAmountInBalance)
  } else {
    let assetOut = this.strf(aa())
    let poolAmountInBalance = getAccBalance(assetIn) - i.payments[0].value().amount
    (assetOut, poolAmountInBalance) 
  }

  let poolConfig = gpc()
  let amId = poolConfig[idxAmAsId]
  let prId = poolConfig[idxPrAsId]
  # let xp = [amId.getAccBalance().toBigInt()  - i.payments[0].value().amount.toBigInt(), prId.getAccBalance().toBigInt()]
  let xp = if (isReverse == false) then {
    [amId.getAccBalance().toBigInt() - i.payments[0].value().amount.toBigInt(), prId.getAccBalance().toBigInt()]
  } else { 
    [amId.getAccBalance().toBigInt(), prId.getAccBalance().toBigInt() - i.payments[0].value().amount.toBigInt()]
  }
  let D = xp.getD()
  let y = getY(isReverse, D, toBigInt(0))

  # let x = poolAmountInBalance.toBigInt() + cleanAmountIn.toBigInt()

  let dy = getAccBalance(assetOut).toBigInt() - y - toBigInt(1) # -1 just in case there were some rounding errors

  let totalGetRaw = [0, dy.toInt()].max()

  strict checkMin = amountOutMin <= totalGetRaw || "Exchange result is fewer coins than expected".throw()

  let newXp = if (isReverse == false) then {
    [amId.getAccBalance().toBigInt(), prId.getAccBalance().toBigInt() - dy]
  } else { 
    [amId.getAccBalance().toBigInt() - dy, prId.getAccBalance().toBigInt()]
  }
  let newD = newXp.getD()
  strict checkD = newD >= D || "new D is fewer error".throw()
  
  # [ScriptTransfer(addressTo.addressFromStringValue(), dy.toInt(), assetOut.fromBase58String())]
  [ScriptTransfer(addressTo.addressFromStringValue(), totalGetRaw, if (assetIn == "WAVES") then unit else assetOut.fromBase58String())]
}

@Callable(i)
# ido, team, emission, staking, locking (boosting), rest
# fc - factoryContract
func constructor(fc: String) = {
  strict c = i.mm()

  [StringEntry(fc(), fc)]
}

@Callable(i)
func setManager(pendingManagerPublicKey: String) = {
  strict c = i.mm()
  strict cm = pendingManagerPublicKey.fromBase58String()

  [StringEntry(pmpk(), pendingManagerPublicKey)]
}

@Callable(i)
func confirmManager() = {
  let p = pm()
  strict hpm = p.isDefined() || throw("No pending manager")
  strict cpm = i.callerPublicKey == p.value() || throw("You are not pending manager")

  [
    StringEntry(mpk(), p.value().toBase58String()),
    DeleteEntry(pmpk())
  ]
}

# called by: LP
#
# purpose:
#    function used for entering the pool
# actions:
#    validate list:
#       1. tokens ratio is in correct range
#       2. slipage is not bigger that current tokens ratio
# arguments:
#    slippageTolerance  max allowed slippage
#    shouldAutoStake    perform LP staking immediatelly in case true otherwise transfer LP to user)
# attach:
#    attached should be two valid tokens from the available pools.
# return:
#    transfer LP tokens based on deposit share
@Callable(i)
func put(slip: Int, autoStake: Boolean) = {
    let factCfg = gfc()
    let stakingCntr = addressFromString(factCfg[idxFactStakCntr]).valueOrErrorMessage("Wr st addr")
    let slipCntr = addressFromString(factCfg[idxFactSlippCntr]).valueOrErrorMessage("Wr sl addr")
    if(slip < 0) then throw("Wrong slippage") else
    if (i.payments.size() != 2) then throw("2 pmnts expd") else

    let amAssetPmt = i.payments[0].value().amount.toBigInt()
    let prAssetPmt = i.payments[1].value().amount.toBigInt()

    strict amountAssetBalance = cfgAmountAssetId.assetIdToString().getAccBalance().toBigInt() - amAssetPmt
    strict priceAssetBalance = cfgPriceAssetId.assetIdToString().getAccBalance().toBigInt() - prAssetPmt
    strict lpAssetEmission = assetInfo(cfgLpAssetId).value().quantity.toBigInt()
    strict currentDLp = calcCurrentDLp(amAssetPmt, prAssetPmt, 0.toBigInt())
    # estPut
    let e = cp(i.caller.toString(),
                          i.transactionId.toBase58String(),
                          AttachedPayment(i.payments[0].value().assetId, i.payments[0].value().amount),
                          i.payments[1],
                          slip,
                          true,
                          false,
                          true,
                          0,
                          "")

    let emitLpAmt = e._2
    let lpAssetId = e._7
    let state     = e._9
    let amDiff    = e._10
    let prDiff    = e._11
    let amId      = e._12
    let prId      = e._13

    # emit lp on factory
    strict r = fca.invoke("emit", [emitLpAmt], [])
    # if the lp instance address is in the legacy list then the legacy factory address will be returned from the factory
    strict el = match (r) {
      case legacy: Address => legacy.invoke("emit", [emitLpAmt], [])
      case _ => unit
    }
    strict sa = if(amDiff > 0)      then slipCntr.invoke("put",[],[AttachedPayment(amId, amDiff)])        else []
    strict sp = if(prDiff > 0)      then slipCntr.invoke("put",[],[AttachedPayment(prId, prDiff)])        else []

    let lpTrnsfr =
      if(autoStake) then strict ss = stakingCntr.invoke("stake",[],[AttachedPayment(lpAssetId, emitLpAmt)]); []
      else [ScriptTransfer(i.caller, emitLpAmt, lpAssetId)]
    
    let (refreshDLpActions, updatedDLp) = refreshDLpInternal(0, 0, 0)

    # strict isUpdatedDLpValid = validateUpdatedDLp(currentDLp, updatedDLp)
    strict check = updatedDLp >= currentDLp || [
      "updated DLp lower than current DLp",
      amountAssetBalance.toString(),
      priceAssetBalance.toString(),
      lpAssetEmission.toString(),
      currentDLp.toString(),
      updatedDLp.toString(),
      amDiff.toString(),
      prDiff.toString()
    ].makeString(" ").throwErr()

    strict lpAssetEmissionAfter = assetInfo(cfgLpAssetId).value().quantity

    state
    ++ lpTrnsfr
    ++ refreshDLpActions
}

@Callable(i)
func putOneTknV2(minOutAmount: Int, autoStake: Boolean) = {
  let isPoolOneTokenOperationsDisabled = fca.invoke(
    "isPoolOneTokenOperationsDisabledREADONLY",
    [this.toString()],
    []
  ).exactAs[Boolean]
  let isPutDisabled = igs() || cfgPoolStatus == PoolPutDis || cfgPoolStatus == PoolShutdown || isPoolOneTokenOperationsDisabled

  strict checks = [
    !isPutDisabled || i.isManager() || "put operation is blocked by admin".throwErr(),
    i.payments.size() == 1 || "exactly 1 payment are expected".throwErr()
  ]

  let amId = cfgAmountAssetId.value().toBase58String()
  let prId = cfgPriceAssetId.value().toBase58String()
  let lpId = cfgLpAssetId
  let amDecimals = cfgAmountAssetDecimals
  let prDecimals = cfgPriceAssetDecimals

  let userAddress = if (i.caller == this) then i.originCaller else i.caller

  let pmt = i.payments[0].value()
  let pmtAssetId = pmt.assetId.value().toBase58String()
  let pmtAmt = pmt.amount

  strict currentDLp = if (pmt.assetId == cfgAmountAssetId) then {
    calcCurrentDLp(pmtAmt.toBigInt(), 0.toBigInt(), 0.toBigInt())
  } else {
    calcCurrentDLp(0.toBigInt(), pmtAmt.toBigInt(), 0.toBigInt())
  }

  strict (estimLP, state, feeAmount) = calcPutOneTkn(
    pmtAmt,
    pmtAssetId,
    userAddress.toString(),
    i.transactionId.toBase58String(),
    true
  )

  let emitLpAmt = if (minOutAmount > 0 && estimLP < minOutAmount) then {
    ["amount to receive is less than ", minOutAmount.toString()].makeString("").throwErr()
  } else estimLP

  # emit lp on factory
  strict e = fca.invoke("emit", [emitLpAmt], [])
  # if the lp instance address is in the legacy list then the legacy factory address will be returned from the factory
  strict el = match (e) {
    case legacy: Address => legacy.invoke("emit", [emitLpAmt], [])
    case _ => unit
  }

  let lpTrnsfr =
    if (autoStake) then strict ss = stakingContract.invoke("stake", [], [AttachedPayment(lpId, emitLpAmt)]); []
    else [ScriptTransfer(i.caller, emitLpAmt, lpId)]

  let sendFeeToMatcher = if (feeAmount > 0) then [ScriptTransfer(feeCollectorAddress, feeAmount, pmtAssetId.fromBase58String())] else []

  let (amountAssetBalanceDelta, priceAssetBalanceDelta) = {
    if (this == feeCollectorAddress) then (0, 0) else {
      # full payment asset id validation is in calcPutOneTkn
      let paymentInAmountAsset = if (pmt.assetId == cfgAmountAssetId) then true else false
      if (paymentInAmountAsset) then (-feeAmount, 0) else (0, -feeAmount)
    }
  }
  let (refreshDLpActions, updatedDLp) = refreshDLpInternal(amountAssetBalanceDelta, priceAssetBalanceDelta, 0)

  strict isUpdatedDLpValid = validateUpdatedDLp(currentDLp, updatedDLp)

  (
    state
    ++ lpTrnsfr
    ++ sendFeeToMatcher
    ++ refreshDLpActions,
    emitLpAmt
  )
}

# Put without LP emission
@Callable(i)
func putForFree(maxSlpg: Int) = {
  if(maxSlpg < 0) then throw("Wrong slpg") else
  if (i.payments.size() != 2) then throw("2 pmnts expd") else
    let estPut = cp(i.caller.toString(),
                          i.transactionId.toBase58String(),
                          AttachedPayment(i.payments[0].value().assetId, i.payments[0].value().amount),
                          i.payments[1],
                          maxSlpg,
                          false,
                          false,
                          true,
                          0,
                          "")

    let state = estPut._9

    let amAssetPmt = i.payments[0].value().amount.toBigInt()
    let prAssetPmt = i.payments[1].value().amount.toBigInt()

    strict currentDLp = calcCurrentDLp(amAssetPmt, prAssetPmt, 0.toBigInt())

    let (refreshDLpActions, updatedDLp) = refreshDLpInternal(0, 0, 0)

    strict isUpdatedDLpValid = validateUpdatedDLp(currentDLp, updatedDLp)

    state ++ refreshDLpActions
}

# Called by: LP
#
# purpose:
#    function used for exit from pool partially or fully
# actions:
# arguments:
# attach:
#    attached should be corresponding pool LP token
# validate list:
# return:
#    transfer to user his share of pool tokens base on passed lp token amount
@Callable(i)
func get() = {
  # amountAssetBalance
  # strict aab = cfgAmountAssetId.assetIdToString().getAccBalance().toBigInt()
  # # priceAssetBalance
  # strict pab = cfgPriceAssetId.assetIdToString().getAccBalance().toBigInt()
  # # lpAssetEmission
  # strict lae = assetInfo(cfgLpAssetId).value().quantity.toBigInt()
  # # lpAssetEmissionAfter
  # strict laea = lae - i.payments[0].value().amount.toBigInt()
  strict currentDLp = calcCurrentDLp(0.toBigInt(), 0.toBigInt(), 0.toBigInt())

  let r = cg(i)
  let outAmtAmt    = r._1
  let outPrAmt     = r._2
  let pmtAmt       = r._3
  let pmtAssetId   = r._4
  let state        = r._5
  strict b = invoke(fca,
                    "burn",
                    [pmtAmt],
                    [AttachedPayment(pmtAssetId, pmtAmt)])

  let (refreshDLpActions, updatedDLp) = refreshDLpInternal(-outAmtAmt, -outPrAmt, 0)

  strict isUpdatedDLpValid = validateUpdatedDLp(currentDLp, updatedDLp)

  state ++ refreshDLpActions
}

@Callable(i)
func getOneTknV2(outAssetId: String, minOutAmount: Int) = {
  let isPoolOneTokenOperationsDisabled = fca.invoke(
    "isPoolOneTokenOperationsDisabledREADONLY",
    [this.toString()],
    []
  ).exactAs[Boolean]
  let isGetDisabled = igs() || cfgPoolStatus == PoolShutdown || isPoolOneTokenOperationsDisabled

  strict checks = [
    !isGetDisabled || i.isManager() || "get operation is blocked by admin".throwErr(),
    i.payments.size() == 1 || "exactly 1 payment are expected".throwErr()
  ]

  let (state, totalAmount) = getOneTknV2Internal(
    outAssetId,
    minOutAmount,
    i.payments,
    i.caller,
    i.originCaller,
    i.transactionId
  )

  (state, totalAmount)
}


@Callable(i)
func refreshDLp() = {
  let lastRefreshedBlockHeight = keyDLpRefreshedHeight.getInteger().valueOrElse(0)
  strict checkLastRefreshedBlockHeight = if (height - lastRefreshedBlockHeight >= dLpRefreshDelay) then unit else {
    [
      dLpRefreshDelay.toString(),
      " blocks have not passed since the previous call"
    ].makeString("").throwErr()
  }

  let dLp = this.getString(keyDLp)
    .valueOrElse("0")
    .parseBigInt()
    .valueOrErrorMessage("invalid dLp".fmtErr())

  let (dLpUpdateActions, updatedDLp) = refreshDLpInternal(0, 0, 0)
  let actions = if (dLp != updatedDLp) then dLpUpdateActions else "nothing to refresh".throwErr()

  (actions, updatedDLp.toString())
}

@Callable(i)
func getOneTknV2READONLY(
  outAssetId: String,
  lpAssetAmount: Int
) = {
  let amId = cfgAmountAssetId.value().toBase58String()
  let prId = cfgPriceAssetId.value().toBase58String()
  let lpId = cfgLpAssetId.value().toBase58String()
  let xp = [amId.getAccBalance().toBigInt(), prId.getAccBalance().toBigInt()]
  # let xp = [prId.getAccBalance().toBigInt(), amId.getAccBalance().toBigInt()]
  let lpEmission = lpId.fromBase58String().assetInfo().valueOrErrorMessage("invalid lp asset").quantity.toBigInt()
  let D0 = xp.getD()
  let D1 = D0 - fraction(lpAssetAmount.toBigInt(), D0, lpEmission)
  let index = if (outAssetId == amId) then {
    0
  } else if (outAssetId == prId) then {
    1
  } else {
    "invalid out asset id".throw()
  }
  let newY = xp.getYD(index, D1)
  let dy = xp[index] - newY
  let totalGetRaw = [0, { dy - big1 }.toInt()].max()
  let (totalGet, feeAmount) = totalGetRaw.takeFee(outFee)

  (nil, (totalGet, feeAmount))
}

@Callable(i)
func getOneTknV2WithBonusREADONLY(
  outAssetId: String,
  lpAssetAmount: Int
) = {
  let amId = cfgAmountAssetId.value().toBase58String()
  let prId = cfgPriceAssetId.value().toBase58String()
  let lpId = cfgLpAssetId.value().toBase58String()

  let amBalance = amId.getAccBalance()
  let prBalance = prId.getAccBalance()

  let (totalGet, feeAmount) = this.invoke("getOneTknV2READONLY", [outAssetId, lpAssetAmount], []).exactAs[(Int, Int)]

  let r = ego(
    "",
    lpId,
    lpAssetAmount,
    this
  )

  let outAmAmt = r._1
  let outPrAmt = r._2
  let sumOfGetAssets = outAmAmt + outPrAmt
  
  let bonus = if (sumOfGetAssets == 0) then {
    if (totalGet == 0) then 0 else "bonus calculation error".throw()
  } else {
    fraction((totalGet - sumOfGetAssets), scale8, sumOfGetAssets)
  }

  ([], (totalGet, feeAmount, bonus))
}

@Callable(i)
func getNoLess(noLessThenAmtAsset: Int, noLessThenPriceAsset: Int) = {
  let r = cg(i)
  let outAmAmt    = r._1
  let outPrAmt    = r._2
  let pmtAmt      = r._3
  let pmtAssetId  = r._4
  let state       = r._5
  if (outAmAmt < noLessThenAmtAsset) then throw("Failed:  " + outAmAmt.toString() + " < " + noLessThenAmtAsset.toString()) else
  if (outPrAmt < noLessThenPriceAsset) then throw("Failed: " + outPrAmt.toString() + " < " + noLessThenPriceAsset.toString()) else

  strict currentDLp = calcCurrentDLp(0.toBigInt(), 0.toBigInt(), 0.toBigInt())

  strict burnLPAssetOnFactory = invoke(fca,
                                  "burn",
                                  [pmtAmt],
                                  [AttachedPayment(pmtAssetId, pmtAmt)])

  let (refreshDLpActions, updatedDLp) = refreshDLpInternal(-outAmAmt, -outPrAmt, 0)

  strict isUpdatedDLpValid = validateUpdatedDLp(currentDLp, updatedDLp)

  state ++ refreshDLpActions
}

# Unstake LP tokens and exit from pool
@Callable(i)
func unstakeAndGet(amount: Int) = {
  strict checkPayments = if (i.payments.size() != 0) then throw("No pmnts expd") else true

  let factoryCfg = gfc()

  let lpAssetId = cfgLpAssetId
  let staking = factoryCfg[idxFactStakCntr].addressFromString().valueOrErrorMessage("Wr st addr")

  strict currentDLp = calcCurrentDLp(0.toBigInt(), 0.toBigInt(), 0.toBigInt())

  # negative amount will not pass
  strict unstakeInv = staking.invoke("unstake", [lpAssetId.toBase58String(), amount], [])

  let r = ego(i.transactionId.toBase58String(), lpAssetId.toBase58String(), amount, i.caller)
  let outAmAmt = r._1
  let outPrAmt = r._2
  let sts = r._9.parseIntValue()
  let state = r._10

  strict v = if (igs() || sts == PoolShutdown) then throw("Blocked: " + sts.toString()) else true

  strict burnA = invoke(fca, "burn", [amount], [AttachedPayment(lpAssetId, amount)])

  let (refreshDLpActions, updatedDLp) = refreshDLpInternal(-outAmAmt, -outPrAmt, 0)

  strict isUpdatedDLpValid = validateUpdatedDLp(currentDLp, updatedDLp)

  state ++ refreshDLpActions
}

@Callable(i)
func unstakeAndGetNoLess(unstakeAmount: Int, noLessThenAmountAsset: Int, noLessThenPriceAsset: Int) = {
  let isGetDisabled = igs() || cfgPoolStatus == PoolShutdown

  strict checks = [
    !isGetDisabled || "get operation is blocked by admin".throw(),
    i.payments.size() == 0 || "no payments are expected".throw()
  ]

  strict currentDLp = calcCurrentDLp(0.toBigInt(), 0.toBigInt(), 0.toBigInt())

  strict unstakeInv = stakingContract.invoke("unstake", [cfgLpAssetId.toBase58String(), unstakeAmount], [])

  let res = ego(i.transactionId.toBase58String(), cfgLpAssetId.toBase58String(), unstakeAmount, i.caller)
  let outAmAmt = res._1
  let outPrAmt = res._2
  let state = res._10

  strict checkAmounts = [
    outAmAmt >= noLessThenAmountAsset || ["amount asset amount to receive is less than ", noLessThenAmountAsset.toString()].makeString("").throw(),
    outPrAmt >= noLessThenPriceAsset || ["price asset amount to receive is less than ", noLessThenPriceAsset.toString()].makeString("").throw()
  ]

  strict burnLPAssetOnFactory = fca.invoke("burn", [unstakeAmount], [AttachedPayment(cfgLpAssetId, unstakeAmount)])

  let (refreshDLpActions, updatedDLp) = refreshDLpInternal(-outAmAmt, -outPrAmt, 0)

  strict isUpdatedDLpValid = validateUpdatedDLp(currentDLp, updatedDLp)

  state ++ refreshDLpActions
}

@Callable(i)
func unstakeAndGetOneTknV2(unstakeAmount: Int, outAssetId: String, minOutAmount: Int) = {
  let isPoolOneTokenOperationsDisabled = fca.invoke(
    "isPoolOneTokenOperationsDisabledREADONLY",
    [this.toString()],
    []
  ).exactAs[Boolean]
  let isGetDisabled = igs() || cfgPoolStatus == PoolShutdown || isPoolOneTokenOperationsDisabled

  strict checks = [
    !isGetDisabled || i.isManager() || "get operation is blocked by admin".throwErr(),
    i.payments.size() == 0 || "no payments are expected".throwErr()
  ]

  let factoryCfg = gfc()

  let lpAssetId = cfgLpAssetId
  let staking = factoryCfg[idxFactStakCntr].addressFromString().valueOrErrorMessage("Wr st addr")

  strict unstakeInv = staking.invoke("unstake", [lpAssetId.toBase58String(), unstakeAmount], [])
  let (state, totalAmount) = getOneTknV2Internal(
    outAssetId,
    minOutAmount,
    [AttachedPayment(lpAssetId, unstakeAmount)],
    i.caller,
    i.originCaller,
    i.transactionId
  )

  (state, totalAmount)
}

@Callable(i)
func putOneTknV2WithBonusREADONLY(paymentAmountRaw: Int, paymentAssetId: String) = {
  let (lpAmount, state, feeAmount, bonus) = calcPutOneTkn(paymentAmountRaw, paymentAssetId, "", "", true)

  (nil, (lpAmount, feeAmount, bonus))
}

@Callable(i)
func putOneTknV2WithoutTakeFeeREADONLY(paymentAmountRaw: Int, paymentAssetId: String) = {
  let (lpAmount, state, feeAmount, bonus) = calcPutOneTkn(paymentAmountRaw, paymentAssetId, "", "", false)

  (nil, (lpAmount, feeAmount, bonus))
}

# purpose:
#    used BY FACTORY for activating new LP pool. Validate it was called only once.
# actions:
#    1. issue new LP token and save data in state
#    2. burn LP token
#    3. write initial price, that is used for first deposit
# arguments:
# attach:
# return:
@Callable(i)
func activate(amtAsStr: String, prAsStr: String) = {
    if (i.caller.toString() != fca.toString()) then throw("denied") else {
        ([
            StringEntry(aa(),amtAsStr),
            StringEntry(pa(),prAsStr)
            ],
        "success")
    }
}

# Set string from addon
@Callable(i)
func setS(k: String, v: String) = {
  if (i.caller.toString() != this.strf(ada())) then pd else

  [
    StringEntry(k, v)
  ]
}

# Set integer from addon
@Callable(i)
func setI(k: String, v: Int) = {
  if (i.caller.toString() != this.strf(ada())) then pd else

  [
    IntegerEntry(k, v)
  ]
}

# API wrappers
@Callable(i)
func getPoolConfigWrapperREADONLY() = {
  (
    [],
    gpc()
  )
}

@Callable(i)
func getAccBalanceWrapperREADONLY(assetId: String) = {
  (
    [],
    assetId.getAccBalance()
  )
}

@Callable(i)
func calcPricesWrapperREADONLY(amAmt: Int, prAmt: Int, lpAmt: Int) = {
  let pr = calcPrices(amAmt, prAmt, lpAmt)
  (
    [],
    [
      pr[0].toString(),
      pr[1].toString(),
      pr[2].toString()
    ]
  )
}

@Callable(i)
func fromX18WrapperREADONLY(val: String, resScaleMult: Int) = {
  (
    [],
    f1(val.parseBigIntValue(), resScaleMult)
  )
}

@Callable(i)
func toX18WrapperREADONLY(origVal: Int, origScaleMult: Int) = {
  (
    [],
    t1(origVal, origScaleMult).toString()
  )
}

@Callable(i)
func calcPriceBigIntWrapperREADONLY(prAmtX18: String, amAmtX18: String) = {
  (
    [],
    cpbi(prAmtX18.parseBigIntValue(), amAmtX18.parseBigIntValue()).toString()
  )
}

@Callable(i)
func estimatePutOperationWrapperREADONLY(
  txId58: String,
  slippage: Int,
  inAmAmt: Int,
  inAmId: ByteVector,
  inPrAmt: Int,
  inPrId: ByteVector,
  usrAddr: String,
  isEval: Boolean,
  emitLp: Boolean
) = {
  (
    [],
    epo(
      txId58,
      slippage,
      inAmAmt,
      inAmId,
      inPrAmt,
      inPrId,
      usrAddr,
      isEval,
      emitLp,
      true,
      false,
      0,
      ""
    )
  )
}

@Callable(i)
func estimateGetOperationWrapperREADONLY(txId58: String, pmtAsId: String, pmtLpAmt: Int, usrAddr: String) = {
  let r = ego(
    txId58,
    pmtAsId,
    pmtLpAmt,
    usrAddr.addressFromStringValue()
  )
  (
    [],
    (r._1, r._2, r._3, r._4, r._5, r._6, r._7, r._8.toString(), r._9, r._10)
  )
}

@Verifier(tx)
func verify() = {
  let targetPublicKey = match m() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }

  match tx {
    case order: Order =>
      let matcherPub    = mp()
      let (orderValid, orderValidInfo) = validateMatcherOrderAllowed(order)
      let senderValid   = sigVerify(order.bodyBytes, order.proofs[0], order.senderPublicKey)
      let matcherValid  = sigVerify(order.bodyBytes, order.proofs[1], matcherPub)

      (orderValid && senderValid && matcherValid) || throwOrderError(orderValid, orderValidInfo, senderValid, matcherValid)
    case s: SetScriptTransaction =>
      if sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey) then {
        true
      } else {
        let newHash = s.script.value().blake2b256()
        let allowedHash = fca.getString(keyAllowedLpStableScriptHash()).value().fromBase64String()
        let currentHash = this.scriptHash()

        allowedHash == newHash && currentHash != newHash
      }
    case _ => {
      sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
    }
  }
}
