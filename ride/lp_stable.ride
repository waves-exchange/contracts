{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# TODO:
#
#  add callable to remove existing pool
#  add restriction on min deposit amount
#  AMU: move "WAVES" into spec variable
#  AMU: add safe cast method instead of copy/past: inAmAssetId.valueOrElse("WAVES".fromBase58String()).toBase58String()

# Description:
#   Contract represents single liquidity pool for specific asset pair, e.g. BTC-USDN
#
#   Actors:
#      1. LP
#      2. Factory
#      3. Matcher
#
#   Actor LP could do do the following:
#      1. Enter the pool
#      2. Exit the pool
#
#   Factory LP could do do the following:
#      1. Activate the pool
#      2. Halt pool operations partially of completelly
#
#   Matcher LP could do do the following:
#      1. Perform exchange operations with pool assets
#
#   New Pool deployment flow:
#      0. Factory contract has BLAKE2b-256 hash of the Pool contract.
#      1. Pool contract is deployed to the blockchain (factory address is injected into it)
#      2. Factory calls 'activate' callable and activate pool in case all prerequisites passed (assset pairs are not registered, contract hash matches actual)

#-----------------
# GLOBAL VARIABLES
#-----------------
let scale8 = 100_000_000
let scale8BigInt = 100_000_000.toBigInt()
let scale18 = 1_000_000_000_000_000_000.toBigInt()
let zeroBigInt = 0.toBigInt()
let oneBigInt = 1.toBigInt()
let slippage4D = (scale8 - scale8 * 1 / scale8).toBigInt() # 9999999 or error of 0.0000001

let Amult = "100"
let Dconv = "1" # D convergence

let SEP = "__"
let EMPTY = ""
let PoolActive               = 1   # ACTIVE, pool without restrictions
let PoolPutDis               = 2   # PUT DISABLED, pool with put operation disabled
let PoolMatcherDis           = 3   # MATCHER DISABLED, pool with matcher operations disabled
let PoolShutdown             = 4   # SHUTDOWN, pool operations halted
# data indexes from pool config stored in factory
let idxPoolAddress  = 1
let idxPoolSt       = 2
let idxLPAsId       = 3
let idxAmAsId       = 4
let idxPrAsId       = 5
let idxAmtAsDcm     = 6
let idxPriceAsDcm   = 7
let idxIAmtAsId     = 8
let idxIPriceAsId   = 9
# data indexes from factory config
let idxFactStakCntr      = 1
let idxFactSlippCntr     = 7
let idxFactGwxRewCntr    = 10

let delay = "%s__delay"
let feePermilleDefault = 10
#-------------------------
# WX COMMON LIBRARY
#-------------------------
func toX18(origVal: Int, origScaleMult: Int)    = fraction(origVal.toBigInt(), scale18, origScaleMult.toBigInt())
func fromX18(val: BigInt, resultScaleMult: Int) = fraction(val, resultScaleMult.toBigInt(), scale18).toInt()

# cast passed amount to specified 'resScale' scale value from 'curScale' scale value
func ts(amt: Int, resScale: Int, curScale: Int) = fraction(amt, resScale, curScale)

func abs(val: BigInt) = if (val < zeroBigInt) then -val else val

#-------------------------
# KEYS ON CURRENT CONTRACT
#-------------------------
func keyFactoryContact() = {"%s__factoryContract"}
func keyManagerPublicKey() = {"%s__managerPublicKey"}
func keyPendingManagerPublicKey() = {"%s__pendingManagerPublicKey"}
func keyPriceLast() = {"%s%s__price__last"}
func keyPriceHistory(h: Int, t: Int) = {makeString(["%s%s%d%d__price__history", h.toString(), t.toString()], SEP)}
func keyPutActionByUser(ua: String, txId: String) = "%s%s%s__P__" + ua + "__" + txId
func keyGetActionByUser(ua: String, txId: String) = "%s%s%s__G__" + ua + "__" + txId
func keyAmountAsset() = {"%s__amountAsset"}
func keyPriceAsset() = {"%s__priceAsset"}
func keyAmplificator() = {"%s__amp"}
func keyAddonAddress() = "%s__addonAddr"
let keyFeePermille = "%s__feePermille"

let feePermille = this.getInteger(keyFeePermille).valueOrElse(feePermilleDefault)

#------------------------
# KEYS ON OTHER CONTRACTS
#------------------------
# from factory
# keyFactoryConfig
func fcfg() = {"%s__factoryConfig"}
# keyMatcherPub
func mtpk() = "%s%s__matcher__publicKey"
# keyPoolConfig
func pc(iAmtAs: String, iPrAs: String) = {"%d%d%s__" + iAmtAs + "__" + iPrAs + "__config"}
# keyMappingsBaseAsset2internalId
func mba(bAStr: String) = {"%s%s%s__mappings__baseAsset2internalId__" + bAStr}
# keyAllPoolsShutdown
func aps() = {"%s__shutdown"}

#------------------------
# FAILURES
#------------------------
func throwErr(msg: String) = ["lp_stable.ride:", msg].makeString(" ").throw()
# func valueOrErr(
#   valueFrom: String|Int|Unit,
#   msg: String
# ) = valueFrom.valueOrErrorMessage(["lp_stable.ride:", msg].makeString(" ").throw())
func throwOrderError(orV: Boolean, sendrV: Boolean, matchV: Boolean) = {
  throwErr("Failed: ordValid=" + orV.toString() + " sndrValid=" + sendrV.toString() + " mtchrValid=" + matchV.toString())
}

#------------------------
# GLOBAL FUNCTIONS
#------------------------

func str(val: Any) = {
  match val {
    case valStr: String => valStr
    case _ => throwErr("fail cast to String")
  }
}

func getStringOrFail(
  addr: Address,
  key: String
) = addr.getString(key).valueOrErrorMessage(makeString(["mandatory ", addr.toString(), ".", key, " not defined"], ""))
func getIntOrFail(
  addr: Address,
  key: String
) = addr.getInteger(key).valueOrErrorMessage(makeString(["mandatory ", addr.toString(), ".", key, " not defined"], ""))

let factoryContract = addressFromStringValue(getStringOrFail(this, keyFactoryContact()))

let amplificator = getStringOrFail(this, keyAmplificator())

# check that global shutdown is take place
func isGlobalShutdown() = {
  factoryContract.getBoolean(aps()).valueOrElse(false)
}
func getMatcherPubOrFail() = {
  factoryContract.getStringOrFail(mtpk()).fromBase58String()
}
# function used to gather all pool data from factory
func getPoolConfig() = {
  let amtAs = getStringOrFail(this, keyAmountAsset())
  let priceAs = getStringOrFail(this, keyPriceAsset())
  let iPriceAs = getIntOrFail(factoryContract, mba(priceAs))
  let iAmtAs = getIntOrFail(factoryContract, mba(amtAs))
  getStringOrFail(factoryContract, pc(iAmtAs.toString(), iPriceAs.toString())).split(SEP)
}

func getFactoryConfig() = {
  getStringOrFail(factoryContract, fcfg()).split(SEP)
}

func dataPutActionInfo(inAmtAssetAmt: Int, inPriceAssetAmt: Int, outLpAmt: Int, price: Int, slipByUser: Int, slippageReal: Int, txHeight: Int, txTimestamp: Int, slipageAmAmt: Int, slipagePrAmt: Int) = {
  makeString(["%d%d%d%d%d%d%d%d%d%d", inAmtAssetAmt.toString(), inPriceAssetAmt.toString(), outLpAmt.toString(), price.toString(), slipByUser.toString(), slippageReal.toString(), txHeight.toString(), txTimestamp.toString(), slipageAmAmt.toString(), slipagePrAmt.toString()], SEP)
}

func dataGetActionInfo(outAmtAssetAmt: Int, outPriceAssetAmt: Int, inLpAmt: Int, price: Int, txHeight: Int, txTimestamp: Int) = {
  makeString( ["%d%d%d%d%d%d", outAmtAssetAmt.toString(), outPriceAssetAmt.toString(), inLpAmt.toString(), price.toString(), txHeight.toString(), txTimestamp.toString()], SEP)
}

func getAccBalance(assetId: String) = {
  if(assetId == "WAVES") then wavesBalance(this).available else assetBalance(this, fromBase58String(assetId))
}

func calcPriceBigInt(prAmtX18: BigInt, amAmtX18: BigInt) = {
  fraction(prAmtX18, scale18, amAmtX18)
}

func validateAbsDiff(estimateLP: BigInt, outLp: BigInt, slippage: BigInt) = {
  let diff = fraction(estimateLP - outLp, scale8BigInt, outLp)
  let pass = (slippage - abs(diff)) > zeroBigInt
  if (!pass) then throwErr("Big slippage: " + diff.toString()) else
  (pass, min([estimateLP, outLp]))
}

func validateD(D1: BigInt, D0: BigInt, slippage: BigInt) = {
  let diff = fraction(D0, scale8BigInt, D1)
  let fail = diff < slippage
  if (fail || D1 < D0) then throwErr(D0.toString() + " " + D1.toString() + " " + diff.toString() + " " + slippage.toString()) else
  fail
}

# cast assets and calc price
func privateCalcPrice(amAssetDcm: Int, prAssetDcm: Int, amAmt: Int, prAmt: Int) = {
    let amtAsAmtX18 = amAmt.toX18(amAssetDcm)
    let prAsAmtX18 = prAmt.toX18(prAssetDcm)
    calcPriceBigInt(prAsAmtX18, amtAsAmtX18)
}

# used only in stats endpoint, so result values are in scale8 as required
func calcPrices(amAmt: Int, prAmt: Int, lpAmt: Int) = {
  let cfg = getPoolConfig()
  let amtAsDcm = cfg[idxAmtAsDcm].parseIntValue()
  let prAsDcm = cfg[idxPriceAsDcm].parseIntValue()

  let priceX18 = privateCalcPrice(amtAsDcm, prAsDcm, amAmt, prAmt)

  let amAmtX18 = amAmt.toX18(amtAsDcm)
  let prAmtX18 = prAmt.toX18(prAsDcm)
  let lpAmtX18 = lpAmt.toX18(scale8)

  let lpPrInAmAsX18 = calcPriceBigInt(amAmtX18, lpAmtX18)
  let lpPrInPrAsX18 = calcPriceBigInt(prAmtX18, lpAmtX18)

  [priceX18, lpPrInAmAsX18, lpPrInPrAsX18]
}

# public API which is used by backend
func calculatePrices(amAmt: Int, prAmt: Int, lpAmt: Int) = {
  let p = calcPrices(amAmt, prAmt, lpAmt)
  [
    p[0].fromX18(scale8),
    p[1].fromX18(scale8),
    p[2].fromX18(scale8)
  ]
}

func estimateGetOperation(txId58: String, paymentAssetId: String, paymentLpAmount: Int, userAddress: Address) = {
  # data from pool config
  let cfg             = getPoolConfig()
  let lpAssetId       = cfg[idxLPAsId]
  let amountId        = cfg[idxAmAsId]
  let priceId         = cfg[idxPrAsId]
  let amountDecimals  = cfg[idxAmtAsDcm].parseIntValue()
  let priceDecimals   = cfg[idxPriceAsDcm].parseIntValue()
  let sts             = cfg[idxPoolSt]

  let lpEmission = assetInfo(lpAssetId.fromBase58String()).valueOrErrorMessage("Wrong LP id").quantity

  strict validationBlock = lpAssetId == paymentAssetId || throwErr("Wrong payment asset")

  strict decimals = if amountDecimals >= priceDecimals then {
    amountDecimals
  } else {
    priceDecimals
  }

  let amountBalance     = getAccBalance(amountId)
  let amountBalanceX18  = amountBalance.toX18(decimals)
  let priceBalance      = getAccBalance(priceId)
  let priceBalanceX18   = priceBalance.toX18(decimals)

  let currentPriceX18 = calcPriceBigInt(priceBalanceX18, amountBalanceX18)
  let curPrice = currentPriceX18.fromX18(scale8)
  
  let paymentLpAmountX18 = paymentLpAmount.toX18(scale8)
  let lpEmissionX18 = lpEmission.toX18(scale8)

  # calculations
  let outAmountAmountX18 = fraction(amountBalanceX18, paymentLpAmountX18, lpEmissionX18)
  let outPriceAmountX18 = fraction(priceBalanceX18, paymentLpAmountX18, lpEmissionX18)

  # cast amounts to asset decimals
  let outAmountAmount = outAmountAmountX18.fromX18(decimals)
  let outPriceAmount = outPriceAmountX18.fromX18(decimals)

  let state = if (txId58 == "") then [] else
  [
    ScriptTransfer(userAddress, outAmountAmount, if (amountId == "WAVES") then unit else amountId.fromBase58String()),
    ScriptTransfer(userAddress, outPriceAmount, if (priceId == "WAVES") then unit else priceId.fromBase58String()),
    StringEntry(
      keyGetActionByUser(userAddress.toString(), txId58),
      dataGetActionInfo(outAmountAmount, outPriceAmount, paymentLpAmount, curPrice, height, lastBlock.timestamp)
    ),
    IntegerEntry(keyPriceLast(), curPrice),
    IntegerEntry(keyPriceHistory(height, lastBlock.timestamp), curPrice)
  ]

  (
    outAmountAmount,  # 1
    outPriceAmount,   # 2
    amountId,         # 3
    priceId,          # 4
    amountBalance,    # 5
    priceBalance,     # 6
    lpEmission,       # 7
    currentPriceX18,  # 8
    sts,              # 9
    state             # 10
  )
}

func estimatePutOperation(
  txId58: String,
  slippageTolerance: Int,
  inAmountAssetAmount: Int,
  inAmountAssetId: ByteVector|Unit,
  inPriceAssetAmount: Int,
  inPriceAssetId: ByteVector|Unit,
  userAddress: String,
  isEvaluate: Boolean,
  emitLp: Boolean,
  isOneAsset: Boolean,
  paymentAmount: Int,
  paymentId: String
) = {
    # data from pool config
    let cfg             = getPoolConfig()
    let lpAssetId       = cfg[idxLPAsId].fromBase58String()
    let amountIdStr     = cfg[idxAmAsId]
    let priceIdStr      = cfg[idxPrAsId]
    let inAmountIdStr   = cfg[idxIAmtAsId]
    let inPriceIdStr    = cfg[idxIPriceAsId]
    let amountDecimals  = cfg[idxAmtAsDcm].parseIntValue()
    let priceDecimals   = cfg[idxPriceAsDcm].parseIntValue()
    let sts             = cfg[idxPoolSt]

    let lpEmission = assetInfo(lpAssetId).valueOrErrorMessage("Wrong lp asset").quantity

    # get current balances from account
    let amountBalance = if(isEvaluate) then getAccBalance(amountIdStr) else
      if(isOneAsset && paymentId == amountIdStr) then getAccBalance(amountIdStr) - paymentAmount else
      if(isOneAsset) then getAccBalance(amountIdStr) else getAccBalance(amountIdStr) - inAmountAssetAmount

    # calc pool price
    let priceBalance = if(isEvaluate) then getAccBalance(priceIdStr) else
      if(isOneAsset && paymentId == priceIdStr) then getAccBalance(priceIdStr) - paymentAmount else
      if(isOneAsset) then getAccBalance(priceIdStr) else getAccBalance(priceIdStr) - inPriceAssetAmount

    strict decimals = if amountDecimals >= priceDecimals then {
      amountDecimals
    } else {
      priceDecimals
    }

    # cast amounts to the lp decimals
    let inAmountAssetAmountX18 = inAmountAssetAmount.toX18(decimals)
    let inPriceAssetAmountX18 = inPriceAssetAmount.toX18(decimals)

    # calc user expected price
    let userPriceX18 = calcPriceBigInt(inPriceAssetAmountX18, inAmountAssetAmountX18)

    let amountBalanceX18 = amountBalance.toX18(decimals)
    let priceBalanceX18 = priceBalance.toX18(decimals)

    # case of the initial or first deposit
    # result is a tuple containing the following:
    # 1. lp amount that user got
    # 2. amtAsset amount that goes to Pool liquidity
    # 3. priceAsset amount that goes to Pool liquidity
    # 4. pool price after PUT operation
    let r = if(lpEmission == 0) then {
      let currentPriceX18 = zeroBigInt
      let slippageX18 = zeroBigInt
      # calc initial deposit by geometric mean
      let lpAmountX18 = pow(inAmountAssetAmountX18 * inPriceAssetAmountX18, 0, 5.toBigInt(), 1, 0, DOWN)
      (
        lpAmountX18.fromX18(scale8),
        inAmountAssetAmountX18.fromX18(decimals),
        inPriceAssetAmountX18.fromX18(decimals),
        calcPriceBigInt(priceBalanceX18 + inPriceAssetAmountX18, amountBalanceX18 + inAmountAssetAmountX18),
        slippageX18
      )
    } else {
      let currentPriceX18 = calcPriceBigInt(priceBalanceX18, amountBalanceX18)
      let slippageRealX18 = fraction(abs(currentPriceX18 - userPriceX18), scale18, currentPriceX18)
      let slippageX18 = slippageTolerance.toX18(scale8)

      strict validateSlippage = (currentPriceX18 != zeroBigInt && slippageRealX18 > slippageX18) == true ||
        throwErr("Price slippage " + slippageRealX18.toString() + " > " + slippageX18.toString())

      let lpEmissionX18 = lpEmission.toX18(scale8)
      # calculate amount of price asset needed to deposit pool by current price and user's amountAsset amount
      let prViaAmX18 = fraction(inAmountAssetAmountX18, currentPriceX18, scale18)
      let amViaPrX18 = fraction(inPriceAssetAmountX18, scale18, currentPriceX18)

      # calculate amount and price assets to perform pool deposit in proportion to current pool price
      let expectedAmounts = if (prViaAmX18 > inPriceAssetAmountX18)
        then (amViaPrX18, inAmountAssetAmountX18)
        else (inAmountAssetAmountX18, prViaAmX18)

      let expectedAmountAssetAmountX18 = expectedAmounts._1
      let expectedPriceAssetAmountX18  = expectedAmounts._2
      # calculate LP amount that user
      let lpAmountX18 = fraction(lpEmissionX18, expectedPriceAssetAmountX18, priceBalanceX18)
      (
        lpAmountX18.fromX18(scale8),
        expectedAmountAssetAmountX18.fromX18(decimals),
        expectedPriceAssetAmountX18.fromX18(decimals),
        currentPriceX18,
        slippageX18
      )
    }

    let calculateLpAmount           = r._1
    let calculateAmountAssetPayment = r._2
    let calculatePriceAssetPayment  = r._3
    let currentPrice                = r._4.fromX18(scale8)
    let slippageCalculate           = r._5.fromX18(scale8)

    strict checkCalcLpAmount = calculateLpAmount > 0 || throwErr("LP <= 0")

    let emitLpAmount = if (!emitLp) then 0 else calculateLpAmount
    let amountDiff = inAmountAssetAmount - calculateAmountAssetPayment
    let priceDiff = inPriceAssetAmount - calculatePriceAssetPayment

    let (writeAmAmt, writePrAmt) = if(isOneAsset && paymentId == amountIdStr)
      then (paymentAmount, 0)
      else if(isOneAsset && paymentId == priceIdStr)
        then (0, paymentAmount)
        else (calculateAmountAssetPayment, calculatePriceAssetPayment)

    let commonState = [
      IntegerEntry(keyPriceLast(), currentPrice),
      IntegerEntry(keyPriceHistory(height, lastBlock.timestamp), currentPrice),
      StringEntry(
        keyPutActionByUser(userAddress, txId58),
        dataPutActionInfo(
          writeAmAmt,
          writePrAmt,
          emitLpAmount,
          currentPrice,
          slippageTolerance,
          slippageCalculate,
          height,
          lastBlock.timestamp,
          amountDiff,
          priceDiff
        )
      )
    ]

    (
      calculateLpAmount,  # 1.
      emitLpAmount,       # 2.
      currentPrice,       # 3.
      amountBalance,      # 4.
      priceBalance,       # 5.
      lpEmission,         # 6.
      lpAssetId,          # 7.
      sts,                # 8.
      commonState,        # 9.
      amountDiff,         # 10.
      priceDiff,          # 11.
      inAmountAssetId,    # 12.
      inPriceAssetId      # 13.
    )
}

func validateMatcherOrderAllowed(order: Order) = {
  let cfg = getPoolConfig()
  let amtAsId = cfg[idxAmAsId]
  let prAsId = cfg[idxPrAsId]
  let sts = cfg[idxPoolSt].parseIntValue()
  let amtAsDcm = cfg[idxAmtAsDcm].parseIntValue()
  let prAsDcm = cfg[idxPriceAsDcm].parseIntValue()

  # get current balances from acc
  let accAmtAsBalance = getAccBalance(amtAsId)
  let accPrAsBalance = getAccBalance(prAsId)

  let currentPriceX18 = if(order.orderType == Buy)
    then privateCalcPrice(amtAsDcm, prAsDcm, accAmtAsBalance + order.amount, accPrAsBalance)
    else privateCalcPrice(amtAsDcm, prAsDcm, accAmtAsBalance - order.amount, accPrAsBalance)
  let curPrice = currentPriceX18.fromX18(scale8)

  # validate status
  if (isGlobalShutdown() || sts == PoolMatcherDis || sts == PoolShutdown) then throwErr("Admin blocked") else

  # validate pairs
  let orAmtAsset = order.assetPair.amountAsset
  let orAmtAsStr = if( orAmtAsset == unit) then "WAVES" else toBase58String(orAmtAsset.value())
  let orPrAsset = order.assetPair.priceAsset
  let orPrAsStr = if( orPrAsset == unit) then "WAVES" else toBase58String(orPrAsset.value())
  if(orAmtAsStr != amtAsId ||  orPrAsStr != prAsId) then throwErr("Wr assets") else

  let orderPrice = order.price
  #priceDecimals = 8 + priceAssetDcm - amtAssetDcm
  let priceDecimals = fraction(scale8, prAsDcm, amtAsDcm)
  let castOrderPrice = orderPrice.ts(scale8, priceDecimals)

  let isOrderPriceValid = if(order.orderType == Buy) then castOrderPrice <= curPrice else castOrderPrice >= curPrice
  #if(!isOrderPriceValid) then throw("Order price leads to K decrease. castedOrderPrice="+castedOrderPrice.toString() + " curPrice="+curPrice.toString()) else
  true
}

func commonGet(i: Invocation) = {
  strict checkPayments = i.payments.size() == 1 || throwErr("1 payment expected")

  let payment         = i.payments[0].value()
  let paymentAssetId  = payment.assetId.value()
  let paymentAmount   = payment.amount

  let r = estimateGetOperation(
    i.transactionId.toBase58String(),
    paymentAssetId.toBase58String(),
    paymentAmount,
    i.caller
  )
  let outAmountAmount    = r._1
  let outPriceAmount    = r._2
  let sts         = r._9.parseIntValue()
  let state       = r._10

  if(isGlobalShutdown() || sts == PoolShutdown) then throwErr("Admin blocked: " + sts.toString()) else

  (outAmountAmount,
  outPriceAmount,
  paymentAmount,
  paymentAssetId,
  state
  )
}

func commonPut(
  caller: String,
  txId: String,
  amountAssetPayment: AttachedPayment,
  priceAssetPayment: AttachedPayment,
  slippage: Int,
  emitLp: Boolean,
  isOneAsset: Boolean,
  paymentAmount: Int,
  paymentId: String
) = {
  let r = estimatePutOperation(
    txId,
    slippage,
    amountAssetPayment.value().amount,
    amountAssetPayment.value().assetId,
    priceAssetPayment.value().amount,
    priceAssetPayment.value().assetId,
    caller,
    false,
    emitLp,
    isOneAsset,
    paymentAmount,
    paymentId
  )

  let sts = r._8.parseIntValue()
  if(isGlobalShutdown() || sts == PoolPutDis || sts == PoolShutdown) then throwErr("Blocked:" + sts.toString()) else
  r
}

func managerPublicKeyOrUnit() = match keyManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func pendingManagerPublicKeyOrUnit() = match keyPendingManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

let pd = "Permission denied".throwErr()

func mustManager(i: Invocation) = {
  match managerPublicKeyOrUnit() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

@Callable(i)
func constructor(factoryContract: String) = {
  strict checkCaller = i.mustManager()

  [StringEntry(keyFactoryContact(), factoryContract)]
}

@Callable(i)
func setManager(pendingManagerPublicKey: String) = {
  strict checkCaller = i.mustManager()
  strict checkManagerPublicKey = pendingManagerPublicKey.fromBase58String()

  [StringEntry(keyPendingManagerPublicKey(), pendingManagerPublicKey)]
}

@Callable(i)
func confirmManager() = {
  let pm = pendingManagerPublicKeyOrUnit()
  strict hasPM = pm.isDefined() || throwErr("No pending manager")
  strict checkPM = i.callerPublicKey == pm.value() || throwErr("You are not pending manager")

  [
    StringEntry(keyManagerPublicKey(), pm.value().toBase58String()),
    DeleteEntry(keyPendingManagerPublicKey())
  ]
}

# called by: LP
#
# purpose:
#    function used for entering the pool
# actions:
#    validate list:
#       1. tokens ratio is in correct range
#       2. slipage is not bigger that current tokens ratio
# arguments:
#    slippageTolerance  max allowed slippage
#    shouldAutoStake    perform LP staking immediatelly in case true otherwise transfer LP to user)
# attach:
#    attached should be two valid tokens from the available pools.
# return:
#    transfer LP tokens based on deposit share
@Callable(i)
func put(slippage: Int, autoStake: Boolean) = {
    let factCfg = getFactoryConfig()
    let stakingContract  = addressFromString(factCfg[idxFactStakCntr]).valueOrErrorMessage("Wrong staking contract")
    let slippageContract = addressFromString(factCfg[idxFactSlippCntr]).valueOrErrorMessage("Wrogn slippage contract")
    strict slippageCheck = slippage >= 0 || throwErr("wrong slippage")
    strict paymentsCheck = i.payments.size() == 2 || throwErr("2 payments expected")

    let estimatePut = commonPut(
      i.caller.toString(),
      i.transactionId.toBase58String(),
      AttachedPayment(i.payments[0].value().assetId, i.payments[0].value().amount),
      i.payments[1],
      slippage,
      true,
      false,
      0,
      ""
    )

    let emitLpAmount  = estimatePut._2
    let lpAssetId     = estimatePut._7
    let state         = estimatePut._9
    let amountDiff    = estimatePut._10
    let priceDiff     = estimatePut._11
    let amountId      = estimatePut._12
    let priceId       = estimatePut._13

    # emit lp on factory
    strict r = factoryContract.invoke("emit", [emitLpAmount], [])
    # if the lp instance address is in the legacy list then the legacy factory address will be returned from the factory
    strict el = match (r) {
      case legacy: Address => legacy.invoke("emit", [emitLpAmount], [])
      case _ => unit
    }
    strict sa = if(amountDiff > 0) then {
      slippageContract.invoke("put",[],[AttachedPayment(amountId, amountDiff)])
    } else []
    strict sp = if(priceDiff > 0) then {
      slippageContract.invoke("put",[],[AttachedPayment(priceId, priceDiff)])
    } else []

    let lpTrasfer =
      if(autoStake) then strict ss = stakingContract.invoke("stake",[],[AttachedPayment(lpAssetId, emitLpAmount)]); []
      else [ScriptTransfer(i.caller, emitLpAmount, lpAssetId)]

    state++lpTrasfer
}

# slippage in scale8
@Callable(i)
func putOneTkn(amountAssetPart: Int, priceAssetPart: Int, outLp: Int, slippage: Int, autoStake: Boolean) = {
    let cfg = getFactoryConfig()
    #if(true) then throw("off") else
    let stakingContract   = addressFromString(cfg[idxFactStakCntr]).valueOrErrorMessage("Wrong staking contract")
    let slippageContract  = addressFromString(cfg[idxFactSlippCntr]).valueOrErrorMessage("Wrong slippage contract")
    let gwxRewardContract = addressFromString(cfg[idxFactGwxRewCntr]).valueOrErrorMessage("Wrong gwx reward contract")
    let poolCfg           = getPoolConfig()
    let amountId          = poolCfg[idxAmAsId]
    let priceId           = poolCfg[idxPrAsId]
    let amountDecimals    = poolCfg[idxAmtAsDcm].parseIntValue()
    let priceDecimals     = poolCfg[idxPriceAsDcm].parseIntValue()

    let addon       = this.getString(keyAddonAddress()).valueOrElse("")
    let userAddress = if(addon == i.caller.toString()) then i.originCaller else i.caller

    if(slippage <= 0 || amountAssetPart<=0 || priceAssetPart<=0 || outLp <= 0) then throwErr("Wrong params") else
    if (i.payments.size() != 1) then throwErr("1 payment expected") else

    let payment         = i.payments[0].value()
    let paymentAssetId  = payment.assetId.value().toBase58String()
    let paymentAmount   = payment.amount
    if (paymentAmount < amountAssetPart || paymentAmount < priceAssetPart || paymentAmount < 10_000_000) then {
      throwErr("wrong payment amount") 
    } else

    let amountBalance = getAccBalance(amountId)
    let priceBalance = getAccBalance(priceId)

    let (amountBalanceNow, priceBalanceNow, virtSwapInAm, virtSwapOutPr, virtSwapInPr, virtSwapOutAm) =
      if (paymentAssetId == amountId) then {
        (amountBalance-paymentAmount, priceBalance, paymentAmount - amountAssetPart, priceAssetPart, 0, 0)
      } else if (paymentAssetId == priceId) then {
        (amountBalance, priceBalance-paymentAmount, 0, 0, paymentAmount - priceAssetPart, amountAssetPart)
      } else throwErr("wrong paymentAssetId")

    let D0 = gwxRewardContract.invoke("calcD", [
      amountBalanceNow.toString(),
      priceBalanceNow.toString(),
      amplificator, Amult, Dconv],[]
    )

    let D1 = gwxRewardContract.invoke("calcD", [
      (amountBalanceNow + virtSwapInAm - virtSwapOutAm).toBigInt().toString(),
      (priceBalanceNow + virtSwapInPr - virtSwapOutPr).toBigInt().toString(),
      amplificator, Amult, Dconv],[]
    )

    strict D0vsD1 = validateD(D1.str().parseBigIntValue(), D0.str().parseBigIntValue(), slippage4D)

    let estimatePut = commonPut(
      i.caller.toString(),
      i.transactionId.toBase58String(),
      AttachedPayment(amountId.fromBase58String(), amountAssetPart),
      AttachedPayment(priceId.fromBase58String(), priceAssetPart),
      slippage,
      true,
      true,
      paymentAmount,
      paymentAssetId
    )

    let estimateLP  = estimatePut._2
    let lpAssetId   = estimatePut._7
    let state       = estimatePut._9
    let amountDiff  = estimatePut._10
    let priceDiff   = estimatePut._11

    let lpCalcRes = validateAbsDiff(estimateLP.toBigInt(), outLp.toBigInt(), slippage.toBigInt())

    let emitLpAmount = lpCalcRes._2.toInt()

    # emit lp on factory
    strict e = factoryContract.invoke("emit", [emitLpAmount], [])
    # if the lp instance address is in the legacy list then the legacy factory address will be returned from the factory
    strict el = match (e) {
      case legacy: Address => legacy.invoke("emit", [emitLpAmount], [])
      case _ => unit
    }
    strict sa = if (amountDiff > 0) then {
      slippageContract.invoke("put",[],[AttachedPayment(amountId.fromBase58String(), amountDiff)])
    } else []
    strict sp = if (priceDiff > 0) then {
      slippageContract.invoke("put",[],[AttachedPayment(priceId.fromBase58String(), priceDiff)]) 
    } else []

    let lpTrasfer = if(autoStake) then {
      strict ss = stakingContract.invoke("stake",[],[AttachedPayment(lpAssetId, emitLpAmount)]); []
    } else {
      [ScriptTransfer(i.caller, emitLpAmount, lpAssetId)]
    }  

    state ++ lpTrasfer
}

# Put without LP emission
@Callable(i)
func putForFree(maxslippage: Int) = {
  if (maxslippage < 0) then throwErr("wrong slippage") else
  if (i.payments.size() != 2) then throwErr("2 payments expected") else
    let estimatePut = commonPut(
      i.caller.toString(),
        i.transactionId.toBase58String(),
        AttachedPayment(i.payments[0].value().assetId, i.payments[0].value().amount),
        i.payments[1],
        maxslippage,
        false,
        false,
        0,
        ""
      )
    estimatePut._9
}

# Called by: LP
#
# purpose:
#    function used for exit from pool partially or fully
# actions:
# arguments:
# attach:
#    attached should be corresponding pool LP token
# validate list:
# return:
#    transfer to user his share of pool tokens base on passed lp token amount
@Callable(i)
func get() = {
  let r = commonGet(i)
  let outAmtAmt       = r._1
  let outPriceAmount  = r._2
  let paymentAmount   = r._3
  let paymentAssetId  = r._4
  let state           = r._5
  strict b = invoke(
    factoryContract,
    "burn",
    [paymentAmount],
    [AttachedPayment(paymentAssetId, paymentAmount)]
  )
  state
}

@Callable(i)
func getOneTkn(exchResult: Int, notUsed: Int, outAmount: Int, outAssetId: String, slippage: Int) = {
  if (i.payments.size() != 1) then throwErr("1 payment expected") else
  #if(true) then throw("off") else
  let cfg             = getPoolConfig()
  let lpAssetId       = cfg[idxLPAsId]
  let amountId        = cfg[idxAmAsId]
  let priceId         = cfg[idxPrAsId]
  let amountDecimals  = cfg[idxAmtAsDcm].parseIntValue()
  let priceDecimals   = cfg[idxPriceAsDcm].parseIntValue()
  let sts             = cfg[idxPoolSt]

  let factCfg            = getFactoryConfig()
  let gwxRewardContract  = addressFromString(
    factCfg[idxFactGwxRewCntr]
  ).valueOrErrorMessage("Wrong gwxRewardContract address")
  let payment            = i.payments[0].value()

  # todo: addon is a separate contract with unstake and get on tkn operation,
  # should me merged with this contract once max script size is increased
  let addon           = this.getString(keyAddonAddress()).valueOrElse("")
  let userAddress     = if(addon == i.caller.toString()) then i.originCaller else i.caller
  let txId58          = i.transactionId.toBase58String()
  let paymentAssetId  = payment.assetId.value()
  let paymentAmount   = payment.amount

  if(paymentAmount < 10_00_000_000) then throwErr("Min payment 10 LP") else

  if(slippage < 0 || exchResult < 0 || outAmount < 0) then throwErr("Wrong params") else
  if (lpAssetId != paymentAssetId.toBase58String()) then throwErr("Wrong LP") else

  let r = estimateGetOperation(
    i.transactionId.toBase58String(),
    paymentAssetId.toBase58String(),
    paymentAmount,
    i.caller
  )
  let estimAmAmt    = r._1
  let estimPrAmt    = r._2

  let amountBalance = getAccBalance(amountId)
  let priceBalance = getAccBalance(priceId)

  let (amountBalanceNow, priceBalanceNow, virtSwapInAm, virtSwapOutPr, virtSwapInPr, virtSwapOutAm, totalGet) =
    if (outAssetId == amountId) then {
      (amountBalance - estimAmAmt, priceBalance - estimPrAmt, exchResult, estimPrAmt, 0, 0, estimAmAmt + exchResult)
    } else if (outAssetId == priceId) then {
      (amountBalance - estimAmAmt, priceBalance - estimPrAmt, 0, 0, exchResult, estimAmAmt,  estimPrAmt + exchResult)
    } else throwErr("wrong outAssetId")

  if(virtSwapInAm < 0 || virtSwapInPr < 0) then throwErr("Wrong calc") else

  let D0 = gwxRewardContract.invoke("calcD", [
    amountBalanceNow.toString(),
    priceBalanceNow.toString(),
    amplificator,
    Amult,
    Dconv
  ],[]);

  let D1 = gwxRewardContract.invoke("calcD", [
    (amountBalanceNow - virtSwapInAm + virtSwapOutAm).toString(),
    (priceBalanceNow + virtSwapOutPr - virtSwapInPr).toString(),
    amplificator,
    Amult,
    Dconv
  ],[]);

  strict D0vsD1 = validateD(D1.str().parseBigIntValue(), D0.str().parseBigIntValue(), slippage4D)

  strict finalRes = validateAbsDiff(totalGet.toBigInt(), outAmount.toBigInt(), slippage.toBigInt())

  let (outAm, outPr)  = if(outAssetId == amountId) then (finalRes._2.toInt(), 0) else (0, finalRes._2.toInt())

  strict decimals = if amountDecimals >= priceDecimals then {
    amountDecimals
  } else {
    priceDecimals
  }

  let curPrX18 = calcPriceBigInt(priceBalance.toX18(decimals), amountBalance.toX18(decimals))
  let curPr = curPrX18.fromX18(scale8)

  strict state =
  [
    ScriptTransfer(
      userAddress, outAm + outPr, if (outAssetId == "WAVES") then unit else outAssetId.fromBase58String()
    ),
    StringEntry(
      keyGetActionByUser(userAddress.toString(), txId58),
      dataGetActionInfo(outAm, outPr, paymentAmount, curPr, height, lastBlock.timestamp)
    ),
    IntegerEntry(keyPriceLast(), curPr),
    IntegerEntry(keyPriceHistory(height, lastBlock.timestamp), curPr)
  ]

  strict burn = invoke(
    factoryContract,
    "burn",
    [paymentAmount],
    [AttachedPayment(paymentAssetId, paymentAmount)])
  state
}

@Callable(i)
func getNoLess(noLessThenAmtAsset: Int, noLessThenPriceAsset: Int) = {
  let r = commonGet(i)
  let outAmountAmount = r._1
  let outPriceAmount  = r._2
  let paymentAmount   = r._3
  let paymentAssetId  = r._4
  let state           = r._5
  strict checkOutAmountAmount = outAmountAmount >= noLessThenAmtAsset || throwErr(
    "Failed:  " + outAmountAmount.toString() + " < " + noLessThenAmtAsset.toString()
  )
  strict checkOutPriceAmount = outPriceAmount >= noLessThenPriceAsset || throwErr(
    "Failed: " + outPriceAmount.toString() + " < " + noLessThenPriceAsset.toString()
  )

  strict burnLPAssetOnFactory = invoke(
    factoryContract,
    "burn",
    [paymentAmount],
    [AttachedPayment(paymentAssetId, paymentAmount)]
  )
  state
}

# Unstake LP tokens and exit from pool
@Callable(i)
func unstakeAndGet(amount: Int) = {
  strict checkPayments = if (i.payments.size() != 0) then throwErr("no payments expected") else true

  let cfg = getPoolConfig()
  let factoryCfg = getFactoryConfig()

  let lpAssetId = cfg[idxLPAsId].fromBase58String()
  let staking = factoryCfg[idxFactStakCntr].addressFromString().valueOrErrorMessage("wrong")

  # negative amount will not pass
  strict unstakeInv = staking.invoke("unstake", [lpAssetId.toBase58String(), amount], [])

  let r = estimateGetOperation(i.transactionId.toBase58String(), lpAssetId.toBase58String(), amount, i.caller)
  let sts = r._9.parseIntValue()
  let state = r._10

  strict v = if (isGlobalShutdown() || sts == PoolShutdown) then throwErr("Blocked: " + sts.toString()) else true

  strict burnA = invoke(factoryContract, "burn", [amount], [AttachedPayment(lpAssetId, amount)])

  state
}

# purpose:
#    used BY FACTORY for activating new LP pool. Validate it was called only once.
# actions:
#    1. issue new LP token and save data in state
#    2. burn LP token
#    3. write initial price, that is used for first deposit
# arguments:
# attach:
# return:
@Callable(i)
func activate(amtAsStr: String, prAsStr: String) = {
  if (i.caller.toString() != factoryContract.toString()) then throwErr("denied") else {
    (
      [
        StringEntry(keyAmountAsset(),amtAsStr),
        StringEntry(keyPriceAsset(),prAsStr)
      ],
      "success"
    )
  }
}

# Set string from addon
@Callable(i)
func setS(k: String, v: String) = {
  if (i.caller.toString() != this.getStringOrFail(keyAddonAddress())) then pd else

  [
    StringEntry(k, v)
  ]
}

# Set integer from addon
@Callable(i)
func setI(k: String, v: Int) = {
  if (i.caller.toString() != this.getStringOrFail(keyAddonAddress())) then pd else

  [
    IntegerEntry(k, v)
  ]
}

# API wrappers
@Callable(i)
func getPoolConfigWrapperREADONLY() = {
  (
    [],
    getPoolConfig()
  )
}

@Callable(i)
func getAccBalanceWrapperREADONLY(assetId: String) = {
  (
    [],
    assetId.getAccBalance()
  )
}

@Callable(i)
func calcPricesWrapperREADONLY(amAmt: Int, prAmt: Int, lpAmt: Int) = {
  let pr = calcPrices(amAmt, prAmt, lpAmt)
  (
    [],
    [
      pr[0].toString(),
      pr[1].toString(),
      pr[2].toString()
    ]
  )
}

@Callable(i)
func fromX18WrapperREADONLY(val: String, resScaleMult: Int) = {
  (
    [],
    fromX18(val.parseBigIntValue(), resScaleMult)
  )
}

@Callable(i)
func toX18WrapperREADONLY(origVal: Int, origScaleMult: Int) = {
  (
    [],
    toX18(origVal, origScaleMult).toString()
  )
}

@Callable(i)
func calcPriceBigIntWrapperREADONLY(prAmtX18: String, amAmtX18: String) = {
  (
    [],
    calcPriceBigInt(prAmtX18.parseBigIntValue(), amAmtX18.parseBigIntValue()).toString()
  )
}

@Callable(i)
func estimatePutOperationWrapperREADONLY(
  txId58: String,
  slippage: Int,
  inAmountAssetAmount: Int,
  inAmId: ByteVector,
  inPriceAssetAmount: Int,
  inPrId: ByteVector,
  usrAddr: String,
  isEvaluate: Boolean,
  emitLp: Boolean
) = {
  (
    [],
    estimatePutOperation(
      txId58,
      slippage,
      inAmountAssetAmount,
      inAmId,
      inPriceAssetAmount,
      inPrId,
      usrAddr,
      isEvaluate,
      emitLp,
      false,
      0,
      ""
    )
  )
}

@Callable(i)
func estimateGetOperationWrapperREADONLY(txId58: String, paymentAsId: String, paymentLpAmount: Int, usrAddr: String) = {
  let r = estimateGetOperation(
    txId58,
    paymentAsId,
    paymentLpAmount,
    usrAddr.addressFromStringValue()
  )
  (
    [],
    (r._1, r._2, r._3, r._4, r._5, r._6, r._7, r._8.toString(), r._9, r._10)
  )
}

@Verifier(tx)
func verify() = {
  match tx {
    case order: Order =>
      let mtchPub    = getMatcherPubOrFail()
      let orV    = validateMatcherOrderAllowed(order)
      let sndrV   = sigVerify(order.bodyBytes, order.proofs[0], order.senderPublicKey)
      let mtchV  = sigVerify(order.bodyBytes, order.proofs[1], mtchPub)

      (orV && sndrV && mtchV) || throwOrderError(orV, sndrV, mtchV)
    case _ => {
      let targetPublicKey = match managerPublicKeyOrUnit() {
        case pk: ByteVector => pk
        case _: Unit => tx.senderPublicKey
      }
      sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
    }
  }
}
