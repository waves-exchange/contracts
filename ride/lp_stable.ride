{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# TODO:
#
#  add callable to remove existing pool
#  add restriction on min deposit amount
#  AMU: move "WAVES" into spec variable
#  AMU: add safe cast method instead of copy/past: inAmAssetId.valueOrElse("WAVES".fromBase58String()).toBase58String()

# Description:
#   Contract represents single liquidity pool for specific asset pair, e.g. BTC-USDN
#
#   Actors:
#      1. LP
#      2. Factory
#      3. Matcher
#
#   Actor LP could do do the following:
#      1. Enter the pool
#      2. Exit the pool
#
#   Factory LP could do do the following:
#      1. Activate the pool
#      2. Halt pool operations partially of completelly
#
#   Matcher LP could do do the following:
#      1. Perform exchange operations with pool assets
#
#   New Pool deployment flow:
#      0. Factory contract has BLAKE2b-256 hash of the Pool contract.
#      1. Pool contract is deployed to the blockchain (factory address is injected into it)
#      2. Factory calls 'activate' callable and activate pool in case all prerequisites passed (assset pairs are not registered, contract hash matches actual)

#-----------------
# GLOBAL VARIABLES
#-----------------
let scale8 = 100_000_000
let scale8BigInt = 100_000_000.toBigInt()
let scale18 = 1_000_000_000_000_000_000.toBigInt()
let zeroBigInt = 0.toBigInt()
let oneBigInt = 1.toBigInt()
let slippage4D = (scale8 - scale8 * 1 / scale8).toBigInt() # 9999999 or error of 0.0000001

let Amult = "100"
let Dconv = "1" # D convergence

let SEP = "__"
let EMPTY = ""
let PoolActive               = 1   # ACTIVE, pool without restrictions
let PoolPutDis               = 2   # PUT DISABLED, pool with put operation disabled
let PoolMatcherDis           = 3   # MATCHER DISABLED, pool with matcher operations disabled
let PoolShutdown             = 4   # SHUTDOWN, pool operations halted
# data indexes from pool config stored in factory
let idxPoolAddress                           = 1
let idxPoolSt                               = 2
let idxLPAsId                                = 3
let idxAmAsId                                = 4
let idxPrAsId                                = 5
let idxAmtAsDcm                              = 6
let idxPriceAsDcm                            = 7
let idxIAmtAsId                              = 8
let idxIPriceAsId                            = 9
# data indexes from factory config
let idxFactStakCntr      = 1
let idxFactSlippCntr     = 7
let idxFactGwxRewCntr    = 10

let feeDefault = fraction(5, scale8, 10_000)
#-------------------------
# WX COMMON LIBRARY
#-------------------------
func t1(origVal: Int, origScaleMult: Int)        = fraction(origVal.toBigInt(), scale18, origScaleMult.toBigInt())
func f1(val: BigInt, resultScaleMult: Int)       = fraction(val, resultScaleMult.toBigInt(), scale18).toInt()

# cast passed amount to specified 'resScale' scale value from 'curScale' scale value
func ts(amt: Int, resScale: Int, curScale: Int)  = fraction(amt, resScale, curScale)

func abs(val: BigInt) = if (val < zeroBigInt) then -val else val

#-------------------------
# KEYS ON CURRENT CONTRACT
#-------------------------
func fc() = {"%s__factoryContract"}
func mpk() = {"%s__managerPublicKey"}
func pmpk() = {"%s__pendingManagerPublicKey"}
func pl() = {"%s%s__price__last"}
func ph(h: Int, t: Int) = {makeString(["%s%s%d%d__price__history", h.toString(), t.toString()], SEP)}
# keyPutActionByUser
func pau(ua: String, txId: String) = "%s%s%s__P__" + ua + "__" + txId
# keyGetActionByUser
func gau(ua: String, txId: String) = "%s%s%s__G__" + ua + "__" + txId
func aa() = {"%s__amountAsset"}
func pa() = {"%s__priceAsset"}
# keyAmplificator
func amp() = {"%s__amp"}
func ada() = "%s__addonAddr"

let keyFee = "%s__fee"
let fee = this.getInteger(keyFee).valueOrElse(feeDefault)

#------------------------
# KEYS ON OTHER CONTRACTS
#------------------------
# from factory
# keyFactoryConfig
func fcfg() = {"%s__factoryConfig"}
# keyMatcherPub
func mtpk() = "%s%s__matcher__publicKey"
# keyPoolConfig
func pc(iAmtAs: String, iPrAs: String) = {"%d%d%s__" + iAmtAs + "__" + iPrAs + "__config"}
# keyMappingsBaseAsset2internalId
func mba(bAStr: String) = {"%s%s%s__mappings__baseAsset2internalId__" + bAStr}
# keyAllPoolsShutdown
func aps() = {"%s__shutdown"}
func keyAllowedLpStableScriptHash() = "%s__allowedLpStableScriptHash"
func keyFeeCollectorAddress() = "%s__feeCollectorAddress"

#------------------------
# FAILURES
#------------------------
# throwOrderError
func toe(orV: Boolean, sendrV: Boolean, matchV: Boolean) = {
  throw("Failed: ordValid=" + orV.toString() + " sndrValid=" + sendrV.toString() + " mtchrValid=" + matchV.toString())
}

#------------------------
# GLOBAL FUNCTIONS
#------------------------

func str(val: Any) = {
  match val {
    case valStr: String => valStr
    case _ => throw("fail cast to String")
  }
}

# getStringOrFail
func strf(addr: Address, key: String) = addr.getString(key).valueOrErrorMessage(makeString(["mandatory ", addr.toString(), ".", key, " not defined"], ""))
# getIntOrFail
func intf(addr: Address, key: String) = addr.getInteger(key).valueOrErrorMessage(makeString(["mandatory ", addr.toString(), ".", key, " not defined"], ""))

# factoryContract
let fca = addressFromStringValue(strf(this, fc()))

let A = strf(this, amp())

# isGlobalShutdown
# check that global shutdown is take place
func igs() = {
  fca.getBoolean(aps()).valueOrElse(false)
}

# getMatcherPubOrFail
func mp() = {
  fca.strf(mtpk()).fromBase58String()
}

let feeCollectorAddress = fca.strf(keyFeeCollectorAddress()).addressFromStringValue()

# getPoolConfig
# function used to gather all pool data from factory
func gpc() = {
  let amtAs = strf(this, aa())
  let priceAs = strf(this, pa())
  let iPriceAs = intf(fca, mba(priceAs))
  let iAmtAs = intf(fca, mba(amtAs))
  strf(fca, pc(iAmtAs.toString(), iPriceAs.toString())).split(SEP)
}

# getFactoryConfig
func gfc() = {
  strf(fca, fcfg()).split(SEP)
}

let factoryConfig = gfc()
let stakingContract = factoryConfig[idxFactStakCntr].addressFromString().valueOrErrorMessage("Invalid staking contract address")
let slipageContract = factoryConfig[idxFactSlippCntr].addressFromString().valueOrErrorMessage("Invalid slipage contract address")
let gwxContract = factoryConfig[idxFactGwxRewCntr].addressFromString().valueOrErrorMessage("Invalid gwx contract address")

func dataPutActionInfo(inAmtAssetAmt: Int, inPriceAssetAmt: Int, outLpAmt: Int, price: Int, slipByUser: Int, slippageReal: Int, txHeight: Int, txTimestamp: Int, slipageAmAmt: Int, slipagePrAmt: Int) = {
  makeString(["%d%d%d%d%d%d%d%d%d%d", inAmtAssetAmt.toString(), inPriceAssetAmt.toString(), outLpAmt.toString(), price.toString(), slipByUser.toString(), slippageReal.toString(), txHeight.toString(), txTimestamp.toString(), slipageAmAmt.toString(), slipagePrAmt.toString()], SEP)
}

func dataGetActionInfo(outAmtAssetAmt: Int, outPriceAssetAmt: Int, inLpAmt: Int, price: Int, txHeight: Int, txTimestamp: Int) = {
  makeString( ["%d%d%d%d%d%d", outAmtAssetAmt.toString(), outPriceAssetAmt.toString(), inLpAmt.toString(), price.toString(), txHeight.toString(), txTimestamp.toString()], SEP)
}

func getAccBalance(assetId: String) = {
  if(assetId == "WAVES") then wavesBalance(this).available else assetBalance(this, fromBase58String(assetId))
}

# calcPriceBigInt
func cpbi(prAmtX18: BigInt, amAmtX18: BigInt) = {
  fraction(prAmtX18, scale18, amAmtX18)
}

# validateAbsDiff
func vad(A1: BigInt, A2: BigInt, slippage: BigInt) = {
  let diff = fraction(A1 - A2, scale8BigInt, A2)
  let pass = (slippage - abs(diff)) > zeroBigInt
  if (!pass) then throw("Big slpg: " + diff.toString()) else
  (pass, min([A1, A2]))
}

# validateD
func vd(D1: BigInt, D0: BigInt, slpg: BigInt) = {
  let diff = fraction(D0, scale8BigInt, D1)
  let fail = diff < slpg
  if (fail || D1 < D0) then throw(D0.toString() + " " + D1.toString() + " " + diff.toString() + " " + slpg.toString()) else
  fail
}

# privateCalcPrice
# cast assets and calc price
func pcp(amAssetDcm: Int, prAssetDcm: Int, amAmt: Int, prAmt: Int) = {
    let amtAsAmtX18 = amAmt.t1(amAssetDcm)
    let prAsAmtX18 = prAmt.t1(prAssetDcm)
    cpbi(prAsAmtX18, amtAsAmtX18)
}

# used only in stats endpoint, so result values are in scale8 as required
func calcPrices(amAmt: Int, prAmt: Int, lpAmt: Int) = {
  let cfg = gpc()
  let amtAsDcm = cfg[idxAmtAsDcm].parseIntValue()
  let prAsDcm = cfg[idxPriceAsDcm].parseIntValue()

  let priceX18 = pcp(amtAsDcm, prAsDcm, amAmt, prAmt)

  let amAmtX18 = amAmt.t1(amtAsDcm)
  let prAmtX18 = prAmt.t1(prAsDcm)
  let lpAmtX18 = lpAmt.t1(scale8)

  let lpPrInAmAsX18 = cpbi(amAmtX18, lpAmtX18)
  let lpPrInPrAsX18 = cpbi(prAmtX18, lpAmtX18)

  [priceX18, lpPrInAmAsX18, lpPrInPrAsX18]
}

# public API which is used by backend
func calculatePrices(amAmt: Int, prAmt: Int, lpAmt: Int) = {
    let p = calcPrices(amAmt, prAmt, lpAmt)
    [p[0].f1(scale8),
        p[1].f1(scale8),
        p[2].f1(scale8)]
}

func takeFee(amount: Int) = {
  let feeAmount = fraction(amount, fee, scale8)
  (amount - feeAmount, feeAmount)
}

# estimateGetOperation
func ego(txId58: String, pmtAssetId: String, pmtLpAmt: Int, userAddress: Address) = {
  # data from pool config
  let cfg             = gpc()
  let lpId       = cfg[idxLPAsId]
  let amId       = cfg[idxAmAsId]
  let prId       = cfg[idxPrAsId]
  let amDcm      = cfg[idxAmtAsDcm].parseIntValue()
  let prDcm      = cfg[idxPriceAsDcm].parseIntValue()
  let sts      = cfg[idxPoolSt]

  let lpEmiss = assetInfo(lpId.fromBase58String()).valueOrErrorMessage("Wrong LP id").quantity

  # validation block
  if (lpId != pmtAssetId) then throw("Wrong pmt asset") else

  let amBalance = getAccBalance(amId)
  let amBalanceX18 = amBalance.t1(amDcm)

  let prBalance = getAccBalance(prId)
  let prBalanceX18 = prBalance.t1(prDcm)

  let curPriceX18 = cpbi(prBalanceX18, amBalanceX18)
  let curPrice = curPriceX18.f1(scale8)

  let pmtLpAmtX18 = pmtLpAmt.t1(scale8)
  let lpEmissX18 = lpEmiss.t1(scale8)
  # calculations
  let outAmAmtX18 = fraction(amBalanceX18, pmtLpAmtX18, lpEmissX18)
  let outPrAmtX18 = fraction(prBalanceX18, pmtLpAmtX18, lpEmissX18)

  # cast amounts to asset decimals
  let outAmAmt = outAmAmtX18.f1(amDcm)
  let outPrAmt = outPrAmtX18.f1(prDcm)

  let state = if (txId58 == "") then [] else
  [
    ScriptTransfer(userAddress, outAmAmt, if (amId == "WAVES") then unit else amId.fromBase58String()),
    ScriptTransfer(userAddress, outPrAmt, if (prId == "WAVES") then unit else prId.fromBase58String()),

    StringEntry(
          gau(userAddress.toString(), txId58),
          dataGetActionInfo(outAmAmt, outPrAmt, pmtLpAmt, curPrice, height, lastBlock.timestamp)),
    IntegerEntry(pl(), curPrice),
    IntegerEntry(ph(height, lastBlock.timestamp), curPrice)
  ]

  ( outAmAmt,     # 1
    outPrAmt,     # 2
    amId,         # 3
    prId,         # 4
    amBalance,    # 5
    prBalance,    # 6
    lpEmiss,   # 7
    curPriceX18,  # 8
    sts,   # 9
    state         # 10
  )
}

# estimatePutOperation
func epo(txId58: String,
                          slippage: Int,
                          inAmAmt: Int,
                          inAmId: ByteVector|Unit,
                          inPrAmt: Int,
                          inPrId: ByteVector|Unit,
                          userAddress: String,
                          isEval: Boolean,
                          emitLp: Boolean,
                          isOneAsset: Boolean,
                          validateSlippage: Boolean,
                          pmtAmt: Int,
                          pmtId: String) = {
    # data from pool config
    let cfg           = gpc()
    let lpId     = cfg[idxLPAsId].fromBase58String()
    let amIdStr  = cfg[idxAmAsId]
    let prIdStr  = cfg[idxPrAsId]
    let inAmIdStr   = cfg[idxIAmtAsId]
    let inPrIdStr = cfg[idxIPriceAsId]
    let amtDcm   = cfg[idxAmtAsDcm].parseIntValue()
    let priceDcm = cfg[idxPriceAsDcm].parseIntValue()
    let sts    = cfg[idxPoolSt]

    let lpEm = assetInfo(lpId).valueOrErrorMessage("Wr lp as").quantity

    # get current balances from acc
    let amBalance = if(isEval) then getAccBalance(amIdStr) else
                                                              if(isOneAsset && pmtId == amIdStr) then getAccBalance(amIdStr) - pmtAmt else
                                                                                            if(isOneAsset) then getAccBalance(amIdStr) else getAccBalance(amIdStr) - inAmAmt
    let prBalance = if(isEval) then getAccBalance(prIdStr) else
                                                              if(isOneAsset && pmtId == prIdStr) then getAccBalance(prIdStr) - pmtAmt  else
                                                                                            if(isOneAsset) then getAccBalance(prIdStr) else getAccBalance(prIdStr) - inPrAmt

    #if(true) then throw("lpEmission = "+ lpEmission.toString() +
    #                    " amBalance = " + amBalance.toString() +
    #                    " prBalance = " + prBalance.toString() +
    #                    " getAccBalance(amIdStr) = " + getAccBalance(amIdStr).toString() +
    #                    " etAccBalance(prIdStr) = " + getAccBalance(prIdStr).toString()) else

    # cast amounts to the lp decimals
    let inAmAssetAmtX18 = inAmAmt.t1(amtDcm)
    let inPrAssetAmtX18 = inPrAmt.t1(priceDcm)

    # calc user expected price
    let userPriceX18 = cpbi(inPrAssetAmtX18, inAmAssetAmtX18)

    # calc pool price
    let amBalanceX18 = amBalance.t1(amtDcm)
    let prBalanceX18 = prBalance.t1(priceDcm)

    # case of the initial or first deposit
    # result is a tuple containing the following:
    # 1. lp amount that user got
    # 2. amtAsset amount that goes to Pool liquidity
    # 3. priceAsset amount that goes to Pool liquidity
    # 4. pool price after PUT operation
    let r = if(lpEm == 0) then {
        let curPriceX18 = zeroBigInt
        let slippageX18 = zeroBigInt
        # calc initial deposit by geometric mean
        let lpAmtX18 = pow(inAmAssetAmtX18 * inPrAssetAmtX18, 0, 5.toBigInt(), 1, 0, DOWN)
        (
          lpAmtX18.f1(scale8),
          inAmAssetAmtX18.f1(amtDcm),
          inPrAssetAmtX18.f1(priceDcm),
          cpbi(prBalanceX18 + inPrAssetAmtX18, amBalanceX18 + inAmAssetAmtX18),
          slippageX18
        )
    } else {
            let curPriceX18 = cpbi(prBalanceX18, amBalanceX18)
            let slippageRealX18 = fraction(abs(curPriceX18 - userPriceX18), scale18, curPriceX18)
            let slippageX18 = slippage.t1(scale8)
            # validate slippage
            if (validateSlippage && curPriceX18 != zeroBigInt && slippageRealX18 > slippageX18) then throw("Price slippage " + slippageRealX18.toString() + " > " + slippageX18.toString()) else

            let lpEmissionX18 = lpEm.t1(scale8)
            # calculate amount of price asset needed to deposit pool by current price and user's amountAsset amount
            let prViaAmX18 = fraction(inAmAssetAmtX18, curPriceX18, scale18)
            let amViaPrX18 = fraction(inPrAssetAmtX18, scale18, curPriceX18)

            # calculate amount and price assets to perform pool deposit in proportion to current pool price
            let expectedAmts= if (prViaAmX18 > inPrAssetAmtX18)
                    then (amViaPrX18, inPrAssetAmtX18)
                    else (inAmAssetAmtX18, prViaAmX18)

            let expAmtAssetAmtX18   = expectedAmts._1
            let expPriceAssetAmtX18 = expectedAmts._2
            # calculate LP amount that user
            let lpAmtX18 = fraction(lpEmissionX18, expPriceAssetAmtX18, prBalanceX18)
            (
              lpAmtX18.f1(scale8),
              expAmtAssetAmtX18.f1(amtDcm),
              expPriceAssetAmtX18.f1(priceDcm),
              curPriceX18,
              slippageX18
            )
        }

    let calcLpAmt         = r._1
    let calcAmAssetPmt    = r._2
    let calcPrAssetPmt    = r._3
    let curPrice          = r._4.f1(scale8)
    let slippageCalc      = r._5.f1(scale8)

    if(calcLpAmt <= 0) then throw("LP <= 0") else

    let emitLpAmt = if (!emitLp) then 0 else calcLpAmt
    let amDiff = inAmAmt - calcAmAssetPmt
    let prDiff = inPrAmt - calcPrAssetPmt

    let (writeAmAmt, writePrAmt) = if(isOneAsset && pmtId == amIdStr)
                                  then (pmtAmt, 0)
                                        else if(isOneAsset && pmtId == prIdStr)
                                            then (0, pmtAmt)
                                                  else (calcAmAssetPmt, calcPrAssetPmt)

    let commonState = [
      IntegerEntry(pl(), curPrice),
      IntegerEntry(ph(height, lastBlock.timestamp), curPrice),
      StringEntry(
          pau(userAddress, txId58),
          dataPutActionInfo(writeAmAmt, writePrAmt, emitLpAmt, curPrice, slippage, slippageCalc, height, lastBlock.timestamp, amDiff, prDiff))
    ]

    (
      calcLpAmt,                # 1.
      emitLpAmt,                # 2.
      curPrice,                 # 3.
      amBalance,                # 4.
      prBalance,                # 5.
      lpEm,                     # 6.
      lpId,                     # 7.
      sts,               # 8.
      commonState,              # 9.
      amDiff,                   # 10.
      prDiff,                   # 11.
      inAmId,                   # 12
      inPrId                    # 13
    )
}

# validateMatcherOrderAllowed
func moa(order: Order) = {
  let cfg = gpc()
  let amtAsId = cfg[idxAmAsId]
  let prAsId = cfg[idxPrAsId]
  let sts = cfg[idxPoolSt].parseIntValue()
  let amtAsDcm = cfg[idxAmtAsDcm].parseIntValue()
  let prAsDcm = cfg[idxPriceAsDcm].parseIntValue()

  # get current balances from acc
  let accAmtAsBalance = getAccBalance(amtAsId)
  let accPrAsBalance = getAccBalance(prAsId)

  let curPriceX18 = if(order.orderType == Buy)
      then pcp(amtAsDcm, prAsDcm, accAmtAsBalance + order.amount, accPrAsBalance)
      else pcp(amtAsDcm, prAsDcm, accAmtAsBalance - order.amount, accPrAsBalance)
  let curPrice = curPriceX18.f1(scale8)

  # validate status
  if (igs() || sts == PoolMatcherDis || sts == PoolShutdown) then throw("Admin blocked") else

  # validate pairs
  let orAmtAsset = order.assetPair.amountAsset
  let orAmtAsStr = if( orAmtAsset == unit) then "WAVES" else toBase58String(orAmtAsset.value())
  let orPrAsset = order.assetPair.priceAsset
  let orPrAsStr = if( orPrAsset == unit) then "WAVES" else toBase58String(orPrAsset.value())
  if(orAmtAsStr != amtAsId ||  orPrAsStr != prAsId) then throw("Wr assets") else

  let orderPrice = order.price
  #priceDecimals = 8 + priceAssetDcm - amtAssetDcm
  let priceDcm = fraction(scale8, prAsDcm, amtAsDcm)
  let castOrderPrice = orderPrice.ts(scale8, priceDcm)

  let isOrderPriceValid = if(order.orderType == Buy) then castOrderPrice <= curPrice else castOrderPrice >= curPrice
  #if(!isOrderPriceValid) then throw("Order price leads to K decrease. castedOrderPrice="+castedOrderPrice.toString() + " curPrice="+curPrice.toString()) else
  true
}

# commonGet
func cg(i: Invocation) = {
  if (i.payments.size() != 1) then throw("1 pmnt exp") else

  let pmt         = i.payments[0].value()
  let pmtAssetId  = pmt.assetId.value()
  let pmtAmt      = pmt.amount

  let r = ego(i.transactionId.toBase58String(), pmtAssetId.toBase58String(), pmtAmt, i.caller)
  let outAmAmt    = r._1
  let outPrAmt    = r._2
  let sts  = r._9.parseIntValue()
  let state       = r._10

  if(igs() || sts == PoolShutdown) then throw("Admin blocked: " + sts.toString()) else

  (outAmAmt,
  outPrAmt,
  pmtAmt,
  pmtAssetId,
  state
  )
}

# commonPut
func cp(caller: String,
              txId: String,
              amAsPmt: AttachedPayment,
              prAsPmt: AttachedPayment,
              slippage: Int,
              emitLp: Boolean,
              isOneAsset: Boolean,
              validateSlippage: Boolean,
              pmtAmt: Int,
              pmtId: String) = {

    let r = epo(txId, # i.transactionId.toBase58String()
                      slippage,
                      amAsPmt.value().amount,
                      amAsPmt.value().assetId,
                      prAsPmt.value().amount,
                      prAsPmt.value().assetId,
                      caller,     #i.caller.toString()
                      false,
                      emitLp,
                      isOneAsset,
                      validateSlippage,
                      pmtAmt,
                      pmtId)

    let sts  = r._8.parseIntValue()
    if(igs() || sts == PoolPutDis || sts == PoolShutdown) then throw("Blocked:" + sts.toString()) else
    r
}

func estimatePutOneTknV2(
  pmtAmtRaw: Int,
  pmtAssetId: String,
  userAddress: String,
  txId: String
) = {
  let poolConfig = gpc()
  let amId = poolConfig[idxAmAsId]
  let prId = poolConfig[idxPrAsId]

  let amBalance = amId.getAccBalance()
  let prBalance = prId.getAccBalance()

  let (pmtAmt, feeAmount) = pmtAmtRaw.takeFee()

  let (amBalanceNow, prBalanceNow) =
    if (txId == "") then (amBalance, prBalance) else {
      if (pmtAssetId == amId) then {
        if (amBalance < pmtAmtRaw) then "invalid payment amount".throw() else
          (amBalance - pmtAmtRaw, prBalance)
      } else if (pmtAssetId == prId) then {
        if (prBalance < pmtAmtRaw) then "invalid payment amount".throw() else
          (amBalance, prBalance - pmtAmtRaw)
      } else throw("wrong pmtAssetId")
    }

  let (amBalanceForCalc, prBalanceForCalc) = if (pmtAssetId == amId) then (amBalanceNow, prBalanceNow) else (prBalanceNow, amBalanceNow)

  let xPrecision = 1
  let result = gwxContract.invoke("calcPutXOnly", [
    pmtAmt.toString(), # paymentAmountBigIntStr
    amBalanceForCalc.toString(), # amountAssetBalanceBigIntStr
    prBalanceForCalc.toString(), # priceAssetBalanceBigIntStr
    "", # dBigIntStr
    A, # amplificatorBigIntStr
    Amult, # amplificatorPrecisionBigIntStr
    xPrecision.toString(), # targetXPrecisionBigIntStr
    Dconv # targetDPrecisionBigIntStr
  ], []).exactAs[(Int, Int)]

  let (amAssetPart, prAssetPart) = if (pmtAssetId == amId) then result else (result._2, result._1)

  let estPut = cp(userAddress,
    txId,
    AttachedPayment(amId.fromBase58String(), amAssetPart),
    AttachedPayment(prId.fromBase58String(), prAssetPart),
    0,
    true,
    true,
    false,
    pmtAmtRaw,
    pmtAssetId
  )

  let estimLP   = estPut._2
  let lpAssetId = estPut._7
  let state     = estPut._9
  let amDiff    = estPut._10
  let prDiff    = estPut._11

  estPut
}

func getOneTknV2Internal(
  outAssetId: String,
  minOutAmount: Int,
  payments: List[AttachedPayment],
  caller: Address,
  originCaller: Address,
  transactionId: ByteVector
) = {
  if (payments.size() != 1) then throw("1 pmnt expd") else
  let poolConfig = gpc()
  let lpId = poolConfig[idxLPAsId]
  let amId = poolConfig[idxAmAsId]
  let prId = poolConfig[idxPrAsId]
  let amDecimals = poolConfig[idxAmtAsDcm].parseIntValue()
  let prDecimals = poolConfig[idxPriceAsDcm].parseIntValue()
  let poolStatus = poolConfig[idxPoolSt]

  let userAddress = if (caller == this) then originCaller else caller

  let pmt = payments[0].value()
  let pmtAssetId = pmt.assetId.value()
  let pmtAmt = pmt.amount

  if (pmtAmt < 10_00_000_000) then throw("Min pmt 10 LP") else

  let txId58 = transactionId.toBase58String()

  if (lpId != pmtAssetId.toBase58String()) then throw("Wrong LP") else

  let amBalance = amId.getAccBalance()
  let prBalance = prId.getAccBalance()

  let (totalGet, feeAmount) = this.invoke("getOneTknV2READONLY", [outAssetId, pmtAmt], []).exactAs[(Int, Int)]

  let totalAmount = if (minOutAmount > 0 && totalGet < minOutAmount) then {
    ["amount to receive is less than ", minOutAmount.toString()].makeString("").throw()
  } else totalGet

  let (outAm, outPr) = if(outAssetId == amId) then (totalAmount, 0) else (0, totalAmount)

  let curPrX18 = cpbi(prBalance.t1(prDecimals), amBalance.t1(amDecimals))
  let curPr = curPrX18.f1(scale8)

  let outAssetIdOrWaves = if (outAssetId == "WAVES") then unit else outAssetId.fromBase58String()
  let sendFeeToMatcher = if (feeAmount > 0) then [ScriptTransfer(feeCollectorAddress, feeAmount, outAssetIdOrWaves)] else []

  strict state = [
    ScriptTransfer(userAddress, totalAmount, outAssetIdOrWaves),
    StringEntry(
      gau(userAddress.toString(), txId58),
      dataGetActionInfo(outAm, outPr, pmtAmt, curPr, height, lastBlock.timestamp)),
    IntegerEntry(pl(), curPr),
    IntegerEntry(ph(height, lastBlock.timestamp), curPr)
  ] ++ sendFeeToMatcher

  strict burn = invoke(fca,
    "burn",
    [pmtAmt],
    [AttachedPayment(pmtAssetId, pmtAmt)]
  )
  (state, totalAmount)
}

# managerPublicKeyOrUnit
func m() = match mpk().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

# pendingManagerPublicKeyOrUnit
func pm() = match pmpk().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

let pd = "Permission denied".throw()

# mustManager
func mm(i: Invocation) = {
  match m() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

@Callable(i)
# ido, team, emission, staking, locking (boosting), rest
# fc - factoryContract
func constructor(fc: String) = {
  strict c = i.mm()

  [StringEntry(fc(), fc)]
}

@Callable(i)
func setManager(pendingManagerPublicKey: String) = {
  strict c = i.mm()
  strict cm = pendingManagerPublicKey.fromBase58String()

  [StringEntry(pmpk(), pendingManagerPublicKey)]
}

@Callable(i)
func confirmManager() = {
  let p = pm()
  strict hpm = p.isDefined() || throw("No pending manager")
  strict cpm = i.callerPublicKey == p.value() || throw("You are not pending manager")

  [
    StringEntry(mpk(), p.value().toBase58String()),
    DeleteEntry(pmpk())
  ]
}

# called by: LP
#
# purpose:
#    function used for entering the pool
# actions:
#    validate list:
#       1. tokens ratio is in correct range
#       2. slipage is not bigger that current tokens ratio
# arguments:
#    slippageTolerance  max allowed slippage
#    shouldAutoStake    perform LP staking immediatelly in case true otherwise transfer LP to user)
# attach:
#    attached should be two valid tokens from the available pools.
# return:
#    transfer LP tokens based on deposit share
@Callable(i)
func put(slip: Int, autoStake: Boolean) = {
    let factCfg = gfc()
    let stakingCntr = addressFromString(factCfg[idxFactStakCntr]).valueOrErrorMessage("Wr st addr")
    let slipCntr = addressFromString(factCfg[idxFactSlippCntr]).valueOrErrorMessage("Wr sl addr")
    if(slip < 0) then throw("Wrong slippage") else
    if (i.payments.size() != 2) then throw("2 pmnts expd") else
    # estPut
    let e = cp(i.caller.toString(),
                          i.transactionId.toBase58String(),
                          AttachedPayment(i.payments[0].value().assetId, i.payments[0].value().amount),
                          i.payments[1],
                          slip,
                          true,
                          false,
                          true,
                          0,
                          "")

    let emitLpAmt = e._2
    let lpAssetId = e._7
    let state     = e._9
    let amDiff    = e._10
    let prDiff    = e._11
    let amId      = e._12
    let prId      = e._13

    # emit lp on factory
    strict r = fca.invoke("emit", [emitLpAmt], [])
    # if the lp instance address is in the legacy list then the legacy factory address will be returned from the factory
    strict el = match (r) {
      case legacy: Address => legacy.invoke("emit", [emitLpAmt], [])
      case _ => unit
    }
    strict sa = if(amDiff > 0)      then slipCntr.invoke("put",[],[AttachedPayment(amId, amDiff)])        else []
    strict sp = if(prDiff > 0)      then slipCntr.invoke("put",[],[AttachedPayment(prId, prDiff)])        else []

    let lpTrnsfr =
      if(autoStake) then strict ss = stakingCntr.invoke("stake",[],[AttachedPayment(lpAssetId, emitLpAmt)]); []
      else [ScriptTransfer(i.caller, emitLpAmt, lpAssetId)]

    state++lpTrnsfr
}

# slippage in scale8
@Callable(i)
func putOneTkn(amAssetPart: Int, prAssetPart: Int, outLp: Int, slippage: Int, autoStake: Boolean) = {
    let cfg = gfc()
    #if(true) then throw("off") else
    let stakingCntr = addressFromString(cfg[idxFactStakCntr]).valueOrErrorMessage("Wr st addr")
    let slipCntr    = addressFromString(cfg[idxFactSlippCntr]).valueOrErrorMessage("Wr sl addr")
    let gwxCntr     = addressFromString(cfg[idxFactGwxRewCntr]).valueOrErrorMessage("Wr gwx addr")
    let poolCfg     = gpc()
    let amId        = poolCfg[idxAmAsId]
    let prId        = poolCfg[idxPrAsId]
    let amDcm       = poolCfg[idxAmtAsDcm].parseIntValue()
    let prDcm       = poolCfg[idxPriceAsDcm].parseIntValue()

    let addon       = this.getString(ada()).valueOrElse("")
    let userAddress = if(addon == i.caller.toString()) then i.originCaller else i.caller

    if(slippage <= 0 || amAssetPart<=0 || prAssetPart<=0 || outLp <= 0) then throw("Wrong params") else
    if (i.payments.size() != 1) then throw("1 pmnt expd") else

    let pmt         = i.payments[0].value()
    let pmtAssetId  = pmt.assetId.value().toBase58String()
    let paymentAmountRaw = pmt.amount
    let (pmtAmt, feeAmount) = paymentAmountRaw.takeFee()

    if (paymentAmountRaw < 10_000_000) then throw("Wrong pmt amt") else

    let amBalance = getAccBalance(amId)
    let prBalance = getAccBalance(prId)

    let (amBalanceNow, prBalanceNow, virtSwapInAm, virtSwapOutPr, virtSwapInPr, virtSwapOutAm) =
      if (pmtAssetId == amId) then {
        if (amBalance < paymentAmountRaw || pmtAmt < amAssetPart) then "invalid payment amount".throw() else
          (amBalance - paymentAmountRaw, prBalance, pmtAmt - amAssetPart, prAssetPart, 0, 0)
      } else if (pmtAssetId == prId) then {
        if (prBalance < paymentAmountRaw || pmtAmt < prAssetPart) then "invalid payment amount".throw() else
          (amBalance, prBalance - paymentAmountRaw, 0, 0, pmtAmt - prAssetPart, amAssetPart)
      } else throw("wrong pmtAssetId")

    let D0 = gwxCntr.invoke("calcD", [
                    amBalanceNow.toString(),
                    prBalanceNow.toString(),
                    A, Amult, Dconv],[])

    let D1 = gwxCntr.invoke("calcD", [
                    (amBalanceNow + virtSwapInAm - virtSwapOutAm).toBigInt().toString(),
                    (prBalanceNow + virtSwapInPr - virtSwapOutPr).toBigInt().toString(),
                    A, Amult, Dconv],[])

    strict D0vsD1 = vd(D1.str().parseBigIntValue(), D0.str().parseBigIntValue(), slippage4D)

    let estPut = cp(i.caller.toString(),
                          i.transactionId.toBase58String(),
                          AttachedPayment(amId.fromBase58String(), amAssetPart),
                          AttachedPayment(prId.fromBase58String(), prAssetPart),
                          slippage,
                          true,
                          true,
                          true,
                          pmtAmt,
                          pmtAssetId)

    let estimLP   = estPut._2
    let lpAssetId = estPut._7
    let state     = estPut._9
    let amDiff    = estPut._10
    let prDiff    = estPut._11

    let lpCalcRes = vad(estimLP.toBigInt(), outLp.toBigInt(), slippage.toBigInt())

    let emitLpAmt = lpCalcRes._2.toInt()

    # emit lp on factory
    strict e = fca.invoke("emit", [emitLpAmt], [])
    # if the lp instance address is in the legacy list then the legacy factory address will be returned from the factory
    strict el = match (e) {
      case legacy: Address => legacy.invoke("emit", [emitLpAmt], [])
      case _ => unit
    }
    strict sa = if(amDiff > 0)      then slipCntr.invoke("put",[],[AttachedPayment(amId.fromBase58String(), amDiff)])        else []
    strict sp = if(prDiff > 0)      then slipCntr.invoke("put",[],[AttachedPayment(prId.fromBase58String(), prDiff)])        else []

    let lpTrnsfr =
      if(autoStake) then strict ss = stakingCntr.invoke("stake",[],[AttachedPayment(lpAssetId, emitLpAmt)]); []
      else [ScriptTransfer(i.caller, emitLpAmt, lpAssetId)]
    
    let sendFeeToMatcher = if (feeAmount > 0) then [ScriptTransfer(feeCollectorAddress, feeAmount, pmtAssetId.fromBase58String())] else []

    state ++ lpTrnsfr ++ sendFeeToMatcher
}

# slippage in scale8
@Callable(i)
func putOneTknV2(minOutAmount: Int, autoStake: Boolean) = {
  if (i.payments.size() != 1) then throw("1 pmnt expd") else

  let poolConfig = gpc()
  let amId = poolConfig[idxAmAsId]
  let prId = poolConfig[idxPrAsId]
  let amDecimals = poolConfig[idxAmtAsDcm].parseIntValue()
  let prDecimals = poolConfig[idxPriceAsDcm].parseIntValue()

  let userAddress = if (i.caller == this) then i.originCaller else i.caller

  let pmt = i.payments[0].value()
  let pmtAssetId = pmt.assetId.value().toBase58String()
  let pmtAmt = pmt.amount
  
  if (pmtAmt < 10_000_000) then throw("Wrong pmt amt") else

  let r = estimatePutOneTknV2(pmtAmt, pmtAssetId, userAddress.toString(), i.transactionId.toBase58String())
  let estimLP   = r._2
  let lpAssetId = r._7
  let state     = r._9
  let amDiff    = r._10
  let prDiff    = r._11

  let emitLpAmt = if (minOutAmount > 0 && estimLP < minOutAmount) then {
    ["amount to receive is less than ", minOutAmount.toString()].makeString("").throw()
  } else estimLP

  # emit lp on factory
  strict e = fca.invoke("emit", [emitLpAmt], [])
  # if the lp instance address is in the legacy list then the legacy factory address will be returned from the factory
  strict el = match (e) {
    case legacy: Address => legacy.invoke("emit", [emitLpAmt], [])
    case _ => unit
  }
  strict sa = if(amDiff > 0)      then slipageContract.invoke("put",[],[AttachedPayment(amId.fromBase58String(), amDiff)])        else []
  strict sp = if(prDiff > 0)      then slipageContract.invoke("put",[],[AttachedPayment(prId.fromBase58String(), prDiff)])        else []

  let lpTrnsfr =
    if(autoStake) then strict ss = stakingContract.invoke("stake",[],[AttachedPayment(lpAssetId, emitLpAmt)]); []
    else [ScriptTransfer(i.caller, emitLpAmt, lpAssetId)]

  let feeAmount = pmtAmt.takeFee()._2
  let sendFeeToMatcher = if (feeAmount > 0) then [ScriptTransfer(feeCollectorAddress, feeAmount, pmtAssetId.fromBase58String())] else []

  (state ++ lpTrnsfr ++ sendFeeToMatcher, emitLpAmt)
}

@Callable(i)
func putOneTknV2READONLY(
  paymentAmount: Int,
  paymentAssetId: String
) = {
  let r = estimatePutOneTknV2(paymentAmount, paymentAssetId, "", "")
  let estimLP   = r._2
  let lpAssetId = r._7
  let state     = r._9
  let amDiff    = r._10
  let prDiff    = r._11

  ([], estimLP)
}

@Callable(i)
func putOneTknV2WithBonusREADONLY(
  paymentAmount: Int,
  paymentAssetId: String
) = {
  let poolConfig = gpc()
  let amId = poolConfig[idxAmAsId]
  let prId = poolConfig[idxPrAsId]

  let r = estimatePutOneTknV2(paymentAmount, paymentAssetId, "", "")
  let estimLP = r._2
  let curPrice = r._3
  let lpAssetEmission = r._6
  let lpAssetId = r._7
  # let amBalance = r._4
  # let prBalance = r._5

  let amBalance = amId.getAccBalance()
  let prBalance = prId.getAccBalance()
  let poolProportion = prBalance.fraction(scale8, amBalance)
  let amountAssetPart = fraction(paymentAmount, scale8, poolProportion + scale8)
  let priceAssetPart = paymentAmount - amountAssetPart

  let lpAmtBoth = fraction(lpAssetEmission, priceAssetPart, prBalance)
  
  let bonus = fraction(estimLP - lpAmtBoth, scale8, lpAmtBoth)
  let feeAmount = paymentAmount.takeFee()._2

  ([], (estimLP, feeAmount, bonus))
}

# Put without LP emission
@Callable(i)
func putForFree(maxSlpg: Int) = {
  if(maxSlpg < 0) then throw("Wrong slpg") else
  if (i.payments.size() != 2) then throw("2 pmnts expd") else
    let estPut = cp(i.caller.toString(),
                          i.transactionId.toBase58String(),
                          AttachedPayment(i.payments[0].value().assetId, i.payments[0].value().amount),
                          i.payments[1],
                          maxSlpg,
                          false,
                          false,
                          true,
                          0,
                          "")
    estPut._9
}

# Called by: LP
#
# purpose:
#    function used for exit from pool partially or fully
# actions:
# arguments:
# attach:
#    attached should be corresponding pool LP token
# validate list:
# return:
#    transfer to user his share of pool tokens base on passed lp token amount
@Callable(i)
func get() = {
  let r = cg(i)
  let outAmtAmt    = r._1
  let outPrAmt     = r._2
  let pmtAmt       = r._3
  let pmtAssetId   = r._4
  let state        = r._5
  strict b = invoke(fca,
                    "burn",
                    [pmtAmt],
                    [AttachedPayment(pmtAssetId, pmtAmt)])
  state
}

@Callable(i)
func getOneTkn(exchResult: Int, notUsed: Int, outAmount: Int, outAssetId: String, slippage: Int) = {
  if (i.payments.size() != 1) then throw("1 pmnt expd") else
  #if(true) then throw("off") else
  let cfg         = gpc()
  let lpId        = cfg[idxLPAsId]
  let amId        = cfg[idxAmAsId]
  let prId        = cfg[idxPrAsId]
  let amDcm       = cfg[idxAmtAsDcm].parseIntValue()
  let prDcm       = cfg[idxPriceAsDcm].parseIntValue()
  let sts         = cfg[idxPoolSt]

  let factCfg     = gfc()
  let gwxCntr     = addressFromString(factCfg[idxFactGwxRewCntr]).valueOrErrorMessage("Wr sl addr")

  let pmt         = i.payments[0].value()

  # todo: addon is a separate contract with unstake and get on tkn operation, should me merged with this contract once max script size is increased
  let addon       = this.getString(ada()).valueOrElse("")
  let userAddress = if(addon == i.caller.toString()) then i.originCaller else i.caller
  let txId58      = i.transactionId.toBase58String()
  let pmtAssetId  = pmt.assetId.value()
  let pmtAmt      = pmt.amount

  if(pmtAmt < 10_00_000_000) then throw("Min pmt 10 LP") else

  if(slippage < 0 || exchResult < 0 || outAmount < 0) then throw("Wrong params") else
  if (lpId != pmtAssetId.toBase58String()) then throw("Wrong LP") else

  let r = ego(i.transactionId.toBase58String(), pmtAssetId.toBase58String(), pmtAmt, i.caller)
  let estimAmAmt    = r._1
  let estimPrAmt    = r._2

  let amBalance = getAccBalance(amId)
  let prBalance = getAccBalance(prId)

  let (amBalanceNow, prBalanceNow, virtSwapInAm, virtSwapOutPr, virtSwapInPr, virtSwapOutAm, totalGetRaw) =
        if (outAssetId == amId) then {
          (amBalance - estimAmAmt, prBalance - estimPrAmt, exchResult, estimPrAmt, 0, 0, estimAmAmt + exchResult)
        } else if (outAssetId == prId) then {
          (amBalance - estimAmAmt, prBalance - estimPrAmt, 0, 0, exchResult, estimAmAmt,  estimPrAmt + exchResult)
        } else throw("wrong outAssetId")

  if(virtSwapInAm < 0 || virtSwapInPr < 0) then throw("Wrong calc") else

  let D0 = gwxCntr.invoke("calcD", [
                                        amBalanceNow.toString(),
                                        prBalanceNow.toString(), A, Amult, Dconv],[]);

  let D1 = gwxCntr.invoke("calcD", [
                                        (amBalanceNow - virtSwapInAm + virtSwapOutAm).toString(),
                                        (prBalanceNow + virtSwapOutPr - virtSwapInPr).toString(), A, Amult, Dconv],[]);

  strict D0vsD1 = vd(D1.str().parseBigIntValue(), D0.str().parseBigIntValue(), slippage4D)

  let totalGet = totalGetRaw.takeFee()._1
  strict finalRes = vad(totalGet.toBigInt(), outAmount.toBigInt(), slippage.toBigInt())

  let (outAm, outPr)  = if(outAssetId == amId) then (finalRes._2.toInt(), 0) else (0, finalRes._2.toInt())
  let totalAmount = outAm + outPr
  let feeAmount = totalGetRaw - totalGet

  let outAssetIdOrWaves = if (outAssetId == "WAVES") then unit else outAssetId.fromBase58String()

  let sendFeeToMatcher = if (feeAmount > 0) then [ScriptTransfer(feeCollectorAddress, feeAmount, outAssetIdOrWaves)] else []

  let curPrX18 = cpbi(prBalance.t1(prDcm), amBalance.t1(amDcm))
  let curPr = curPrX18.f1(scale8)

  strict state =
  [
    ScriptTransfer(userAddress, totalAmount, outAssetIdOrWaves),
    StringEntry(
          gau(userAddress.toString(), txId58),
          dataGetActionInfo(outAm, outPr, pmtAmt, curPr, height, lastBlock.timestamp)),
    IntegerEntry(pl(), curPr),
    IntegerEntry(ph(height, lastBlock.timestamp), curPr)
  ]

  strict burn = invoke(fca,
                                  "burn",
                                  [pmtAmt],
                                  [AttachedPayment(pmtAssetId, pmtAmt)])
  state ++ sendFeeToMatcher
}

@Callable(i)
func getOneTknV2(outAssetId: String, minOutAmount: Int) = {
  let (state, totalAmount) = getOneTknV2Internal(
    outAssetId,
    minOutAmount,
    i.payments,
    i.caller,
    i.originCaller,
    i.transactionId
  )

  (state, totalAmount)
}

@Callable(i)
func getOneTknV2READONLY(
  outAssetId: String,
  lpAssetAmount: Int
) = {
  let poolConfig = gpc()
  let lpId = poolConfig[idxLPAsId]
  let amId = poolConfig[idxAmAsId]
  let prId = poolConfig[idxPrAsId]
  let r = ego("", lpId, lpAssetAmount, this)
  let estimAmAmt = r._1
  let estimPrAmt = r._2

  let amBalance = amId.getAccBalance()
  let prBalance = prId.getAccBalance()

  let amBalanceNow = amBalance - estimAmAmt
  let prBalanceNow = prBalance - estimPrAmt

  let (amountBalanceForSwap, priceBalanceForSwap, amountToSwap, amountToAdd) =
    if (outAssetId == amId) then {
      (prBalanceNow, amBalanceNow, estimPrAmt, estimAmAmt)
    } else if (outAssetId == prId) then {
      (amBalanceNow, prBalanceNow, estimAmAmt, estimPrAmt)
    } else throw("wrong outAssetId")

  let yPrecision = 1
  let exchResult = gwxContract.invoke("calcSwapXToY", [
    amountToSwap.toString(), # amountAssetAmountBigIntStr
    amountBalanceForSwap.toString(), # amountAssetBalanceBigIntStr
    priceBalanceForSwap.toString(), # priceAssetBalanceBigIntStr
    "", # dBigIntStr
    A, # amplificatorBigIntStr
    Amult, # amplificatorPrecisionBigIntStr
    yPrecision.toString(), # targetXPrecisionBigIntStr
    Dconv # targetDPrecisionBigIntStr
  ], []).exactAs[Int]

  let totalGetRaw = exchResult + amountToAdd
  let (totalGet, feeAmount) = totalGetRaw.takeFee()

  ([], (totalGet, feeAmount, estimAmAmt, estimPrAmt, amountToSwap, exchResult))
}

@Callable(i)
func getOneTknV2WithBonusREADONLY(
  outAssetId: String,
  lpAssetAmount: Int
) = {
  let poolConfig = gpc()
  let amId = poolConfig[idxAmAsId]
  let prId = poolConfig[idxPrAsId]
  let lpId = poolConfig[idxLPAsId]

  let amBalance = amId.getAccBalance()
  let prBalance = prId.getAccBalance()

  let (totalGet, feeAmount) = this.invoke("getOneTknV2READONLY", [outAssetId, lpAssetAmount], []).exactAs[(Int, Int)]

  let r = ego(
    "",
    lpId,
    lpAssetAmount,
    this
  )

  let outAmAmt = r._1
  let outPrAmt = r._2
  let sumOfGetAssets = outAmAmt + outPrAmt
  
  let bonus = fraction((totalGet - sumOfGetAssets), scale8, sumOfGetAssets)

  ([], (totalGet, feeAmount, bonus))
}

@Callable(i)
func getNoLess(noLessThenAmtAsset: Int, noLessThenPriceAsset: Int) = {
  let r = cg(i)
  let outAmAmt    = r._1
  let outPrAmt    = r._2
  let pmtAmt      = r._3
  let pmtAssetId  = r._4
  let state       = r._5
  if (outAmAmt < noLessThenAmtAsset) then throw("Failed:  " + outAmAmt.toString() + " < " + noLessThenAmtAsset.toString()) else
  if (outPrAmt < noLessThenPriceAsset) then throw("Failed: " + outPrAmt.toString() + " < " + noLessThenPriceAsset.toString()) else

  strict burnLPAssetOnFactory = invoke(fca,
                                  "burn",
                                  [pmtAmt],
                                  [AttachedPayment(pmtAssetId, pmtAmt)])
  state
}

# Unstake LP tokens and exit from pool
@Callable(i)
func unstakeAndGet(amount: Int) = {
  strict checkPayments = if (i.payments.size() != 0) then throw("No pmnts expd") else true

  let cfg = gpc()
  let factoryCfg = gfc()

  let lpAssetId = cfg[idxLPAsId].fromBase58String()
  let staking = factoryCfg[idxFactStakCntr].addressFromString().valueOrErrorMessage("Wr st addr")

  # negative amount will not pass
  strict unstakeInv = staking.invoke("unstake", [lpAssetId.toBase58String(), amount], [])

  let r = ego(i.transactionId.toBase58String(), lpAssetId.toBase58String(), amount, i.caller)
  let sts = r._9.parseIntValue()
  let state = r._10

  strict v = if (igs() || sts == PoolShutdown) then throw("Blocked: " + sts.toString()) else true

  strict burnA = invoke(fca, "burn", [amount], [AttachedPayment(lpAssetId, amount)])

  state
}

@Callable(i)
func unstakeAndGetOneTkn(unstakeAmount: Int, outAssetId: String, minOutAmount: Int) = {
  strict checkPayments = if (i.payments.size() != 0) then throw("No pmnts expd") else true

  let cfg = gpc()
  let factoryCfg = gfc()

  let lpAssetId = cfg[idxLPAsId].fromBase58String()
  let staking = factoryCfg[idxFactStakCntr].addressFromString().valueOrErrorMessage("Wr st addr")

  strict unstakeInv = staking.invoke("unstake", [lpAssetId.toBase58String(), unstakeAmount], [])
  let (state, totalAmount) = getOneTknV2Internal(
    outAssetId,
    minOutAmount,
    [AttachedPayment(lpAssetId, unstakeAmount)],
    i.caller,
    i.originCaller,
    i.transactionId
  )

  (state, totalAmount)
}

# purpose:
#    used BY FACTORY for activating new LP pool. Validate it was called only once.
# actions:
#    1. issue new LP token and save data in state
#    2. burn LP token
#    3. write initial price, that is used for first deposit
# arguments:
# attach:
# return:
@Callable(i)
func activate(amtAsStr: String, prAsStr: String) = {
    if (i.caller.toString() != fca.toString()) then throw("denied") else {
        ([
            StringEntry(aa(),amtAsStr),
            StringEntry(pa(),prAsStr)
            ],
        "success")
    }
}

# Set string from addon
@Callable(i)
func setS(k: String, v: String) = {
  if (i.caller.toString() != this.strf(ada())) then pd else

  [
    StringEntry(k, v)
  ]
}

# Set integer from addon
@Callable(i)
func setI(k: String, v: Int) = {
  if (i.caller.toString() != this.strf(ada())) then pd else

  [
    IntegerEntry(k, v)
  ]
}

# API wrappers
@Callable(i)
func getPoolConfigWrapperREADONLY() = {
  (
    [],
    gpc()
  )
}

@Callable(i)
func getAccBalanceWrapperREADONLY(assetId: String) = {
  (
    [],
    assetId.getAccBalance()
  )
}

@Callable(i)
func calcPricesWrapperREADONLY(amAmt: Int, prAmt: Int, lpAmt: Int) = {
  let pr = calcPrices(amAmt, prAmt, lpAmt)
  (
    [],
    [
      pr[0].toString(),
      pr[1].toString(),
      pr[2].toString()
    ]
  )
}

@Callable(i)
func fromX18WrapperREADONLY(val: String, resScaleMult: Int) = {
  (
    [],
    f1(val.parseBigIntValue(), resScaleMult)
  )
}

@Callable(i)
func toX18WrapperREADONLY(origVal: Int, origScaleMult: Int) = {
  (
    [],
    t1(origVal, origScaleMult).toString()
  )
}

@Callable(i)
func calcPriceBigIntWrapperREADONLY(prAmtX18: String, amAmtX18: String) = {
  (
    [],
    cpbi(prAmtX18.parseBigIntValue(), amAmtX18.parseBigIntValue()).toString()
  )
}

@Callable(i)
func estimatePutOperationWrapperREADONLY(
  txId58: String,
  slippage: Int,
  inAmAmt: Int,
  inAmId: ByteVector,
  inPrAmt: Int,
  inPrId: ByteVector,
  usrAddr: String,
  isEval: Boolean,
  emitLp: Boolean
) = {
  (
    [],
    epo(
      txId58,
      slippage,
      inAmAmt,
      inAmId,
      inPrAmt,
      inPrId,
      usrAddr,
      isEval,
      emitLp,
      true,
      false,
      0,
      ""
    )
  )
}

@Callable(i)
func estimateGetOperationWrapperREADONLY(txId58: String, pmtAsId: String, pmtLpAmt: Int, usrAddr: String) = {
  let r = ego(
    txId58,
    pmtAsId,
    pmtLpAmt,
    usrAddr.addressFromStringValue()
  )
  (
    [],
    (r._1, r._2, r._3, r._4, r._5, r._6, r._7, r._8.toString(), r._9, r._10)
  )
}

@Callable(i)
func getFeeREADONLY() = {
  ([], fee)
}

@Verifier(tx)
func verify() = {
  let targetPublicKey = match m() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }

  match tx {
    case order: Order =>
      let matcherPub    = mp()
      let orderValid    = moa(order)
      let senderValid   = sigVerify(order.bodyBytes, order.proofs[0], order.senderPublicKey)
      let matcherValid  = sigVerify(order.bodyBytes, order.proofs[1], matcherPub)

      (orderValid && senderValid && matcherValid) || toe(orderValid, senderValid, matcherValid)
    case s: SetScriptTransaction =>
      let newHash = s.script.value().blake2b256()
      let allowedHash = fca.getString(keyAllowedLpStableScriptHash()).value().fromBase64String()
      let currentHash = this.scriptHash()
      if (allowedHash == newHash && currentHash != newHash) then {
        true
      } else {
        sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
      }
    case _ => {
      sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
    }
  }
}
