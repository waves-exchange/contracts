{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}


let separator = "__"
let MULT8 = 100000000

func wrapErr(msg: String) = ["voting_verified_v2.ride:", msg].makeString(" ")
func throwErr(msg: String) = msg.wrapErr().throw()

func asInt(val: Any) = {
  match val {
    case valInt: Int => valInt
    case _ => throw("Failed to cast into Integer")
  }
}

func getIntegerOrZero(address:Address, key: String) = address.getInteger(key).valueOrElse(0)
func getIntegerOrFail(
  address:Address,
  key: String
) = address.getInteger(key).valueOrErrorMessage(wrapErr(key + " is not defined"))
func getStringOrEmpty(address:Address, key: String) = address.getString(key).valueOrElse("")
func getStringOrFail(
  address:Address,
  key: String
) = address.getString(key).valueOrErrorMessage(wrapErr(key + " is not defined"))

let keyBoostingContract = ["%s", "boostingContract"].makeString(separator)
let keyEmissionContract = ["%s", "emissionContract"].makeString(separator)
let keyAssetsStoreContract = ["%s", "assetsStoreContract"].makeString(separator)

let boostingContract = keyBoostingContract.getStringValue().addressFromStringValue()
let emissionContract = keyEmissionContract.getStringValue().addressFromStringValue()
let assetsStoreContract = keyAssetsStoreContract.getStringValue().addressFromStringValue()

# Emission keys
let keyEmissionConfig = ["%s", "config"].makeString(separator)
let wxAssetIdStr = emissionContract.getStringOrFail(keyEmissionConfig).split(separator)[1]
let wxAssetId = wxAssetIdStr.fromBase58String()
# Emission keys

let keyVotingThresholdAdd = ["%s%s", "votingThreshold", "add"].makeString(separator)
let keyVotingThresholdRemove = ["%s%s", "votingThreshold", "remove"].makeString(separator)

func keyPeriodLengthAdd(
  assetId: String,
  index: Int
) = ["%s%s%d", "periodLengthAdd", assetId, index.toString()].makeString(separator)
let keyPeriodLengthRemove = ["%s", "periodLengthRemove"].makeString(separator)

func keyCurrentVotingHeightStart(
  assetId: String,
  index: Int
) = ["%s%s%d", "currentVotingHeightStart", assetId, index.toString()].makeString(separator)

func keyVerified(assetId: String) = ["%s%s", "verified", assetId].makeString(separator)
func keyVerificationInProgress(
  assetId: String
) = ["%s%s%s", "verification", "inProgress", assetId].makeString(separator)
func keyDeverificationInProgress(
  assetId: String
) = ["%s%s%s", "deverification", "inProgress", assetId].makeString(separator)

let keyMaxPeriodLength = ["%s", "maxPeriodLength"].makeString(separator)
let keyMinPeriodLength = ["%s", "minPeriodLength"].makeString(separator)

func keyVotingRewardAssetId(
  assetId: String,
  index: Int
) = ["%s%s%d", "votingRewardAssetId", assetId, index.toString()].makeString(separator)
func keyTotalVotingReward(assetId: String, index: Int) = {
  ["%s%s%d", "votingReward", assetId, index.toString()].makeString(separator)
}

let keyFinalizeCallRewardAmount = ["%s", "finalizeCallRewardAmount"].makeString(separator)

let keyMinSuggestRemoveBalance = ["%s", "minSuggestRemoveBalance"].makeString(separator)

func keyCurrentIndex(assetId: String) = ["%s%s", "currentIndex", assetId].makeString(separator)

func keyVote(
  assetId: String,
  index: Int,
  caller: Address
) = ["%s%s%d%s", "vote", assetId, index.toString(), caller.toString()].makeString(separator)
func voteValue(
  inFavor: Boolean,
  gwxAmount: Int
) = ["%s%d", inFavor.toString(), gwxAmount.toString()].makeString(separator)
func keyVotingResult(
  assetId: String,
  index: Int
) = ["%s%s%d", "votingResult", assetId, index.toString()].makeString(separator)
func votingValue(
  forAmount: Int,
  againstAmount: Int
) = ["%d%d", forAmount.toString(), againstAmount.toString()].makeString(separator)
let defaultVotingValue = ["%d%d", "0", "0"].makeString(separator)

func keySuggestIssuer(
  assetId: String,
  index: Int
) = ["%s%s%d", "suggestIssuer", assetId, index.toString()].makeString(separator)

func keyClaimHistory(
  userAddress: Address,
  assetId: String,
  index: Int
) = ["%s%s%s%d", "history", userAddress.toString(), assetId, index.toString()].makeString(separator)
func claimHistoryValue(
  gwxAmount: Int
) = ["%d%s", gwxAmount.toString()].makeString(separator)

func keyVotingEndHeight(
  assetId: String,
  index: Int
) = ["%s%s%d", "votingEndHeight", assetId, index.toString()].makeString(separator)

let keyFeePerBlock = ["%s", "feePerBlock"].makeString(separator)
let feePerBlock = this.getIntegerOrFail(keyFeePerBlock)

let keyMinWxMinForSuggestAddAmountRequired = ["%s", "wxMinForSuggestAddAmountRequired"].makeString(separator)
let keyWxForSuggestRemoveAmountRequired = ["%s", "wxForSuggestRemoveAmountRequired"].makeString(separator)

func getUserGwxAmountAtHeight(userAddress: String, targetHeight: Int) = {
  let gwxAmount = boostingContract.invoke("getUserGwxAmountAtHeightREADONLY", [userAddress, targetHeight], [])

  gwxAmount.asInt()
}

# Manager keys and functions ->
func keyManagerVaultAddress() = "%s__managerVaultAddress"
func keyManagerPublicKey() = "%s__managerPublicKey"

func getManagerVaultAddressOrThis() = {
  match keyManagerVaultAddress().getString() {
    case s:String => s.addressFromStringValue()
    case _=> this
  }
}

func managerPublicKeyOrUnit() = {
  let managerVaultAddress = getManagerVaultAddressOrThis()
  match managerVaultAddress.getString(keyManagerPublicKey()) {
    case s: String => s.fromBase58String()
    case _: Unit => unit
  }
}
# <-

func votingExistChecks(assetId: String, currentIndex: Int) = {
  let verificationInProgress = keyVerificationInProgress(assetId).getBoolean().valueOrElse(false)
  let deverificationInProgress = keyDeverificationInProgress(assetId).getBoolean().valueOrElse(false)

  let suggestIssuer = keySuggestIssuer(assetId, currentIndex).getString().valueOrErrorMessage(
    wrapErr("voting issuer not found")
  )

  let currentVotingHeightStart = keyCurrentVotingHeightStart(assetId, currentIndex).getInteger().valueOrErrorMessage(
    wrapErr("voting start height not found")
  )

  let votingPeriodLenght = if verificationInProgress then {
    keyPeriodLengthAdd(assetId, currentIndex).getInteger().valueOrErrorMessage(
      wrapErr("voting period length not found")
    )
  } else {
    keyPeriodLengthRemove.getInteger().value()
  }

  strict checks = [
    verificationInProgress || deverificationInProgress || "no voting in progress".throwErr(),
    currentVotingHeightStart + votingPeriodLenght > height || "voting expired".throwErr()
  ]

  (
    verificationInProgress,
    deverificationInProgress,
    currentVotingHeightStart,
    votingPeriodLenght,
    suggestIssuer
  )
}

func calculateReward(voter: Address, assetId: String, index: Int) = {
  let voteKey = keyVote(assetId, index, voter)
  let lastVote = voteKey.getString().valueOrErrorMessage(wrapErr("you have not voted"))

  let lastVoteParts = lastVote.split(separator)
  let inFavor = lastVoteParts[1]
  let rewardAmount = if inFavor == "true" then {
    let gwxAmount = lastVoteParts[2].parseIntValue()

    let lastVotingValue = keyVotingResult(assetId, index).getString().valueOrErrorMessage(
      wrapErr("voting does not exist")
    )
    let lastVotingValueParts = lastVotingValue.split(separator)
    let totalVotesFor = lastVotingValueParts[1].parseIntValue()

    let partOfTheTotalVotesX8 = fraction(gwxAmount, MULT8, totalVotesFor)
    let totalVotingReward = keyTotalVotingReward(assetId, index).getInteger().valueOrElse(0)
    let rewardAmount = fraction(partOfTheTotalVotesX8, totalVotingReward, MULT8, FLOOR)

    rewardAmount
  } else {
    0
  }

  rewardAmount
}

@Callable(i)
func suggestAdd(assetId: String, periodLength: Int, assetImage: String) = {
  strict info = assetId.fromBase58String().assetInfo().valueOrErrorMessage("Invalid asset ID")

  let currentIndexKey = keyCurrentIndex(assetId)
  let currentIndex = currentIndexKey.getInteger()
  let newIndex = if currentIndex.isDefined() then {
    currentIndex.value() + 1
  } else {
    0
  }

  let wxPayment = i.payments[0]
  let wxPaymentAssetId = wxPayment.assetId.value()
  let wxPaymentAmount = wxPayment.amount.value()

  let votingRewardActions = if i.payments.size() > 1 then {
    let votingRewardPayment = i.payments[1]
    let votingRewardPaymentAssetId = votingRewardPayment.assetId.value().toBase58String()
    let votingRewardPaymentAmount = votingRewardPayment.amount.value()

    [
      StringEntry(keyVotingRewardAssetId(assetId, newIndex), votingRewardPaymentAssetId),
      IntegerEntry(keyTotalVotingReward(assetId, newIndex), votingRewardPaymentAmount)
    ]
  } else {
    []
  }

  let minPeriodLength = keyMinPeriodLength.getIntegerValue()
  let maxPeriodLength = keyMaxPeriodLength.getIntegerValue()

  strict checks = [
    periodLength >= minPeriodLength && periodLength <= maxPeriodLength || "invalid periodLength".throwErr(),
    keyVerified(assetId).getBoolean() == unit || "already verified".throwErr(),
    keyVerificationInProgress(assetId).getBoolean() == unit || "already in progress".throwErr(),
    wxPaymentAmount > periodLength * feePerBlock || "not enough wx for given period".throwErr(),
    wxPaymentAmount >= keyMinWxMinForSuggestAddAmountRequired.getIntegerValue() ||
      "payment less then min for suggest".throwErr()
  ]

  strict assetsStoreCreateOrUpdateInv = assetsStoreContract.invoke("createOrUpdate", [assetId, assetImage, false], [])

  let votingEndHeight = height + periodLength

  let finalizeCallRewardAmount = keyFinalizeCallRewardAmount.getInteger().valueOrElse(0)
  let burnWxAmount = wxPaymentAmount - finalizeCallRewardAmount

  [
    IntegerEntry(currentIndexKey, newIndex),
    BooleanEntry(keyVerificationInProgress(assetId), true),
    IntegerEntry(keyCurrentVotingHeightStart(assetId, newIndex), height),
    IntegerEntry(keyPeriodLengthAdd(assetId, newIndex), periodLength),
    StringEntry(keySuggestIssuer(assetId, newIndex), i.caller.toString()),
    IntegerEntry(keyVotingEndHeight(assetId, newIndex), votingEndHeight),
    Burn(wxPaymentAssetId, burnWxAmount)
  ] ++ votingRewardActions
}

@Callable(i)
func suggestRemove(assetId: String) = {
  let gwxAmountAtNow = i.caller.toString().getUserGwxAmountAtHeight(height)
  let minSuggestRemoveBalance = keyMinSuggestRemoveBalance.getIntegerValue()

  let wxPayment = i.payments[0]
  let wxPaymentAssetId = wxPayment.assetId.value()
  let wxPaymentAmount = wxPayment.amount.value()

  let isVerified = keyVerified(assetId).getBoolean().valueOrElse(false)

  strict checks = [
    isVerified || [assetId, "not verified"].makeString(" ").throwErr(),
    gwxAmountAtNow >= minSuggestRemoveBalance || "not enough gWXes".throwErr(),
    wxPaymentAmount >= keyWxForSuggestRemoveAmountRequired.getIntegerValue() ||
      "payment less then min for suggest".throwErr()
  ]

  let currentIndexKey = keyCurrentIndex(assetId)
  let currentIndex = currentIndexKey.getInteger()
  let newIndex = if currentIndex.isDefined() then {
    currentIndex.value() + 1
  } else {
    0
  }

  let periodLength = keyPeriodLengthRemove.getInteger().valueOrErrorMessage(
    wrapErr("periodLengthRemove not set")
  )
  let votingEndHeight = height + periodLength

  [ 
    IntegerEntry(currentIndexKey, newIndex),
    BooleanEntry(keyDeverificationInProgress(assetId), true),
    IntegerEntry(keyCurrentVotingHeightStart(assetId, newIndex), height),
    StringEntry(keySuggestIssuer(assetId, newIndex), i.caller.toString()),
    IntegerEntry(keyVotingEndHeight(assetId, newIndex), votingEndHeight)
  ]
}

@Callable(i)
func vote(assetId: String, inFavor: Boolean) = {
  let currentIndexKey = keyCurrentIndex(assetId)
  let currentIndex = currentIndexKey.getInteger().valueOrErrorMessage(wrapErr("voting does not exist"))

  strict votingInfo = votingExistChecks(assetId, currentIndex)
  let currentVotingHeightStart = votingInfo._3
  let votingPeriodLenght = votingInfo._4

  let gwxAmountAtEnd = i.caller.toString().getUserGwxAmountAtHeight(currentVotingHeightStart + votingPeriodLenght)

  let voteKey = keyVote(assetId, currentIndex, i.caller)
  let votingResultKey = keyVotingResult(assetId, currentIndex)

  strict checks = [
    voteKey.getString() == unit || "You have already voted".throwErr(),
    gwxAmountAtEnd > 0 || "You'll not have gWX at the end of voting".throw()
  ]

  let lastVotingValue = votingResultKey.getString().valueOrElse(defaultVotingValue)
  let lastVotingValueParts = lastVotingValue.split(separator)

  let newVotingValue = if inFavor then {
    votingValue(
      lastVotingValueParts[1].parseIntValue() + gwxAmountAtEnd,
      lastVotingValueParts[2].parseIntValue()
    )
  } else {
    votingValue(
      lastVotingValueParts[1].parseIntValue(),
      lastVotingValueParts[2].parseIntValue() + gwxAmountAtEnd
    )
  }

  [
    StringEntry(voteKey, voteValue(inFavor, gwxAmountAtEnd)),
    StringEntry(votingResultKey, newVotingValue)
  ]
}

@Callable(i)
func cancelVote(assetId: String) = {
  let currentIndexKey = keyCurrentIndex(assetId)
  let currentIndex = currentIndexKey.getInteger().valueOrErrorMessage(wrapErr("voting does not exist"))

  let voteKey = keyVote(assetId, currentIndex, i.caller)
  let votingResultKey = keyVotingResult(assetId, currentIndex)

  let lastVote = voteKey.getString().valueOrErrorMessage(wrapErr("you have not voted"))
  let lastVoteParts = lastVote.split(separator)
  let inFavor = lastVoteParts[1]
  let gwxAmount = lastVoteParts[2].parseIntValue()

  strict votingInfo = votingExistChecks(assetId, currentIndex)
  strict checks = [
    inFavor == "true" || inFavor == "false" || "invalid vote".throwErr()
  ]

  let lastVotingValue = votingResultKey.getString().valueOrElse(defaultVotingValue)
  let lastVotingValueParts = lastVotingValue.split(separator)

  let newVotingResultValue = if inFavor == "true" then {
    votingValue(
      lastVotingValueParts[1].parseIntValue() - gwxAmount,
      lastVotingValueParts[2].parseIntValue()
    )
  } else {
    votingValue(
      lastVotingValueParts[1].parseIntValue(),
      lastVotingValueParts[2].parseIntValue() - gwxAmount
    )
  }

  [
    DeleteEntry(voteKey),
    StringEntry(votingResultKey, newVotingResultValue)
  ]
}

@Callable(i)
func finalize(assetId: String) = {
  let verificationInProgress = keyVerificationInProgress(assetId).getBoolean().valueOrElse(false)
  let deverificationInProgress = keyDeverificationInProgress(assetId).getBoolean().valueOrElse(false)

  let currentIndexKey = keyCurrentIndex(assetId)
  let currentIndex = currentIndexKey.getInteger().valueOrElse(0)

  let votingThresholdAdd = keyVotingThresholdAdd.getInteger().valueOrErrorMessage(
    wrapErr("votingThresholdAdd not set")
  )
  let votingThresholdRemove = keyVotingThresholdRemove.getInteger().valueOrErrorMessage(
    wrapErr("votingThresholdRemove not set")
  )

  let (finalizeVotingActions, verified, threshold) = if verificationInProgress then {
    (
      [
        DeleteEntry(keyVerificationInProgress(assetId)),
        BooleanEntry(keyVerified(assetId),true)
      ],
      true,
      votingThresholdAdd
    )
  } else {
    (
      [
        DeleteEntry(keyDeverificationInProgress(assetId)),
        DeleteEntry(keyVerified(assetId))
      ],
      true,
      votingThresholdRemove
    )
  }

  let lastVotingValue = keyVotingResult(assetId, currentIndex).getString().valueOrElse(defaultVotingValue)
  let lastVotingValueParts = lastVotingValue.split(separator)
  let votesFor = lastVotingValueParts[1].parseIntValue()
  let votesAgainst = lastVotingValueParts[2].parseIntValue()
  let votesTotal = votesFor + votesAgainst

  let votingEndHeight = keyVotingEndHeight(assetId, currentIndex).getInteger().valueOrErrorMessage(
    wrapErr("voting end height not found")
  )

  strict checks = [
    verificationInProgress || deverificationInProgress || "nothing to finalize".throwErr(),
    votingEndHeight <= height || "voting not finished".throwErr(),
    votesTotal >= threshold || "not enough votes".throwErr()
  ]

  let finalizeCallRewardAction = if votesFor < votesAgainst then {
    strict setVerifiedInvoke = assetsStoreContract.invoke("setVerified", [assetId, verified], [])

    let finalizeCallRewardAmount = keyFinalizeCallRewardAmount.getInteger().valueOrElse(0)
    [ScriptTransfer(i.caller, finalizeCallRewardAmount, wxAssetId)]
  } else {
    []
  }

  finalizeVotingActions ++ finalizeCallRewardAction
}

@Callable(i)
func claimREADONLY(assetId: String, index: Int) = {
  let callerAddress = i.caller
  let votingRewardAssetIdStr = keyVotingRewardAssetId(assetId, index).getString()

  let rewardAmount = if votingRewardAssetIdStr.isDefined() then {
    calculateReward(callerAddress, assetId, index)
  } else {
    0
  }

  (nil, rewardAmount)
}

@Callable(i)
func claim(assetId: String, index: Int) = {
  let callerAddress = i.caller

  let claimHistoryKey = keyClaimHistory(callerAddress, assetId, index)
  let claimHistory = claimHistoryKey.getString()

  strict checks = [
    claimHistory == unit || "already claimed".throwErr()
  ]

  let rewardAmount = if calculateReward(callerAddress, assetId, index) > 0 then {
    calculateReward(callerAddress, assetId, index)
  } else {
    "nothing to claim".throwErr()
  }

  let votingRewardAssetIdStr = keyVotingRewardAssetId(assetId, index).getString()

  let rewardAction = if votingRewardAssetIdStr.isDefined() then {
    let votingRewardAssetId = votingRewardAssetIdStr.value().fromBase58String()

    [
      ScriptTransfer(callerAddress, rewardAmount, votingRewardAssetId),
      StringEntry(claimHistoryKey, claimHistoryValue(rewardAmount))
    ]
  } else {
    "nothing to claim".throwErr()
  }

  rewardAction
}

@Verifier(tx)
func verify() = {
  let targetPublicKey = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
}
