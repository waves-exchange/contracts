{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}


let separator = "__"
let MULT8 = 100000000

func wrapErr(msg: String) = ["voting_verified_v2.ride:", msg].makeString(" ")
func throwErr(msg: String) = msg.wrapErr().throw()

func asInt(val: Any) = {
  match val {
    case valInt: Int => valInt
    case _ => throw("Failed to cast into Integer")
  }
}

func getIntegerOrZero(address:Address, key: String) = address.getInteger(key).valueOrElse(0)
func getIntegerOrFail(
  address:Address,
  key: String
) = address.getInteger(key).valueOrErrorMessage(wrapErr(key + " is not defined"))
func getStringOrEmpty(address:Address, key: String) = address.getString(key).valueOrElse("")
func getStringOrFail(
  address:Address,
  key: String
) = address.getString(key).valueOrErrorMessage(wrapErr(key + " is not defined"))

let keyBoostingContract = ["%s", "boostingContract"].makeString(separator)
let keyEmissionContract = ["%s", "emissionContract"].makeString(separator)
let keyAssetsStoreContract = ["%s", "assetsStoreContract"].makeString(separator)

let boostingContract = keyBoostingContract.getStringValue().addressFromStringValue()
let emissionContract = keyEmissionContract.getStringValue().addressFromStringValue()
let assetsStoreContract = keyAssetsStoreContract.getStringValue().addressFromStringValue()

# Emission keys
let keyEmissionConfig = ["%s", "config"].makeString(separator)
let wxAssetIdStr = emissionContract.getStringOrFail(keyEmissionConfig).split(separator)[1]
let wxAssetId = wxAssetIdStr.fromBase58String()
# Emission keys

let keyFeePerBlock = ["%s", "feePerBlock"].makeString(separator)
let feePerBlock = this.getIntegerOrFail(keyFeePerBlock)

let keyVotingThresholdAdd = ["%s%s", "votingThreshold", "add"].makeString(separator)
let keyVotingThresholdRemove = ["%s%s", "votingThreshold", "remove"].makeString(separator)

func keyPeriodLengthAdd(
  assetId: String,
  index: Int
) = ["%s%s%s", "periodLengthAdd", assetId, index.toString()].makeString(separator)
let keyPeriodLengthRemove = ["%s", "periodLengthRemove"].makeString(separator)

func keyCurrentVotingHeightStart(
  assetId: String,
  index: Int
) = ["%s%s%s", "currentVotingHeightStart", assetId, index.toString()].makeString(separator)


func keyVerified(assetId: String) = ["%s%s", "verified", assetId].makeString(separator)
func keyVerificationInProgress(
  assetId: String
) = ["%s%s%s", "verification", "inProgress", assetId].makeString(separator)
func keyDeverificationInProgress(
  assetId: String
) = ["%s%s%s", "deverification", "inProgress", assetId].makeString(separator)

let keyMaxPeriodLength = ["%s", "maxPeriodLength"].makeString(separator)
let keyMinPeriodLength = ["%s", "minPeriodLength"].makeString(separator)

func keyVotingRewardAssetId(
  assetId: String,
  index: Int
) = ["%s%s%s", "votingRewardAssetId", assetId, index.toString()].makeString(separator)
func keyTotalVotingReward(assetId: String, index: Int) = {
  ["%s%s%s", "votingReward", assetId, index.toString()].makeString(separator)
}
func keyVotingReward(voterAddress: Address, rewardAssetId: String) = {
  ["%s%s", "votingReward", voterAddress.toString(), rewardAssetId].makeString(separator)
}

let keyFinilizeCallReward = ["%s", "finilizeCallReward"].makeString(separator)

let keyMinSuggestRemoveBalance = ["%s", "minSuggestRemoveBalance"].makeString(separator)

func keyCurrentIndex(assetId: String) = ["%s%s", "currentIndex", assetId].makeString(separator)

func keyVote(
  assetId: String,
  index: Int,
  caller: Address
) = ["%s%s%s%s", "vote", assetId, index.toString(), caller.toString()].makeString(separator)
func voteValue(
  inFavor: Boolean,
  gwxAmount: Int
) = ["%s%d", inFavor.toString(), gwxAmount.toString()].makeString(separator)
func keyVotingResult(
  assetId: String,
  index: Int
) = ["%s%s%s", "votingResult", assetId, index.toString()].makeString(separator)
func votingValue(
  forAmount: Int,
  againstAmount: Int
) = ["%d%d", forAmount.toString(), againstAmount.toString()].makeString(separator)
let defaultVotingValue = ["%d%d", "0", "0"].makeString(separator)

func keySuggestIssuer(
  assetId: String,
  index: Int
) = ["%s%s%s", "suggestIssuer", assetId, index.toString()].makeString(separator)

func keyClaimHistory(
  userAddress: Address,
  assetId: String,
  index: Int
) = ["%s%s%s%s", "history", userAddress.toString(), assetId, index.toString()].makeString(separator)
func claimHistoryValue(
  gwxAmount: Int
) = ["%d%s", gwxAmount.toString()].makeString(separator)

func keyVotingEndHeight(
  assetId: String,
  index: Int
) = ["%s%s%s", "votingEndHeight", assetId, index.toString()].makeString(separator)

func getUserGwxAmountAtHeight(userAddress: String, targetHeight: Int) = {
  let gwxAmount = boostingContract.invoke("getUserGwxAmountAtHeightREADONLY", [userAddress, targetHeight], [])

  gwxAmount.asInt()
}

func votingExistChecks(assetId: String, currentIndex: Int) = {
  let verificationInProgress = keyVerificationInProgress(assetId).getBoolean().valueOrElse(false)
  let deverificationInProgress = keyDeverificationInProgress(assetId).getBoolean().valueOrElse(false)

  let suggestIssuer = keySuggestIssuer(assetId, currentIndex).getString().valueOrErrorMessage(
    wrapErr("voting issuer not found")
  )

  let currentVotingHeightStart = keyCurrentVotingHeightStart(assetId, currentIndex).getInteger().valueOrErrorMessage(
    wrapErr("voting start height not found")
  )

  let votingPeriodLenght = if verificationInProgress then {
    keyPeriodLengthAdd(assetId, currentIndex).getInteger().valueOrErrorMessage(
      wrapErr("voting period length not found")
    )
  } else {
    keyPeriodLengthRemove.getInteger().value()
  }

  strict checks = [
    verificationInProgress || deverificationInProgress || "no voting in progress".throwErr(),
    currentVotingHeightStart + votingPeriodLenght > height || "voting expired".throwErr()
  ]

  (
    verificationInProgress,
    deverificationInProgress,
    currentVotingHeightStart,
    votingPeriodLenght,
    suggestIssuer
  )
}

func calculateReward(voter: Address, assetId: String, index: Int) = {
  let voteKey = keyVote(assetId, index, voter)
  let lastVote = voteKey.getString().valueOrErrorMessage(wrapErr("you have not voted"))

  let lastVoteParts = lastVote.split(separator)
  let inFavor = lastVoteParts[1]
  let rewardAmount = if inFavor == "true" then {
    let gwxAmount = lastVoteParts[2].parseIntValue()

    let lastVotingValue = keyVotingResult(assetId, index).getString().valueOrErrorMessage(
      wrapErr("voting does not exist")
    )
    let lastVotingValueParts = lastVotingValue.split(separator)
    let totalVotesFor = lastVotingValueParts[1].parseIntValue()

    let partOfTheTotalVotesX8 = fraction(gwxAmount, MULT8, totalVotesFor)
    let totalVotingReward = keyTotalVotingReward(assetId, index).getInteger().valueOrElse(0)
    let rewardAmount = fraction(partOfTheTotalVotesX8, totalVotingReward, MULT8, FLOOR)

    rewardAmount
  } else {
    0
  }

  rewardAmount
}

@Callable(i)
func suggestAdd(assetId: String, periodLength: Int, assetImage: String) = {
  strict info = assetId.fromBase58String().assetInfo().valueOrErrorMessage("Invalid asset ID")
  let payment = i.payments[0]
  let paymentAssetId = payment.assetId.value().toBase58String()
  let paymentAmount = payment.amount.value()

  let minPeriodLength = keyMinPeriodLength.getIntegerValue()
  let maxPeriodLength = keyMaxPeriodLength.getIntegerValue()

  strict checks = [
    periodLength >= minPeriodLength && periodLength <= maxPeriodLength || "invalid periodLength".throwErr(),
    paymentAmount == periodLength * feePerBlock || "Invalid fee amount".throwErr()
  ]

  strict assetsStoreCreateOrUpdateInv = assetsStoreContract.invoke("createOrUpdate", [assetId, assetImage, false], [])

  let currentIndexKey = keyCurrentIndex(assetId)
  let currentIndex = currentIndexKey.getInteger()
  let newIndex = if currentIndex.isDefined() then {
    currentIndex.value() + 1
  } else {
    0
  }

  let votingEndHeight = height + periodLength

  [
    IntegerEntry(currentIndexKey, newIndex),
    BooleanEntry(keyVerificationInProgress(assetId), true),
    StringEntry(keyVotingRewardAssetId(assetId, newIndex), paymentAssetId),
    IntegerEntry(keyTotalVotingReward(assetId, newIndex), paymentAmount),
    IntegerEntry(keyCurrentVotingHeightStart(assetId, newIndex), height),
    IntegerEntry(keyPeriodLengthAdd(assetId, newIndex), periodLength),
    StringEntry(keySuggestIssuer(assetId, newIndex), i.caller.toString()),
    IntegerEntry(keyVotingEndHeight(assetId, newIndex), votingEndHeight)
  ]
}

@Callable(i)
func suggestRemove(assetId: String) = {
  let gwxAmountAtNow = i.caller.toString().getUserGwxAmountAtHeight(height)
  let minSuggestRemoveBalance = keyMinSuggestRemoveBalance.getIntegerValue()

  let isVerified = keyVerified(assetId).getBoolean().valueOrElse(false)

  strict checks = [
    isVerified || [assetId, "not verified"].makeString(" ").throwErr(),
    gwxAmountAtNow >= minSuggestRemoveBalance || "not enough gWXes".throwErr()
  ]

  let currentIndexKey = keyCurrentIndex(assetId)
  let currentIndex = currentIndexKey.getInteger()
  let newIndex = if currentIndex.isDefined() then {
    currentIndex.value() + 1
  } else {
    0
  }

  let periodLength = keyPeriodLengthRemove.getInteger().valueOrErrorMessage(
    wrapErr("periodLengthRemove not set")
  )
  let votingEndHeight = height + periodLength

  [ 
    IntegerEntry(currentIndexKey, newIndex),
    BooleanEntry(keyDeverificationInProgress(assetId), true),
    IntegerEntry(keyCurrentVotingHeightStart(assetId, newIndex), height),
    StringEntry(keySuggestIssuer(assetId, newIndex), i.caller.toString()),
    IntegerEntry(keyVotingEndHeight(assetId, newIndex), votingEndHeight)
  ]
}

@Callable(i)
func vote(assetId: String, inFavor: Boolean) = {
  let currentIndexKey = keyCurrentIndex(assetId)
  let currentIndex = currentIndexKey.getInteger().valueOrErrorMessage(wrapErr("voting does not exist"))

  strict votingInfo = votingExistChecks(assetId, currentIndex)
  let currentVotingHeightStart = votingInfo._3
  let votingPeriodLenght = votingInfo._4

  let gwxAmountAtEnd = i.caller.toString().getUserGwxAmountAtHeight(currentVotingHeightStart + votingPeriodLenght)

  let voteKey = keyVote(assetId, currentIndex, i.caller)
  let votingResultKey = keyVotingResult(assetId, currentIndex)

  strict checks = [
    voteKey.getString() == unit || "You have already voted".throwErr(),
    gwxAmountAtEnd > 0 || "You'll not have gWX at the end of voting".throw()
  ]

  let lastVotingValue = votingResultKey.getString().valueOrElse(defaultVotingValue)
  let lastVotingValueParts = lastVotingValue.split(separator)

  let newVotingValue = if inFavor then {
    votingValue(
      lastVotingValueParts[1].parseIntValue() + gwxAmountAtEnd,
      lastVotingValueParts[2].parseIntValue()
    )
  } else {
    votingValue(
      lastVotingValueParts[1].parseIntValue(),
      lastVotingValueParts[2].parseIntValue() + gwxAmountAtEnd
    )
  }

  [
    StringEntry(voteKey, voteValue(inFavor, gwxAmountAtEnd)),
    StringEntry(votingResultKey, newVotingValue)
  ]
}

@Callable(i)
func cancelVote(assetId: String) = {
  let currentIndexKey = keyCurrentIndex(assetId)
  let currentIndex = currentIndexKey.getInteger().valueOrErrorMessage(wrapErr("voting does not exist"))

  let voteKey = keyVote(assetId, currentIndex, i.caller)
  let votingResultKey = keyVotingResult(assetId, currentIndex)

  let lastVote = voteKey.getString().valueOrErrorMessage(wrapErr("you have not voted"))
  let lastVoteParts = lastVote.split(separator)
  let inFavor = lastVoteParts[1]
  let gwxAmount = lastVoteParts[2].parseIntValue()

  strict votingInfo = votingExistChecks(assetId, currentIndex)
  strict checks = [
    inFavor == "true" || inFavor == "false" || "invalid vote".throwErr()
  ]

  let lastVotingValue = votingResultKey.getString().valueOrElse(defaultVotingValue)
  let lastVotingValueParts = lastVotingValue.split(separator)

  let newVotingResultValue = if inFavor == "true" then {
    votingValue(
      lastVotingValueParts[1].parseIntValue() - gwxAmount,
      lastVotingValueParts[2].parseIntValue()
    )
  } else {
    votingValue(
      lastVotingValueParts[1].parseIntValue(),
      lastVotingValueParts[2].parseIntValue() - gwxAmount
    )
  }

  [
    DeleteEntry(voteKey),
    StringEntry(votingResultKey, newVotingResultValue)
  ]
}

@Callable(i)
func finalize(assetId: String) = {
  let verificationInProgress = keyVerificationInProgress(assetId).getBoolean().valueOrElse(false)
  let deverificationInProgress = keyDeverificationInProgress(assetId).getBoolean().valueOrElse(false)

  let currentIndexKey = keyCurrentIndex(assetId)
  let currentIndex = currentIndexKey.getInteger().valueOrElse(0)

  let votingThresholdAdd = keyVotingThresholdAdd.getInteger().valueOrErrorMessage(
    wrapErr("votingThresholdAdd not set")
  )
  let votingThresholdRemove = keyVotingThresholdRemove.getInteger().valueOrErrorMessage(
    wrapErr("votingThresholdRemove not set")
  )

  let (finalizeVotingActions, verified, threshold) = if verificationInProgress then {
    (
      [
        DeleteEntry(keyVerificationInProgress(assetId)),
        BooleanEntry(keyVerified(assetId),true)
      ],
      true,
      votingThresholdAdd
    )
  } else {
    (
      [
        DeleteEntry(keyDeverificationInProgress(assetId)),
        DeleteEntry(keyVerified(assetId))
      ],
      true,
      votingThresholdRemove
    )
  }

  let lastVotingValue = keyVotingResult(assetId, currentIndex).getString().valueOrElse(defaultVotingValue)
  let lastVotingValueParts = lastVotingValue.split(separator)
  let votesFor = lastVotingValueParts[1].parseIntValue()
  let votesAgainst = lastVotingValueParts[2].parseIntValue()
  let votesTotal = votesFor + votesAgainst

  let votingEndHeight = keyVotingEndHeight(assetId, currentIndex).getInteger().valueOrErrorMessage(
    wrapErr("voting end height not found")
  )

  strict checks = [
    verificationInProgress || deverificationInProgress || "nothing to finalize".throwErr(),
    votingEndHeight <= height || "voting not finished".throwErr(),
    votesTotal >= threshold || "not enough votes".throwErr()
  ]

  strict setVerifiedInvoke = votesFor < votesAgainst ||
    assetsStoreContract.invoke("setVerified", [assetId, verified], [])

  let finilizeCallReward = keyFinilizeCallReward.getInteger().valueOrElse(0)
  let finilizeCallRewardAction = [ScriptTransfer(i.caller, finilizeCallReward, wxAssetId)]

  finalizeVotingActions ++ finilizeCallRewardAction
}

@Callable(i)
func claimREADONLY(assetId: String, index: Int) = {
  let callerAddress = i.caller
  let rewardAmount = calculateReward(callerAddress, assetId, index)

  (nil, rewardAmount)
}

@Callable(i)
func claim(assetId: String, index: Int) = {
  let callerAddress = i.caller

  let votingRewardAssetId = keyVotingRewardAssetId(assetId, index).getString().valueOrErrorMessage(
    wrapErr("votingRewardAssetId not set")
  ).fromBase58String()

  let claimHistoryKey = keyClaimHistory(callerAddress, assetId, index)
  let claimHistory = claimHistoryKey.getString()

  strict checks = [
    claimHistory == unit || "already claimed".throwErr()
  ]

  let rewardAmount = calculateReward(callerAddress, assetId, index)

  [
    ScriptTransfer(callerAddress, rewardAmount, votingRewardAssetId),
    StringEntry(claimHistoryKey, claimHistoryValue(rewardAmount))
  ]
}
