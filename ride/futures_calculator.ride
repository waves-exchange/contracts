{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let separator = "__"
let chainId = this.bytes.drop(1).take(1)
let chainIdW = base16'57'
let contractFilename = "futures_calculator.ride"
let mult8 = 100_000_000
let mult18BigInt = 1_000_000_000_000_000_000.toBigInt()
let wavesDecimals = 8
let usdtDecimals = 6
let wavesString = "WAVES"
let queueItemSize = 32
let big0 = 0.toBigInt()

let kMultisig = "%s__multisig"
func kStatus(dapp: String, txId: String) = ["%s__status", dapp, txId].makeString(separator)

let kShutdown = "%s__shutdown"
let kPublicKeys = "%s__publicKeys"
let kMatcherPublicKey = "%s__matcherPublicKey"

func toX18(origVal: Int, origScaleMult: Int) = fraction(origVal.toBigInt(), mult18BigInt, origScaleMult.toBigInt())
func fromX18(val: BigInt, resultScaleMult: Int) = fraction(val, resultScaleMult.toBigInt(), mult18BigInt).toInt()

func validateAddress(address: String) = {
  addressFromString(address).isDefined()
}

func wrapErr(s: String) = {
  contractFilename + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func ensurePositive(v: Int, s: String) = {
  if (v >= 0) then v else throwErr(s + " value should be positive")
}

func parseAssetId(input: String) = {
  if (input == wavesString) then unit else input.fromBase58String()
}

func assetIdToString(input: ByteVector|Unit) = {
  if (input == unit) then wavesString else input.value().toBase58String()
}

func getAssetInfoOrFail(assetId: ByteVector) = {
  assetInfo(assetId).valueOrErrorMessage(wrapErr("invalid asset info"))
}

func getAssetDecimalsOrFail(assetId: ByteVector|Unit) = {
  match assetId {
    case _: Unit => wavesDecimals
    case assetId: ByteVector => getAssetInfoOrFail(assetId).decimals
  }
}

func pow10(n: Int) = pow(10, 0, n, 0, 0, DOWN)

func pow10Decimals(assetId: ByteVector|Unit) = pow10(getAssetDecimalsOrFail(assetId))

let kFactoryAddress = "%s__factoryAddress"
let factoryAddressOption = match this.getString(kFactoryAddress) {
  case s: String => s.addressFromString()
  case _: Unit => unit
}
let factoryAddress = factoryAddressOption.valueOrErrorMessage(wrapErr("invalid factory address"))

let kUsdtAssetId = "%s__usdtAssetId"
let usdtAssetIdOption = match factoryAddress.getString(kUsdtAssetId) {
  case s: String => parseAssetId(s)
  case _: Unit => unit
}
let usdtAssetId = usdtAssetIdOption.valueOrErrorMessage(wrapErr("invalid usdt asset id"))

let kPricesAddress = "%s__calculatorAddress"

let shutdown = factoryAddress.getBoolean(kShutdown).valueOrElse(false)

func mustAddress(caller: Address, address: Address) = {
  caller == address || throwErr("permission denied")
}

func mustThis(caller: Address) = {
  mustAddress(caller, this)
}

func mustFactory(caller: Address) = {
  mustAddress(caller, factoryAddress)
}

func mustAdmin(callerPublicKey: ByteVector) = {
  let multisig = factoryAddress.getStringValue(kMultisig).addressFromStringValue()
  let publicKeysList = multisig.getStringValue(kPublicKeys).split(separator)

  containsElement(
    publicKeysList, callerPublicKey.toBase58String()
  ) || throwErr("not allowed")
}

let kAccountScript = "%s__accountScript"
func accountScript() = factoryAddress.getBinary(
  kAccountScript
).valueOrErrorMessage(wrapErr("account script is not set"))

let kRewardAmount = "%s__rewardAmount"
func rewardAmount() = factoryAddress.getInteger(
  kRewardAmount
).valueOrErrorMessage(wrapErr("reward amount is not set"))

let kAccountsLimit = "%s__accountsLimit"
let accountsLimitDefault = 20
func accountsLimit() = factoryAddress.getInteger(
  kAccountsLimit
).valueOrElse(accountsLimitDefault)

func kDeposited(accountAddress: Address) = ["%s%s", "deposited", accountAddress.toString()].makeString(separator)
func depositedOption(accountAddress: Address) = factoryAddress.getInteger(
  kDeposited(accountAddress)
)
func kCredit(accountAddress: Address, assetId: ByteVector|Unit) = ["%s%s%s", "credit", accountAddress.toString(), assetId.assetIdToString()].makeString(separator)
func creditOption(accountAddress: Address, assetId: ByteVector|Unit) = factoryAddress.getInteger(
  kCredit(accountAddress, assetId)
)
func kLeverage(accountAddress: Address) = ["%s%s", "leverage", accountAddress.toString()].makeString(separator)
func kRequestLeverage(requestId: ByteVector) = ["%s%s", "requestLeverage", requestId.toBase58String()].makeString(separator)
func kSyntheticAssetId(baseAssetId: ByteVector|Unit) = ["%s%s", "syntheticAssetId", baseAssetId.assetIdToString()].makeString(separator)
func kBaseAssetId(syntheticAssetId: ByteVector|Unit) = ["%s%s", "baseAssetId", syntheticAssetId.assetIdToString()].makeString(separator)

let REQUEST_STATUS_EMPTY = 0
let REQUEST_STATUS_READY = 1
func kRequestStatus(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "status"].makeString(separator)
}

func kAccountCreatorPublicKey(accountAddress: Address) = {
  ["%s%s", accountAddress.toString(), "creatorPublicKey"].makeString(separator)
}
func kRequestOwnerPublicKey(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "ownerPublicKey"].makeString(separator)
}
func kRequestAmountAssetId(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "amountAssetId"].makeString(separator)
}
func kRequestPriceAssetId(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "priceAssetId"].makeString(separator)
}
func kRequestIdToAccountPublicKey(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "requestIdToAccountPublicKey"].makeString(separator)
}
func kAccountAddressToRequestId(accountAddress: Address) = {
  ["%s%s", accountAddress.toString(), "accountAddressToRequestId"].makeString(separator)
}

func kRequestsQueue() = {
  ["%s", "requestsQueue"].makeString(separator)
}
func requestsQueue() = factoryAddress.getBinary(kRequestsQueue()).valueOrElse(base58'')

func kAccountsQueue() = {
  ["%s", "accountsQueue"].makeString(separator)
}
func accountsQueue() = factoryAddress.getBinary(kAccountsQueue()).valueOrElse(base58'')

func kRequestsByOwner(ownerAddress: Address) = {
  ["%s%s", "requests", ownerAddress.toString()].makeString(separator)
}
func requestsByOwner(ownerAddress: Address) = factoryAddress.getBinary(
  kRequestsByOwner(ownerAddress)
).valueOrElse(base58'')

func kPairAllowed(amountAssetId: ByteVector|Unit, priceAssetId: ByteVector|Unit) = {
  ["%s%s%s", assetIdToString(amountAssetId), assetIdToString(priceAssetId), "pairAllowed"].makeString(separator)
}
func pairAllowed(amountAssetId: ByteVector|Unit, priceAssetId: ByteVector|Unit) = {
  factoryAddress.getBoolean(
    kPairAllowed(amountAssetId, priceAssetId)
  ).valueOrElse(false)
}

func kPrice(assetId: ByteVector|Unit) = {
  ["%s", assetIdToString(assetId)].makeString(separator)
}

func getCurrentPrice(assetId: ByteVector|Unit) = {
  let matcherPublicKey = factoryAddress.getString(kMatcherPublicKey).valueOrErrorMessage(
    wrapErr("invalid matcher public key")
  ).fromBase58String()
  let matcherAddress = addressFromPublicKey(matcherPublicKey)
  let price = matcherAddress.getInteger(kPrice(assetId)).valueOrErrorMessage(
    wrapErr("invalid price, assetId = " + assetIdToString(assetId))
  )

  price
}

func calcTotalCredit(creditA: BigInt, creditB: BigInt, currentPrice: BigInt) = {
  fraction(creditA, currentPrice, mult18BigInt) + creditB
}

func calcTotalBalance(balanceA: BigInt, balanceB: BigInt, currentPrice: BigInt) = {
  fraction(balanceA, currentPrice, mult18BigInt) + balanceB
}

func calcPnl(totalBalance: BigInt, totalCredit: BigInt) = {
  totalBalance - totalCredit
}

func calcCreditAvailable(deposit: BigInt, leverage: BigInt, totalCredit: BigInt) = {
  fraction(deposit, leverage, mult18BigInt) - totalCredit
}

func calcRealInCredit(credit: BigInt, balance: BigInt) = {
  if (credit > big0) then credit - balance else big0
}

func calcFree(credit: BigInt, balance: BigInt) = {
  if (credit > big0) then balance - credit else big0
}

func calcShortPrice(free: BigInt, realInCredit: BigInt) = {
  if (realInCredit > big0) then max([big0, fraction(free, mult18BigInt, realInCredit)]) else big0
}

func calcLongPrice(free: BigInt, realInCredit: BigInt) = {
  if (realInCredit > big0) then max([big0, fraction(realInCredit, mult18BigInt, free)]) else big0
}

func calcStartMargin(realInCreditA: BigInt, realInCreditB: BigInt, currentPrice: BigInt, settingsMargin: BigInt) = {
  fraction(fraction(realInCreditA, currentPrice, mult18BigInt) + realInCreditB, settingsMargin, mult18BigInt)
}

func calcMarginSupply(settingsMarginSupply: BigInt, settingsMargin: BigInt, startMargin: BigInt) = {
  fraction(settingsMarginSupply, startMargin, settingsMargin)
}

func calcLiquidationPrice(
  deposit: BigInt,
  marginSupply: BigInt,
  realInCreditA: BigInt,
  realInCreditB: BigInt,
  shortPrice: BigInt,
  longPrice: BigInt
) = {
  let liquidationPriceA = if (realInCreditA > big0) then {
    (deposit - marginSupply) / realInCreditA + shortPrice
  } else big0
  let liquidationPriceB = if (realInCreditB > big0) then {
    longPrice - (deposit - marginSupply) / (realInCreditA / longPrice)
  } else big0
  liquidationPriceA + liquidationPriceB
}

func getRequestId(accountAddress: Address) = {
  let requestId = factoryAddress.getString(
    kAccountAddressToRequestId(accountAddress)
  ).valueOrErrorMessage(wrapErr("invalid account address: request id is undefined")).fromBase58String()

  requestId
}

func getAccountAssets(accountAddress: Address) = {
  let requestId = getRequestId(accountAddress)
  let amountAssetId = factoryAddress.getString(
    kRequestAmountAssetId(requestId)
  ).valueOrErrorMessage(wrapErr("invalid amount asset id")).parseAssetId()
  let priceAssetId = factoryAddress.getString(
    kRequestPriceAssetId(requestId)
  ).valueOrErrorMessage(wrapErr("invalid amount price id")).parseAssetId()

  (amountAssetId, priceAssetId)
}

func getAccountOwnerPublicKey(accountAddress: Address) = {
  let requestId = getRequestId(accountAddress)

  let requestOwnerPublicKey = factoryAddress.getBinary(
    kRequestOwnerPublicKey(requestId)
  ).valueOrErrorMessage(wrapErr("invalid amount asset id"))

  requestOwnerPublicKey
}

@Callable(i)
func init(
  factoryAddressStr: String
) = {
  strict checkCaller = i.caller.mustThis()

  ([
    StringEntry(kFactoryAddress, factoryAddressStr)
  ], unit)
}

# TODO: Validate assetIdStrings
# TODO: price asset id should be usdt?
# TODO: validate leverage
# called by user
# additional fee in payment
# args: [amountAssetId, priceAssetId, leverage]
@Callable(i)
func requestAccount(callerPublicKey: ByteVector, args: List[String]) = {
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory()
  ]
  let amountAssetIdStr = args[0]
  let priceAssetIdStr = args[1]
  let leverage = parseInt(args[2]).valueOrErrorMessage(
    wrapErr("invalid leverage")
  )
  let userAddress = addressFromPublicKey(callerPublicKey)
  let requestId = sha256(userAddress.bytes + amountAssetIdStr.fromBase58String() + priceAssetIdStr.fromBase58String())
  let amountAssetId = parseAssetId(amountAssetIdStr)
  let priceAssetId = parseAssetId(priceAssetIdStr)
  let userRequestsNumber = kRequestsByOwner(userAddress).size() / queueItemSize

  strict checks = [
    i.payments.size() == 1 || throwErr("1 payment is required"),
    i.payments[0].assetId == unit || throwErr("invalid asset"),
    i.payments[0].amount == rewardAmount() || throwErr("invalid amount"),
    pairAllowed(amountAssetId, priceAssetId) || throwErr("pair is not allowed"),
    factoryAddress.getInteger(kRequestStatus(requestId)) == unit || throwErr("account is already exists"),
    userRequestsNumber < accountsLimit() || throwErr("accounts limit is " + accountsLimit().toString())
  ]

  # add request to queue or match with account immediately

  let (actions, factoryActions) = if (accountsQueue().size() == 0) then { # if the accounts queue is empty
    # then add request to requests queue
    ([
      ScriptTransfer(factoryAddress, rewardAmount(), unit)
    ],
    [
      factoryAddress.invoke("integerEntry", [kRequestStatus(requestId), REQUEST_STATUS_EMPTY], []),
      factoryAddress.invoke("binaryEntry", [kRequestsQueue(), requestsQueue() + requestId], []),
      factoryAddress.invoke("integerEntry", [kRequestLeverage(requestId), leverage], [])
    ])
  } else { # if the accounts queue is not empty
    # then fulfill request
    let accountPublicKey = accountsQueue().take(queueItemSize)
    let accountAddress = addressFromPublicKey(accountPublicKey)
    let creatorAddress = addressFromPublicKey(
      factoryAddress.getBinary(
        kAccountCreatorPublicKey(accountAddress)
      ).valueOrErrorMessage(wrapErr("invalid creator public key"))
    )
    ([
      ScriptTransfer(creatorAddress, rewardAmount(), unit)
    ],
    [
      factoryAddress.invoke("binaryEntry", [kAccountsQueue(), accountsQueue().drop(queueItemSize)], []),
      factoryAddress.invoke("integerEntry", [kRequestStatus(requestId), REQUEST_STATUS_READY], []),
      factoryAddress.invoke("binaryEntry", [kRequestIdToAccountPublicKey(requestId), accountPublicKey], []),
      factoryAddress.invoke("stringEntry", [kAccountAddressToRequestId(accountAddress), requestId.toBase58String()], []),
      factoryAddress.invoke("integerEntry", [kLeverage(accountAddress), leverage], [])
    ])
  }

  (actions, factoryActions ++ [
    factoryAddress.invoke("binaryEntry", [kRequestOwnerPublicKey(requestId), callerPublicKey], []),
    factoryAddress.invoke("binaryEntry", [kRequestsByOwner(userAddress), requestsByOwner(userAddress) + requestId], []),
    factoryAddress.invoke("stringEntry", [kRequestAmountAssetId(requestId), amountAssetIdStr], []),
    factoryAddress.invoke("stringEntry", [kRequestPriceAssetId(requestId), priceAssetIdStr], [])
  ])
}

# called by account script
# additional fee is sent to recipient
# args: [creatorPublicKey]
@Callable(i)
func addAccount(callerPublicKey: ByteVector, args: List[String]) = {
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory()
  ]
  let creatorPublicKey = args[0].fromBase58String()
  let accountPublicKey = callerPublicKey
  let accountAddress = addressFromPublicKey(callerPublicKey)
  let creatorAddress = addressFromPublicKey(creatorPublicKey)

  strict checks = [
    factoryAddress.getBinary(kAccountCreatorPublicKey(accountAddress)) == unit || throwErr("account is already exists"),
    match scriptHash(accountAddress) {
      case b: ByteVector => b == blake2b256_32Kb(accountScript())
      case _ => false
    } || throwErr("invalid script")
  ]

  let (actions, factoryActions) = if (requestsQueue().size() == 0) then { # if the requests queue is empty
    # then add account to accounts queue
    (
      [],
      [
        factoryAddress.invoke("binaryEntry", [kAccountsQueue(), accountsQueue() + accountPublicKey], [])
      ]
    )
  } else { # if the requests queue is not empty
    # then fulfill next request
    let requestId = requestsQueue().take(queueItemSize)
    let leverage = factoryAddress.getInteger(kRequestLeverage(requestId)).valueOrErrorMessage(
      wrapErr("request's leverage is undefined")
    )
    (
      [],
      [
        factoryAddress.invoke("integerEntry", [kRequestStatus(requestId), REQUEST_STATUS_READY], []),
        factoryAddress.invoke("binaryEntry", [kRequestIdToAccountPublicKey(requestId), accountPublicKey], []),
        factoryAddress.invoke("binaryEntry", [kRequestsQueue(), requestsQueue().drop(queueItemSize)], []),
        factoryAddress.invoke("stringEntry", [kAccountAddressToRequestId(accountAddress), requestId.toBase58String()], []),
        factoryAddress.invoke("transferWaves", [creatorAddress.bytes, rewardAmount()], []),
        factoryAddress.invoke("integerEntry", [kLeverage(accountAddress), leverage], [])
      ]
    )
  }

  (actions, factoryActions ++ [
    factoryAddress.invoke("binaryEntry", [kAccountCreatorPublicKey(accountAddress), creatorPublicKey], [])
  ])
}

# Deposit USDT
# args: [accountAddress]
@Callable(i)
func deposit(callerPublicKey: ByteVector, args: List[String]) = {
  let payment = i.payments[0]
  let accountAddress = addressFromString(args[0]).valueOrErrorMessage(
    wrapErr("invalid account address")
  )
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory(),
    i.payments.size() == 1 || throwErr("1 payment is required"),
    payment.assetId == usdtAssetId || throwErr("invalid asset"),
    # check if account is ready
    factoryAddress.getInteger(
      kRequestStatus(getRequestId(accountAddress))
    ) == REQUEST_STATUS_READY || throwErr("account is not ready")
  ]

  let actions = [
    ScriptTransfer(accountAddress, payment.amount, payment.assetId)
  ]

  let factoryActions = [
    factoryAddress.invoke(
      "integerEntry",
      [
        kDeposited(accountAddress),
        depositedOption(accountAddress).valueOrElse(0) + payment.amount
      ], []
    )
  ]

  (actions, factoryActions)
}

# TODO: validate accounts relations. (!)
# TODO: validate asset id
# TODO: ensure amount is positive
# args: [accountAddress, amount, assetId]
@Callable(i)
func withdraw(callerPublicKey: ByteVector, args: List[String]) = {
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory()
  ]
  let userAddress = addressFromPublicKey(callerPublicKey)
  let accountAddress = addressFromString(args[0]).valueOrErrorMessage(
    wrapErr("invalid account address")
  )
  let amount = parseInt(args[1]).valueOrErrorMessage(
    wrapErr("invalid amount")
  )
  let assetId = parseAssetId(args[2])

  let invocations = [
    accountAddress.invoke("transferAsset", [userAddress.bytes, amount, assetId], [])
  ]

  (nil, invocations)
}

# args: [accountAddress, assetId, amount]
@Callable(i)
func borrow(callerPublicKey: ByteVector, args: List[String]) = {
  let accountAddress = addressFromString(args[0]).valueOrErrorMessage(
    wrapErr("invalid account address")
  )
  let assetIdRequested = parseAssetId(args[1])
  let amountRequested = parseInt(args[2]).valueOrErrorMessage(
    wrapErr("invalid requested amount")
  ).ensurePositive("requested amount")
  let accountOwnerPublicKey = getAccountOwnerPublicKey(accountAddress)
  let userAddress = addressFromPublicKey(callerPublicKey)

  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory(),
    callerPublicKey == accountOwnerPublicKey || throwErr(
      "can be called by account owner only"
    )
  ]

  let amountAssetId = getAccountAssets(accountAddress)._1
  let deposited = depositedOption(accountAddress).valueOrElse(0).toX18(pow10Decimals(usdtAssetId))
  let currentPrice = getCurrentPrice(amountAssetId).toX18(pow10Decimals(usdtAssetId))
  let creditA = factoryAddress.getInteger(kCredit(accountAddress, amountAssetId)).valueOrElse(0).toX18(pow10Decimals(amountAssetId))
  let creditB = factoryAddress.getInteger(kCredit(accountAddress, usdtAssetId)).valueOrElse(0).toX18(pow10Decimals(usdtAssetId))
  let totalCredit = calcTotalCredit(creditA, creditB, currentPrice)
  let leverage = factoryAddress.getInteger(kLeverage(accountAddress)).valueOrErrorMessage(
    wrapErr("leverage should be defined")
  ).toX18(1)
  let creditAvailableUsdt = calcCreditAvailable(deposited, leverage, totalCredit)

  let creditAvailable = if (assetIdRequested == amountAssetId) then {
    fraction(creditAvailableUsdt, mult18BigInt, currentPrice).fromX18(pow10Decimals(amountAssetId))
  } else if (assetIdRequested == usdtAssetId) then {
    creditAvailableUsdt.fromX18(pow10Decimals(usdtAssetId))
  } else throwErr("invalid requested asset id")

  let syntheticAssetId = factoryAddress.getString(
    kSyntheticAssetId(assetIdRequested)
  ).valueOrErrorMessage(
    wrapErr("synthetic asset for requested asset is undefined")
  ).parseAssetId()

  let amountToSend = if (amountRequested <= creditAvailable) then {
    amountRequested
  } else throwErr("credit available = " + creditAvailable.toString())

  let factoryActions = [
    factoryAddress.invoke(
      "integerEntry",
      [
        kCredit(accountAddress, assetIdRequested),
        creditOption(accountAddress, assetIdRequested).valueOrElse(0) + amountToSend
      ], []
    ),
    factoryAddress.invoke(
      "transferAsset", 
      [
        userAddress.bytes,
        amountToSend,
        syntheticAssetId
      ], []
    )
  ]

  (nil, [factoryActions, creditAvailable])
}

# TODO: not implemented
@Callable(i)
func repay(callerPublicKey: ByteVector, args: List[String]) = {
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory()
  ]

  (nil, unit)
}

# args: [amountAssetId, priceAssetId, allow]
@Callable(i)
func setPairAllowance(callerPublicKey: ByteVector, args: List[String]) = {
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory(),
    callerPublicKey.mustAdmin()
  ]
  let amountAssetIdStr = args[0]
  let priceAssetIdStr = args[1]
  let allowStr = args[2]
  let amountAssetId = parseAssetId(amountAssetIdStr)
  let priceAssetId = parseAssetId(priceAssetIdStr)
  let allow = allowStr == "true"

  let invocations = [
    factoryAddress.invoke("booleanEntry", [kPairAllowed(amountAssetId, priceAssetId), allow], [])
  ]

  (nil, invocations)
}

# args: [assetId]
@Callable(i)
func addSyntheticAsset(callerPublicKey: ByteVector, args: List[String]) = {
  let baseAssetId = parseAssetId(args[0])
  let syntheticAssetId = parseAssetId(args[1])

  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory(),
    callerPublicKey.mustAdmin(),
    factoryAddress.getString(kSyntheticAssetId(baseAssetId)) == unit || throwErr(
      "invalid base asset"
    ),
    factoryAddress.getString(kBaseAssetId(syntheticAssetId)) == unit || throwErr(
      "invalid synthetic asset"
    )
  ]

  let invocations = [
    factoryAddress.invoke("stringEntry", [kSyntheticAssetId(baseAssetId), assetIdToString(syntheticAssetId)], []),
    factoryAddress.invoke("stringEntry", [kBaseAssetId(syntheticAssetId), assetIdToString(baseAssetId)], [])
  ]

  (nil, invocations)
}

@Callable(i)
func doShutdown(callerPublicKey: ByteVector, args: List[String]) = {
  strict checks = [
    i.caller.mustFactory(),
    callerPublicKey.mustAdmin()
  ]

  let invocations = [
    factoryAddress.invoke("booleanEntry", [kShutdown, true], [])
  ]

  (nil, invocations)
}

# args: [accountAddress]
@Callable(i)
func getAccountInfoREADONLY(callerPublicKey: ByteVector, args: List[String]) = {
  strict checks = [
    i.caller.mustFactory()
  ]
  let accountAddress = addressFromString(args[0]).valueOrErrorMessage(
    wrapErr("invalid account address")
  )
  let (amountAssetId, priceAssetId) = getAccountAssets(accountAddress)
  let leverage = factoryAddress.getInteger(kLeverage(accountAddress)).valueOrErrorMessage(
    wrapErr("leverage should be defined")
  )
  let userAddress = addressFromPublicKey(callerPublicKey)

  let requestId = getRequestId(accountAddress)
  let accountPublicKey = factoryAddress.getBinary(kRequestIdToAccountPublicKey(requestId)).valueOrErrorMessage("kRequestIdToAccountPublicKey not found")
  let deposited = depositedOption(accountAddress).valueOrElse(0).toX18(pow10Decimals(usdtAssetId))
  let currentPrice = getCurrentPrice(amountAssetId).toX18(pow10Decimals(usdtAssetId))
  let creditA = factoryAddress.getInteger(kCredit(accountAddress, amountAssetId)).valueOrElse(0).toX18(pow10Decimals(amountAssetId))
  let creditB = factoryAddress.getInteger(kCredit(accountAddress, usdtAssetId)).valueOrElse(0).toX18(pow10Decimals(usdtAssetId))

  let data = (
    amountAssetId.assetIdToString(),
    priceAssetId.assetIdToString(),
    accountAddress.toString(),
    accountPublicKey.toBase58String(),
    leverage,
    requestId.toBase58String(),
    deposited,
    creditA,
    creditB,
    0.toX18(pow10Decimals(amountAssetId)),
    0.toX18(pow10Decimals(usdtAssetId))
  )
  
  (nil, data)
}

@Verifier(tx)
func verify() = {
  if (factoryAddressOption.isDefined() && factoryAddress.getString(kMultisig).isDefined()) then {
    match factoryAddress.getString(kMultisig) {
      case multisig: String => {
        let statusKey = kStatus(this.toString(), tx.id.toBase58String())
        let status = multisig.addressFromStringValue().getBoolean(statusKey).valueOrElse(false)

        status
      }
      case _ => false
    }
  } else {
    sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
  }
}
