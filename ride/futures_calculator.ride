{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let separator = "__"
let chainId = this.bytes.drop(1).take(1)
let chainIdW = base16'57'
let contractFilename = "futures_calculator.ride"

let kMultisig = "%s__multisig"
func kStatus(dapp: String, txId: String) = ["%s__status", dapp, txId].makeString(separator)

let kShutdown = "%s__shutdown"
let kPublicKeys = "%s__publicKeys"
let kMatcherPublicKey = "%s__matcherPublicKey"

func validateAddress(address: String) = {
  addressFromString(address).isDefined()
}

func wrapErr(s: String) = {
  contractFilename + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

let kFactoryAddress = "%s__factoryAddress"
let factoryAddressOption = match this.getString(kFactoryAddress) {
  case s: String => s.addressFromString()
  case _: Unit => unit
}
let factoryAddress = factoryAddressOption.valueOrErrorMessage(wrapErr("invalid factory address"))

let kPricesAddress = "%s__calculatorAddress"

let shutdown = factoryAddress.getBoolean(kShutdown).valueOrElse(false)

func mustAddress(caller: Address, address: Address) = {
  caller == address || throwErr("permission denied")
}

func mustThis(caller: Address) = {
  mustAddress(caller, this)
}

func mustFactory(caller: Address) = {
  mustAddress(caller, factoryAddress)
}

func mustAdmin(callerPublicKey: ByteVector) = {
  let multisig = factoryAddress.getStringValue(kMultisig).addressFromStringValue()
  let publicKeysList = multisig.getStringValue(kPublicKeys).split(separator)

  containsElement(
    publicKeysList, callerPublicKey.toBase58String()
  ) || throwErr("not allowed")
}

let wavesString = "WAVES"
let queueItemSize = 32

func parseAssetId(input: String) = {
  if (input == wavesString) then unit else input.fromBase58String()
}

func assetIdToString(input: ByteVector|Unit) = {
  if (input == unit) then wavesString else input.value().toBase58String()
}

let kAccountScript = "%s__accountScript"
func accountScript() = factoryAddress.getBinary(
  kAccountScript
).valueOrErrorMessage(wrapErr("account script is not set"))

let kRewardAmount = "%s__rewardAmount"
func rewardAmount() = factoryAddress.getInteger(
  kRewardAmount
).valueOrErrorMessage(wrapErr("reward amount is not set"))

let kAccountsLimit = "%s__accountsLimit"
let accountsLimitDefault = 20
func accountsLimit() = factoryAddress.getInteger(
  kAccountsLimit
).valueOrElse(accountsLimitDefault)

func kDeposited(accountAddress: Address) = ["%s%s", "deposited", accountAddress.toString()].makeString(separator)
func depositedOption(accountAddress: Address) = factoryAddress.getInteger(
  kDeposited(accountAddress)
)
func kCredit(accountAddress: Address, assetId: ByteVector|Unit) = ["%s%s%s", "credit", accountAddress.toString(), assetId.assetIdToString()].makeString(separator)
func kLeverage(accountAddress: Address) = ["%s%s", "leverage", accountAddress.toString()].makeString(separator)
func kSyntheticAssetId(baseAssetId: ByteVector|Unit) = ["%s%s", "syntheticAssetId", baseAssetId.assetIdToString()].makeString(separator)
func kBaseAssetId(syntheticAssetId: ByteVector|Unit) = ["%s%s", "baseAssetId", syntheticAssetId.assetIdToString()].makeString(separator)

let REQUEST_STATUS_EMPTY = 0
let REQUEST_STATUS_READY = 1
func kRequestStatus(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "status"].makeString(separator)
}

func kAccountCreatorPublicKey(accountAddress: Address) = {
  ["%s%s", accountAddress.toString(), "creatorPublicKey"].makeString(separator)
}
func kRequestOwnerPublicKey(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "ownerPublicKey"].makeString(separator)
}
func kRequestAmountAssetId(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "amountAssetId"].makeString(separator)
}
func kRequestPriceAssetId(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "priceAssetId"].makeString(separator)
}
func kRequestIdToAccountPublicKey(requestId: ByteVector) = {
  ["%s%s", requestId.toBase58String(), "requestIdToAccountPublicKey"].makeString(separator)
}
func kAccountAddressToRequestId(accountAddress: Address) = {
  ["%s%s", accountAddress.toString(), "accountAddressToRequestId"].makeString(separator)
}

func kRequestsQueue() = {
  ["%s", "requestsQueue"].makeString(separator)
}
func requestsQueue() = factoryAddress.getBinary(kRequestsQueue()).valueOrElse(base58'')

func kAccountsQueue() = {
  ["%s", "accountsQueue"].makeString(separator)
}
func accountsQueue() = factoryAddress.getBinary(kAccountsQueue()).valueOrElse(base58'')

func kRequestsByOwner(ownerAddress: Address) = {
  ["%s%s", "accounts", ownerAddress.toString()].makeString(separator)
}
func requestsByOwner(ownerAddress: Address) = factoryAddress.getBinary(
  kRequestsByOwner(ownerAddress)
).valueOrElse(base58'')

func kPairAllowed(amountAssetId: ByteVector|Unit, priceAssetId: ByteVector|Unit) = {
  ["%s%s%s", assetIdToString(amountAssetId), assetIdToString(priceAssetId), "pairAllowed"].makeString(separator)
}
func pairAllowed(amountAssetId: ByteVector|Unit, priceAssetId: ByteVector|Unit) = {
  factoryAddress.getBoolean(
    kPairAllowed(amountAssetId, priceAssetId)
  ).valueOrElse(false)
}

func kPrice(assetId: ByteVector|Unit) = {
  ["%s", assetIdToString(assetId)].makeString(separator)
}

func getCurrentPrice(assetId: ByteVector|Unit) = {
  let matcherPublicKey = factoryAddress.getString(kMatcherPublicKey).valueOrErrorMessage(
    wrapErr("invalid matcher public key")
  ).fromBase58String()
  let matcherAddress = addressFromPublicKey(matcherPublicKey)
  let price = matcherAddress.getInteger(kPrice(assetId)).valueOrErrorMessage(
    wrapErr("invalid price, assetId = " + assetIdToString(assetId))
  )

  price
}

func calcTotalCredit(creditA: Int, creditB: Int, currentPrice: Int) = {
  creditA * currentPrice + creditB
}

func calcTotalBalance(balanceA: Int, balanceB: Int, currentPrice: Int) = {
  balanceA * currentPrice + balanceB
}

func calcPnl(totalBalance: Int, totalCredit: Int) = {
  totalBalance - totalCredit
}

func calcCreditAvailable(deposit: Int, leverage: Int, totalCredit: Int) = {
  deposit * leverage - totalCredit
}

func calcRealInCredit(credit: Int, balance: Int) = {
  if (credit > 0) then credit - balance else 0
}

func calcFree(credit: Int, balance: Int) = {
  if (credit > 0) then balance - credit else 0
}

func calcShortPrice(free: Int, realInCredit: Int) = {
  if (realInCredit > 0) then max([0, free / realInCredit]) else 0
}

func calcLongPrice(free: Int, realInCredit: Int) = {
  if (realInCredit > 0) then max([0, realInCredit / free]) else 0
}

func calcStartMargin(realInCreditA: Int, realInCreditB: Int, currentPrice: Int, settingsMargin: Int) = {
  (realInCreditA * currentPrice + realInCreditB) * settingsMargin
}

func calcMarginSupply(settingsMarginSupply: Int, settingsMargin: Int, startMargin: Int) = {
  settingsMarginSupply / settingsMargin * startMargin
}

func calcLiquidationPrice(
  deposit: Int,
  marginSupply: Int,
  realInCreditA: Int,
  realInCreditB: Int,
  shortPrice: Int,
  longPrice: Int
) = {
  let liquidationPriceA = if (realInCreditA > 0) then {
    (deposit - marginSupply) / realInCreditA + shortPrice
  } else 0
  let liquidationPriceB = if (realInCreditB > 0) then {
    longPrice - (deposit - marginSupply) / (realInCreditA / longPrice)
  } else 0
  liquidationPriceA + liquidationPriceB
}

func getAssetsByAccountAddress(accountAddress: Address) = {
  let requestId = factoryAddress.getString(kAccountAddressToRequestId(accountAddress)).valueOrErrorMessage(wrapErr("invalid account address")).fromBase58String()
  let amountAssetId = factoryAddress.getString(kRequestAmountAssetId(requestId)).valueOrErrorMessage(wrapErr("invalid amount asset id")).parseAssetId()
  let priceAssetId = factoryAddress.getString(kRequestPriceAssetId(requestId)).valueOrErrorMessage(wrapErr("invalid amount price id")).parseAssetId()

  (amountAssetId, priceAssetId)
}

@Callable(i)
func init(
  factoryAddressStr: String
) = {
  strict checkCaller = i.caller.mustThis()

  ([
    StringEntry(kFactoryAddress, factoryAddressStr)
  ], unit)
}

# TODO: price asset id should be usdt?
# called by user
# additional fee in payment
# args: [amountAssetId, priceAssetId]
@Callable(i)
func requestAccount(callerPublicKey: ByteVector, args: List[String]) = {
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory()
  ]
  let amountAssetIdStr = args[0]
  let priceAssetIdStr = args[1]
  let userAddress = addressFromPublicKey(callerPublicKey)
  let requestId = sha256(userAddress.bytes + amountAssetIdStr.fromBase58String() + priceAssetIdStr.fromBase58String())
  let amountAssetId = parseAssetId(amountAssetIdStr)
  let priceAssetId = parseAssetId(priceAssetIdStr)
  let userRequestsNumber = kRequestsByOwner(userAddress).size() / queueItemSize

  strict checks = [
    i.payments.size() == 1 || throwErr("1 payment is required"),
    i.payments[0].assetId == unit || throwErr("invalid asset"),
    i.payments[0].amount == rewardAmount() || throwErr("invalid amount"),
    pairAllowed(amountAssetId, priceAssetId) || throwErr("pair is not allowed"),
    factoryAddress.getInteger(kRequestStatus(requestId)) == unit || throwErr("account is already exists"),
    userRequestsNumber < accountsLimit() || throwErr("accounts limit is " + accountsLimit().toString())
  ]

  # add request to queue or match with account immediately

  let (actions, factoryActions) = if (accountsQueue().size() == 0) then { # if the accounts queue is empty
    # then add request to requests queue
    ([
      ScriptTransfer(factoryAddress, rewardAmount(), unit)
    ],
    [
      factoryAddress.invoke("integerEntry", [kRequestStatus(requestId), REQUEST_STATUS_EMPTY], []),
      factoryAddress.invoke("binaryEntry", [kRequestsQueue(), requestsQueue() + requestId], [])
    ])
  } else { # if the accounts queue is not empty
    # then fullfill request
    let accountPublicKey = accountsQueue().take(queueItemSize)
    let accountAddress = addressFromPublicKey(accountPublicKey)
    let creatorAddress = addressFromPublicKey(
      factoryAddress.getBinary(
        kAccountCreatorPublicKey(accountAddress)
      ).valueOrErrorMessage(wrapErr("invalid creator public key"))
    )
    ([
      ScriptTransfer(creatorAddress, rewardAmount(), unit)
    ],
    [
      factoryAddress.invoke("binaryEntry", [kAccountsQueue(), accountsQueue().drop(queueItemSize)], []),
      factoryAddress.invoke("integerEntry", [kRequestStatus(requestId), REQUEST_STATUS_READY], []),
      factoryAddress.invoke("binaryEntry", [kRequestIdToAccountPublicKey(requestId), accountPublicKey], []),
      factoryAddress.invoke("stringEntry", [kAccountAddressToRequestId(accountAddress), requestId.toBase58String()], [])
    ])
  }

  (actions, factoryActions ++ [
    factoryAddress.invoke("binaryEntry", [kRequestOwnerPublicKey(requestId), callerPublicKey], []),
    factoryAddress.invoke("binaryEntry", [kRequestsByOwner(userAddress), requestsByOwner(userAddress) + requestId], []),
    factoryAddress.invoke("stringEntry", [kRequestAmountAssetId(requestId), amountAssetIdStr], []),
    factoryAddress.invoke("stringEntry", [kRequestPriceAssetId(requestId), priceAssetIdStr], [])
  ])
}

# called by account script
# additional fee is sent to recipient
# args: [creatorPublicKey]
@Callable(i)
func addAccount(callerPublicKey: ByteVector, args: List[String]) = {
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory()
  ]
  let creatorPublicKey = args[0].fromBase58String()
  let accountPublicKey = callerPublicKey
  let accountAddress = addressFromPublicKey(callerPublicKey)
  let creatorAddress = addressFromPublicKey(creatorPublicKey)

  strict checks = [
    factoryAddress.getBinary(kAccountCreatorPublicKey(accountAddress)) == unit || throwErr("account is already exists"),
    match scriptHash(accountAddress) {
      case b: ByteVector => b == blake2b256_32Kb(accountScript())
      case _ => false
    } || throwErr("invalid script")
  ]

  let (actions, factoryActions) = if (requestsQueue().size() == 0) then { # if the requests queue is empty
    # then add account to accounts queue
    (
      [],
      [
        factoryAddress.invoke("binaryEntry", [kAccountsQueue(), accountsQueue() + accountPublicKey], [])
      ]
    )
  } else { # if the requests queue is not empty
    # then fullfill next request
    let requestId = requestsQueue().take(queueItemSize)
    (
      [],
      [
        factoryAddress.invoke("integerEntry", [kRequestStatus(requestId), REQUEST_STATUS_READY], []),
        factoryAddress.invoke("binaryEntry", [kRequestIdToAccountPublicKey(requestId), accountPublicKey], []),
        factoryAddress.invoke("binaryEntry", [kRequestsQueue(), requestsQueue().drop(queueItemSize)], []),
        factoryAddress.invoke("stringEntry", [kAccountAddressToRequestId(accountAddress), requestId.toBase58String()], []),
        factoryAddress.invoke("transferWaves", [creatorAddress.bytes, rewardAmount()], [])
      ]
    )
  }

  (actions, factoryActions ++ [
    factoryAddress.invoke("binaryEntry", [kAccountCreatorPublicKey(accountAddress), creatorPublicKey], [])
  ])
}

# TODO: validate payment (payment asset id - usdt)
# args: [accountAddress]
@Callable(i)
func deposit(callerPublicKey: ByteVector, args: List[String]) = {
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory()
  ]
  let accountAddress = addressFromString(args[0]).valueOrErrorMessage(
    wrapErr("invalid account address")
  )
  let payment = i.payments[0]

  let actions = [
    ScriptTransfer(accountAddress, payment.amount, payment.assetId)
  ]

  let factoryActions = [
    factoryAddress.invoke(
      "integerEntry",
      [
        kDeposited(accountAddress),
        depositedOption(accountAddress).valueOrElse(0) + payment.amount
      ], []
    )
  ]

  (actions, factoryActions)
}

# TODO: validate asset id
# args: [accountAddress, amount, assetId]
@Callable(i)
func withdraw(callerPublicKey: ByteVector, args: List[String]) = {
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory()
  ]
  let userAddress = addressFromPublicKey(callerPublicKey)
  let accountAddress = addressFromString(args[0]).valueOrErrorMessage(
    wrapErr("invalid account address")
  )
  let amount = parseInt(args[1]).valueOrErrorMessage(
    wrapErr("invalid amount")
  )
  let assetId = parseAssetId(args[2])

  let invocations = [
    accountAddress.invoke("transferAsset", [userAddress.bytes, amount, assetId], [])
  ]

  (nil, invocations)
}

# TODO: validate owner
# args: [accountAddress, assetId, amount]
@Callable(i)
func borrow(callerPublicKey: ByteVector, args: List[String]) = {
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory()
  ]

  let accountAddress = addressFromString(args[0]).valueOrErrorMessage(
    wrapErr("invalid account address")
  )
  let assetId = parseAssetId(args[1])
  let amountRaw = parseInt(args[2])

  let deposited = depositedOption(accountAddress).valueOrElse(0)
  let (amountAssetId, priceAssetId) = getAssetsByAccountAddress(accountAddress)
  let currentPrice = getCurrentPrice(amountAssetId)
  let creditA = factoryAddress.getInteger(kCredit(accountAddress, amountAssetId)).valueOrElse(0)
  let creditB = factoryAddress.getInteger(kCredit(accountAddress, priceAssetId)).valueOrElse(0)
  let totalCredit = calcTotalCredit(creditA, creditB, currentPrice)
  let leverageDefault = 3
  let leverage = factoryAddress.getInteger(kLeverage(accountAddress)).valueOrElse(leverageDefault)
  let creditAvailable = calcCreditAvailable(deposited, leverage, totalCredit)

  # let factoryActions = [
  #   factoryAddress.invoke(
  #     "integerEntry",
  #     [
  #       kDeposited(accountAddress),
  #       depositedOption(accountAddress).valueOrElse(0) + payment.amount
  #     ], []
  #   )
  # ]

  (nil, [creditAvailable])
}

@Callable(i)
func repay(callerPublicKey: ByteVector, args: List[String]) = {
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory()
  ]

  (nil, unit)
}

# args: [amountAssetId, priceAssetId, allow]
@Callable(i)
func setPairAllowance(callerPublicKey: ByteVector, args: List[String]) = {
  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory(),
    callerPublicKey.mustAdmin()
  ]
  let amountAssetIdStr = args[0]
  let priceAssetIdStr = args[1]
  let allowStr = args[2]
  let amountAssetId = parseAssetId(amountAssetIdStr)
  let priceAssetId = parseAssetId(priceAssetIdStr)
  let allow = allowStr == "true"

  let invocations = [
    factoryAddress.invoke("booleanEntry", [kPairAllowed(amountAssetId, priceAssetId), allow], [])
  ]

  (nil, invocations)
}

# args: [assetId]
@Callable(i)
func addSyntheticAsset(callerPublicKey: ByteVector, args: List[String]) = {
  let baseAssetIdStr = args[0]
  let baseAssetId = parseAssetId(baseAssetIdStr)
  let syntheticAssetId = i.payments[0].assetId

  strict ckecks = [
    !shutdown || throwErr("not allowed"),
    i.caller.mustFactory(),
    callerPublicKey.mustAdmin(),
    factoryAddress.getString(kSyntheticAssetId(baseAssetId)) == unit || throwErr(
      "invalid base asset"
    ),
    i.payments.size() == 1 || throwErr(
      "invalid payments"
    ),
    factoryAddress.getString(kBaseAssetId(syntheticAssetId)) == unit || throwErr(
      "invalid synthetic asset"
    )
  ]

  let invocations = [
    factoryAddress.invoke("stringEntry", [kSyntheticAssetId(baseAssetId), assetIdToString(syntheticAssetId)], []),
    factoryAddress.invoke("stringEntry", [kBaseAssetId(syntheticAssetId), assetIdToString(baseAssetId)], [])
  ]

  (nil, invocations)
}

@Callable(i)
func doShutdown(callerPublicKey: ByteVector, args: List[String]) = {
  strict checks = [
    i.caller.mustFactory(),
    callerPublicKey.mustAdmin()
  ]

  let invocations = [
    factoryAddress.invoke("booleanEntry", [kShutdown, true], [])
  ]

  (nil, invocations)
}

@Verifier(tx)
func verify() = {
  if (factoryAddressOption.isDefined() && factoryAddress.getString(kMultisig).isDefined()) then {
    match factoryAddress.getString(kMultisig) {
      case multisig: String => {
        let statusKey = kStatus(this.toString(), tx.id.toBase58String())
        let status = multisig.addressFromStringValue().getBoolean(statusKey).valueOrElse(false)

        status
      }
      case _ => false
    }
  } else {
    sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
  }
}
