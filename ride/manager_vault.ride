{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
let contractFilename = "manager_vault.ride"

func throwErr(s: String) = {
  throw(contractFilename + ": " + s)
}

# Manager Public Key
func keyActiveManagerPublicKey() = makeString(["%s", "managerPublicKey"], SEP)
func keyPendingManagerPublicKey() = makeString(["%s", "pendingManagerPublicKey"], SEP)

# Set New Manager vote keys
func keySetNewManagerVotePrefix(managerPublicKey: String)          = makeString(["%s%s%s", "setManager", managerPublicKey], SEP)
func keySetNewManagerVote(managerPublicKey: String, admin: String) = makeString([keySetNewManagerVotePrefix(managerPublicKey), admin], SEP)
func getSetNewManagerVote(managerPublicKey: String, admin: String) = {
  getInteger(keySetNewManagerVote(managerPublicKey, admin)).valueOrElse(0)
}

# Deactivate Manager vote keys
func keyDeactivateManagerVotePrefix()        = makeString(["%s%s", "deactivateManager"], SEP)
func keyDeactivateManagerVote(admin: String) = makeString([keyDeactivateManagerVotePrefix(), admin], SEP)
func getDeactivateManagerVote(admin: String) = {
  getInteger(keyDeactivateManagerVote(admin)).valueOrElse(0)
}

# Activate Manager vote keys
func keyActivateManagerVotePrefix()        = makeString(["%s%s", "activateManager"], SEP)
func keyActivateManagerVote(admin: String) = makeString([keyActivateManagerVotePrefix(), admin], SEP)
func getActivateManagerVote(admin: String) = {
  getInteger(keyActivateManagerVote(admin)).valueOrElse(0)
}

# Admin List key
func keyAdminAdressList() = makeString(["%s", "adminAddressList"], SEP)

func pendingManagerPublicKeyOrUnit() = match keyPendingManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func getAdminsList() = {
  this.getString(keyAdminAdressList()).valueOrElse("").split(SEP)
}

func isInAdminList(address: String) = {
  match (getAdminsList().indexOf(address)) {
      case t:Int => true
      case _ => false
    }
}

# Generate List of keys with same prefix for all admins
func genVotesKeysHelper(a: (List[String], String), adminAddress: String) = {
  let (result, prefix) = a
  (result :+ makeString([prefix, adminAddress], SEP), prefix)
}
func genVotesKeys(keyPrefix: String) = {
  let adminList = keyAdminAdressList()
  FOLD<10>(getAdminsList(), ([], keyPrefix), genVotesKeysHelper)
}

# Count all votes for Prefix
func countVotesHelper(result: Int, voteKey: String) = {
  result + getInteger(voteKey).valueOrElse(0)
}
func countVotes(prefix: String) = {
  let votes = genVotesKeys(prefix)._1
  FOLD<10>(votes, 0, countVotesHelper)
}

# Generate DeleteEntry for all votes with Prefix
func clearVotesHelper(result: List[DeleteEntry], key: String) = {
  result :+ DeleteEntry(key) 
}
func getClearVotesEntries(prefix: String) = {
  let votes = genVotesKeys(prefix)._1
  FOLD<10>(votes, [], clearVotesHelper)
}

# Manager should confirm themself
@Callable(i)
func confirmManager() = {
  let pm = pendingManagerPublicKeyOrUnit()
  strict hasPM    = pm.isDefined() || "no pending manager".throwErr()
  strict checkPM  = i.callerPublicKey == pm.value() || "you are not pending manager".throwErr()

  [ StringEntry(keyActiveManagerPublicKey(), pm.value().toBase58String()) ]
}

# Vote for new Manager (min: 2 votes)
# Set pendingManagerPublicKey
# Manager should confirm or activate by vote
@Callable(i)
func voteForNewManger(newManagerPublicKey: String) = {
  let callerAddressString = toBase58String(i.caller.bytes)
  if (isInAdminList(callerAddressString)) then {
    if (getSetNewManagerVote(newManagerPublicKey, callerAddressString) == 1) then {
      throwErr("Address: " + callerAddressString + " NewManager: " + newManagerPublicKey + " voteForNewManger() you already voted")
    } else {
      let votes = countVotes(keySetNewManagerVotePrefix(newManagerPublicKey))
      if (votes + 1 >= 2) then {
        let clearVotesEntries = getClearVotesEntries(keySetNewManagerVotePrefix(newManagerPublicKey))
        clearVotesEntries ++ 
        [ StringEntry(keyPendingManagerPublicKey(), newManagerPublicKey) ]
      } else {
        [ IntegerEntry(keySetNewManagerVote(newManagerPublicKey, callerAddressString), 1)]
      }
    }
  } else { 
    throwErr("Address: " + callerAddressString + " not in Admin list")
  }
}

# Vote to Deactivate Manager (min: 1 vote)
# Clears managerPublicKey value
@Callable(i)
func deactivateManager() = {
  let callerAddressString = toBase58String(i.caller.bytes)
  if (isInAdminList(callerAddressString)) then {
    if (getDeactivateManagerVote(callerAddressString) == 1) then {
      throwErr("Address: " + callerAddressString + " deactivateManager() you already voted")
    } else {
      let votes = countVotes(keyDeactivateManagerVotePrefix())
      if (votes + 1 >= 1) then {
        let clearVotesEntries = getClearVotesEntries(keyDeactivateManagerVotePrefix())
        clearVotesEntries ++ 
        [ DeleteEntry(keyActiveManagerPublicKey()) ]
      } else {
        [ IntegerEntry(keyDeactivateManagerVote(callerAddressString), 1)]
      }
    }
  } else { 
    throwErr("Address: " + callerAddressString + " not in Admin list")
  }
}

# Vote to Activate Pending Manager (min: 1 vote)
# Copies pendingManagerPublicKey to managerPublicKey
@Callable(i)
func activateManager() = {
  let callerAddressString = toBase58String(i.caller.bytes)
  let pendingManagerString = getStringValue(keyPendingManagerPublicKey())
  if (isInAdminList(callerAddressString)) then {
    if (getActivateManagerVote(callerAddressString) == 1) then {
      throwErr("Address: " + callerAddressString + " activateManager() you already voted")
    } else {
      let votes = countVotes(keyActivateManagerVotePrefix())
      if (votes + 1 >= 2) then {
        let clearVotesEntries = getClearVotesEntries(keyActivateManagerVotePrefix())
        clearVotesEntries ++ 
        [ StringEntry(keyActiveManagerPublicKey(), pendingManagerString) ]
      } else {
        [ IntegerEntry(keyActivateManagerVote(callerAddressString), 1)]
      }
    }
  } else { 
    throwErr("Address: " + callerAddressString + " not in Admin list")
  }
}