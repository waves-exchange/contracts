{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# Required state entries:
# * "%s__factoryContract": String
# * "%s__usdnAssetId": String

let separator = "__"
let shareAssetDecimals = 8
let wavesString = "WAVES"

func wrapErr(msg: String) = ["lp_staking_pools.ride:", msg].makeString(" ").throw()
func throwErr(msg: String) = msg.wrapErr().throw()

func errKeyIsNotDefined(address: Address, key: String) = ["mandatory ", address.toString(), ".", key, " is not defined"].makeString("").wrapErr()
func getStrOrFail(address: Address, key: String) = address.getString(key).valueOrErrorMessage(address.errKeyIsNotDefined(key))
func getIntOrFail(address: Address, key: String) = address.getInteger(key).valueOrErrorMessage(address.errKeyIsNotDefined(key))

func parseAssetId(input: String) = {
  if (input == wavesString) then unit else input.fromBase58String()
}

func assetIdToString(input: ByteVector|Unit) = {
  if (input == unit) then wavesString else input.value().toBase58String()
}

func keyFactoryContract() = ["%s", "factoryContract"].makeString(separator)
func keyAssetsStoreContract() = ["%s", "assetsStoreContract"].makeString(separator)
func keyUsdnAssetId() = ["%s", "usdnAssetId"].makeString(separator)

func keyMinDelay() = ["%s", "minDelay"].makeString(separator)
func keyShareAssetId(baseAssetId: ByteVector|Unit) = {
  ["%s%s", baseAssetId.assetIdToString(), "shareAssetId"].makeString(separator)
}
func keyPeriod(baseAssetId: ByteVector|Unit) = {
  ["%s%s", baseAssetId.assetIdToString(), "period"].makeString(separator)
}
func keyBaseAssetAmountToConvert(baseAssetId: ByteVector|Unit) = {
  ["%s%s", baseAssetId.assetIdToString(), "baseAssetAmountToConvert"].makeString(separator)
}
func keyShareAssetAmountToConvert(baseAssetId: ByteVector|Unit) = {
  ["%s%s", baseAssetId.assetIdToString(), "shareAssetAmountToConvert"].makeString(separator)
}
func keyUserBaseAssetAmountToConvert(baseAssetId: ByteVector|Unit, userAddress: Address) = {
  ["%s%s%s", baseAssetId.assetIdToString(), userAddress.toString(), "baseAssetAmountToConvert"].makeString(separator)
}
func keyUserBaseAssetAmountToConvertPeriod(baseAssetId: ByteVector|Unit, userAddress: Address) = {
  ["%s%s%s%s", baseAssetId.assetIdToString(), userAddress.toString(), "baseAssetAmountToConvert", "period"].makeString(separator)
}
func keyUserShareAssetAmountToConvert(baseAssetId: ByteVector|Unit, userAddress: Address) = {
  ["%s%s%s", baseAssetId.assetIdToString(), userAddress.toString(), "shareAssetAmountToConvert"].makeString(separator)
}
func keyUserShareAssetAmountToConvertPeriod(baseAssetId: ByteVector|Unit, userAddress: Address) = {
  ["%s%s%s%s", baseAssetId.assetIdToString(), userAddress.toString(), "shareAssetAmountToConvert", "period"].makeString(separator)
}
func keyPriceLast(baseAssetId: ByteVector|Unit) = {
  ["%s%s%s", baseAssetId.assetIdToString(), "price", "last"].makeString(separator)
}
func keyPricePeriod(baseAssetId: ByteVector|Unit, period: Int) = {
  ["%s%s%s", baseAssetId.assetIdToString(), "price", period.toString()].makeString(separator)
}

func keyManagerPublicKey() = "%s__managerPublicKey"
func keyPendingManagerPublicKey() = "%s__pendingManagerPublicKey"

func managerPublicKeyOrUnit() = match keyManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func pendingManagerPublicKeyOrUnit() = match keyPendingManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func mustManager(i: Invocation) = {
  let pd = "permission denied".throwErr()

  match managerPublicKeyOrUnit() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

let factoryContract = this.getStrOrFail(keyFactoryContract()).addressFromStringValue()
let assetsStoreContract = factoryContract.getStrOrFail(keyAssetsStoreContract()).addressFromStringValue()
let usdnAssetId = this.getStrOrFail(keyUsdnAssetId()).parseAssetId()

let minDelayDefault = 1440
let minDelay = this.getInteger(keyMinDelay()).valueOrElse(minDelayDefault)

func getPoolInfo(amountAssetId: ByteVector|Unit) = {
  let amountAssetIdStr = amountAssetId.assetIdToString()
  let priceAssetIdStr = usdnAssetId.assetIdToString()

  func keyMappingsBaseAsset2internalId(baseAssetStr: String) = {
    "%s%s%s__mappings__baseAsset2internalId__" + baseAssetStr
  }
  func keyMappingPoolAssetsToPoolContractAddress(internalAmountAssetIdStr: Int, internalPriceAssetIdStr: Int) = {
    "%d%d%s%s__" + internalAmountAssetIdStr.toString() + "__" + internalPriceAssetIdStr.toString() + "__mappings__poolAssets2PoolContract"
  }
  func keyMappingPoolContractToLpAsset(poolContractAddress: String) = {
    "%s%s%s__" + poolContractAddress + "__mappings__poolContract2LpAsset"
  }

  let amountAssetInternalIdOption = factoryContract.getInteger(amountAssetIdStr.keyMappingsBaseAsset2internalId())
  let priceAssetInternalIdOption = factoryContract.getInteger(priceAssetIdStr.keyMappingsBaseAsset2internalId())
  let poolContractAddressOption = factoryContract.getString(keyMappingPoolAssetsToPoolContractAddress(amountAssetInternalIdOption.value(), priceAssetInternalIdOption.value()))
  let lpAssetIdOption = factoryContract.getString(poolContractAddressOption.value().keyMappingPoolContractToLpAsset())
  let poolExists = amountAssetInternalIdOption.isDefined() && priceAssetInternalIdOption.isDefined() && poolContractAddressOption.isDefined()

  let poolInfo = if (poolExists) then {
    (poolContractAddressOption.value().addressFromStringValue(), lpAssetIdOption.value().parseAssetId())
  } else unit

  poolInfo
}

@Callable(i)
func setManager(pendingManagerPublicKey: String) = {
  strict checkCaller = i.mustManager()
  strict checkManagerPublicKey = pendingManagerPublicKey.fromBase58String()

  [
    StringEntry(keyPendingManagerPublicKey(), pendingManagerPublicKey)
  ]
}

@Callable(i)
func confirmManager() = {
  let pm = pendingManagerPublicKeyOrUnit()
  strict hasPM = pm.isDefined() || "no pending manager".throwErr()
  strict checkPM = i.callerPublicKey == pm.value() || "you are not pending manager".throwErr()

  [
    StringEntry(keyManagerPublicKey(), pm.value().toBase58String()),
    DeleteEntry(keyPendingManagerPublicKey())
  ]
}

@Callable(i)
func create(
  baseAssetIdStr: String,
  shareAssetName: String,
  shareAssetDescription: String,
  shareAssetLogo: String
) = {
  let shareAssetLabel = "LP_STAKING_POOLS"
  let baseAssetId = baseAssetIdStr.parseAssetId()

  strict checks = [
    i.mustManager(),
    baseAssetId.getPoolInfo().isDefined() || "invalid base asset".throwErr()
  ]

  let shareAssetIssueAmount = 1
  let shareAssetIssueAction = Issue(shareAssetName, shareAssetDescription, shareAssetIssueAmount, shareAssetDecimals, true)
  let shareAssetId = shareAssetIssueAction.calculateAssetId()
  let shareAssetBurnAction = Burn(shareAssetId, shareAssetIssueAmount)
  let shareAssetIdStr = shareAssetId.toBase58String()
  strict createOrUpdate = assetsStoreContract.invoke("createOrUpdate", [shareAssetIdStr, shareAssetLogo, false], [])
  strict addLabel = assetsStoreContract.invoke("addLabel", [shareAssetIdStr, shareAssetLabel], [])
  # write current period 0 for base asset

  ([
    shareAssetIssueAction,
    shareAssetBurnAction,
    StringEntry(baseAssetId.keyShareAssetId(), shareAssetIdStr)
  ], unit)
}

@Callable(i)
func put() = {
  let pmt = if (i.payments.size() == 1) then i.payments[0] else "exactly 1 payment is expected".throwErr()
  strict checks = [
    pmt.assetId.keyShareAssetId().getString().isDefined() || "invalid asset".throwErr()
  ]
  let (poolAddress, lpAssetId) = pmt.assetId.getPoolInfo().valueOrErrorMessage("invalid asset".wrapErr())
  # increase baseAssetAmountToConvert for current period
  # call claimShareAsset if userBaseAssetAmountToConvertPeriod ≥ current period
  # increase userBaseAssetAmountToConvert
  # write userBaseAssetAmountToConvertPeriod (current period)

  ([], unit)
}

@Callable(i)
func claimShareAsset() = {
  # current period should be ≥ userBaseAssetAmountToConvertPeriod
  # claim share asset with the last price (base asset / share asset ?)
  # reset userBaseAssetAmountToConvert
  ([], unit)
}

@Callable(i)
func get() = {
  # call claimBaseAsset if there's pricePeriod for userShareAssetAmountToConvertPeriod
  # increase shareAssetAmountToConvert
  # increase userShareAssetAmountToConvert
  # save next period in userShareAssetAmountToConvertPeriod
    # this period's price will be used in claimBaseAsset
  ([], unit)
}

@Callable(i)
func claimBaseAsset() = {
  # burn share assets
  # claim base asset with the price for userShareAssetAmountToConvertPeriod
  # reset userShareAssetAmountToConvert
  ([], unit)
}

@Callable(i)
func finalize(baseAssetId: String) = {
  # check minDelay
  # update period
  # update price last and price for period
  # call staking.claimWx
  # call gwx_reward.claimReward
  # use wx on the balance (balance, not variable, because there could be auto-claims)
    # 50% lock in boosting
    # 50% convert to base asset via wx/usdn pool
  # convert shareAssetAmountToConvert to lp tokens using price (share asset / lp asset ?)
  # unstake and get lp, calculate price for claimBaseAsset (base asset / share asset)
  # put and stake baseAssetAmountToConvert
  # calculate and save new price (share asset / lp asset)
  # reset baseAssetAmountToConvert
  # reset shareAssetAmountToConvert
  ([], unit)
}

@Verifier(tx)
func verify() = {
  let targetPublicKey = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
}
