{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# Required state entries:
# * "%s__factoryContract": String
# * "%s__usdnAssetId": String

let separator = "__"
let shareAssetDecimals = 8
let wavesString = "WAVES"

func wrapErr(msg: String) = ["lp_staking_pools.ride:", msg].makeString(" ").throw()
func throwErr(msg: String) = msg.wrapErr().throw()

func errKeyIsNotDefined(address: Address, key: String) = ["mandatory ", address.toString(), ".", key, " is not defined"].makeString("").wrapErr()
func getStrOrFail(address: Address, key: String) = address.getString(key).valueOrErrorMessage(address.errKeyIsNotDefined(key))
func getIntOrFail(address: Address, key: String) = address.getInteger(key).valueOrErrorMessage(address.errKeyIsNotDefined(key))

func parseAssetId(input: String) = {
  if (input == wavesString) then unit else input.fromBase58String()
}

func assetIdToString(input: ByteVector|Unit) = {
  if (input == unit) then wavesString else input.value().toBase58String()
}

func keyFactoryContract() = "%s__factoryContract"
func keyAssetsStoreContract() = "%s__assetsStoreContract"
func keyUsdnAssetId() = "%s__usdnAssetId"

func keyMinDelay() = "%s__minDelay"
func keyShareAssetId(baseAssetId: ByteVector|Unit) = {
  ["%s%s", baseAssetId.assetIdToString(), "shareAssetId"].makeString(separator)
}

func keyManagerPublicKey() = "%s__managerPublicKey"
func keyPendingManagerPublicKey() = "%s__pendingManagerPublicKey"

func managerPublicKeyOrUnit() = match keyManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func pendingManagerPublicKeyOrUnit() = match keyPendingManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func mustManager(i: Invocation) = {
  let pd = "permission denied".throwErr()

  match managerPublicKeyOrUnit() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

let factoryContract = this.getStrOrFail(keyFactoryContract()).addressFromStringValue()
let assetsStoreContract = factoryContract.getStrOrFail(keyAssetsStoreContract()).addressFromStringValue()
let usdnAssetId = this.getStrOrFail(keyUsdnAssetId()).parseAssetId()

let minDelayDefault = 1440
let minDelay = this.getInteger(keyMinDelay()).valueOrElse(minDelayDefault)

func getPoolInfo(amountAssetId: ByteVector|Unit) = {
  let amountAssetIdStr = amountAssetId.assetIdToString()
  let priceAssetIdStr = usdnAssetId.assetIdToString()

  func keyMappingsBaseAsset2internalId(baseAssetStr: String) = {
    "%s%s%s__mappings__baseAsset2internalId__" + baseAssetStr
  }
  func keyMappingPoolAssetsToPoolContractAddress(internalAmountAssetIdStr: Int, internalPriceAssetIdStr: Int) = {
    "%d%d%s%s__" + internalAmountAssetIdStr.toString() + "__" + internalPriceAssetIdStr.toString() + "__mappings__poolAssets2PoolContract"
  }
  func keyMappingPoolContractToLpAsset(poolContractAddress: String) = {
    "%s%s%s__" + poolContractAddress + "__mappings__poolContract2LpAsset"
  }

  let amountAssetInternalIdOption = factoryContract.getInteger(amountAssetIdStr.keyMappingsBaseAsset2internalId())
  let priceAssetInternalIdOption = factoryContract.getInteger(priceAssetIdStr.keyMappingsBaseAsset2internalId())
  let poolContractAddressOption = factoryContract.getString(keyMappingPoolAssetsToPoolContractAddress(amountAssetInternalIdOption.value(), priceAssetInternalIdOption.value()))
  let lpAssetIdOption = factoryContract.getString(poolContractAddressOption.value().keyMappingPoolContractToLpAsset())
  let poolExists = amountAssetInternalIdOption.isDefined() && priceAssetInternalIdOption.isDefined() && poolContractAddressOption.isDefined()

  let poolInfo = if (poolExists) then {
    (poolContractAddressOption.value().addressFromStringValue(), lpAssetIdOption.value().parseAssetId())
  } else unit

  poolInfo
}

@Callable(i)
func setManager(pendingManagerPublicKey: String) = {
  strict checkCaller = i.mustManager()
  strict checkManagerPublicKey = pendingManagerPublicKey.fromBase58String()

  [
    StringEntry(keyPendingManagerPublicKey(), pendingManagerPublicKey)
  ]
}

@Callable(i)
func confirmManager() = {
  let pm = pendingManagerPublicKeyOrUnit()
  strict hasPM = pm.isDefined() || "no pending manager".throwErr()
  strict checkPM = i.callerPublicKey == pm.value() || "you are not pending manager".throwErr()

  [
    StringEntry(keyManagerPublicKey(), pm.value().toBase58String()),
    DeleteEntry(keyPendingManagerPublicKey())
  ]
}

@Callable(i)
func create(
  baseAssetIdStr: String,
  shareAssetName: String,
  shareAssetDescription: String,
  shareAssetLogo: String
) = {
  let shareAssetLabel = "LP_STAKING_POOLS"
  let baseAssetId = baseAssetIdStr.parseAssetId()

  strict checks = [
    i.mustManager(),
    baseAssetId.getPoolInfo().isDefined() || "invalid base asset".throwErr()
  ]

  let shareAssetIssueAmount = 1
  let shareAssetIssueAction = Issue(shareAssetName, shareAssetDescription, shareAssetIssueAmount, shareAssetDecimals, true)
  let shareAssetId = shareAssetIssueAction.calculateAssetId()
  let shareAssetBurnAction = Burn(shareAssetId, shareAssetIssueAmount)
  let shareAssetIdStr = shareAssetId.toBase58String()
  strict createOrUpdate = assetsStoreContract.invoke("createOrUpdate", [shareAssetIdStr, shareAssetLogo, false], [])
  strict addLabel = assetsStoreContract.invoke("addLabel", [shareAssetIdStr, shareAssetLabel], [])

  ([
    shareAssetIssueAction,
    shareAssetBurnAction,
    StringEntry(baseAssetId.keyShareAssetId(), shareAssetIdStr)
  ], unit)
}
 
# Внести средства
# Средства отправляются в соответствующий пул с autoStake = true во время финализации
# Возможность получить lp токены появится только после финализации
# Записать сумму, внесенную в текущий расчетный период, но пока не доступную к обмену на share токен
# Увеличить общую сумму внесенных в текущий период base asset
# Вызвать claimShareAsset, чтобы упростить учет доступных к выводу средств
@Callable(i)
func put() = {
  strict checks = [
    i.payments.size() == 1 || "exactly 1 payment is expected".throwErr()
  ]
  let pmt = i.payments[0]
  let (poolAddress, lpAssetId) = pmt.assetId.getPoolInfo().valueOrErrorMessage("invalid asset".wrapErr())

  ([], unit)
}
 
# Получить доступные к выводу share токены
# Обнулить сумму, внесенную в предыдущий расчетный период
# Обменять share asset на base asset
@Callable(i)
func claimShareAsset() = {
  ([], unit)
}
 
# Запрос на вывод средств
# Записать количество share asset, отправленных пользователем и увеличить общее количество
# Возможность получить средства появится после финализации расчетного периода
# Цену, по которой пользователь сможет вывести средства, надо сохранить
# Сохранить номер периода, цена которого будет использована при вызове claimBaseAsset
# Вызвать claimBaseAsset, чтобы забрать запрошенные в предыдущий раз средства
@Callable(i)
func get() = {
  ([], unit)
}
 
# Вывод средств
# Сжечь заблокированные share asset
@Callable(i)
func claimBaseAsset() = {
  ([], unit)
}
 
# Финализация расчетного периода
# Клейм и стейкинг/обмен WX
@Callable(i)
func finalize(baseAssetId: String) = {
  ([], unit)
}

@Verifier(tx)
func verify() = {
  let targetPublicKey = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
}
