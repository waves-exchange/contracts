{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let USDT = "34N9YcEETLWn93qYQ64EsP1x89tSruJU44RrEMSXXEPJ"
let USDN = "DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p"
let idUSDN = USDN.fromBase58String()
let idUSDT = USDT.fromBase58String()
let withdrawDelay = 1460
let decimalPartUSDN = 1000000
let decimalPartUSDT = 1000000
let minimalAmountToSwapUSDT = 10000*decimalPartUSDN
let minimalAmountToSwapUSDN = 10000*decimalPartUSDT


func collectKey(address: String, amountToSwapInKey:Int, allowToWithdrawHeight:Int) = {
    makeString([address, "WITHDRAW", toString(amountToSwapInKey), "HEIGHT", toString(allowToWithdrawHeight)], "_")
}

func collectBalanceKey(address: String) = {
    makeString([address, "balance"], "_")
}

func collectBalanceKeyWithFee(address: String) = {
    makeString([address, "balance_with_fee"], "_")
}

func usdtToUsdnAssetError() = {
    throw("To swap USDT to USDN you need attach payment in USDT")
}

func usdnToUsdtAssetError() = {
    throw("To swap USDN to USDT you need attach payment in USDN")
}

func usdtToUsdnLowLimitError() = {
    throw("you can swap at least " + toString(minimalAmountToSwapUSDT / decimalPartUSDT) + " tokens")
}

func abs(n: Int) = {
    if (n < 0) then n * -1 else n
}

func getWithoutFeeWithdraw(amount: Int, balanceWithoutFee: Int) = min([amount, balanceWithoutFee])

func getListElementOrDefault(list: List[String], index: Int, default: String) = {
    if (size(list) > index) then getElement(list, index) else default
}

func currentWithdrawals(address: String, amount: Int) = {
    let balanceKey = collectBalanceKey(address)
    let balanceWithFeeKey = collectBalanceKeyWithFee(address)

    let currentClientBalance = this.getInteger(balanceKey).valueOrElse(0)
    let currentClientBalanceWithFee  = this.getInteger(balanceWithFeeKey).valueOrElse(0)
    let userBalance = currentClientBalance + currentClientBalanceWithFee

    if (userBalance < amount || amount < minimalAmountToSwapUSDN) then throw("Swap amount fail, amount is to small or to big.") else

    let toWithdrawWithoutFee = getWithoutFeeWithdraw(amount, currentClientBalance)
    let toWithdrawWithFee = amount - toWithdrawWithoutFee
    let fee = toWithdrawWithFee / 100 * 2

    [toWithdrawWithoutFee, toWithdrawWithFee, fee]
}


@Callable(invoke)
func swapUSDTtoUSDN() =   {
    let balanceKey = collectBalanceKeyWithFee(invoke.caller.toString())
    let payment = value(invoke.payments[0])

    if (payment.assetId != idUSDT) then usdtToUsdnAssetError() else

    let amount = payment.amount
    let fee = amount / 100 * 2
    let currentClientBalanceUSDT = this.getInteger(balanceKey).valueOrElse(0)

    if (amount < minimalAmountToSwapUSDT) then usdtToUsdnLowLimitError() else

    [
        IntegerEntry(balanceKey, currentClientBalanceUSDT + amount),
        ScriptTransfer(invoke.caller, amount - fee, idUSDN)
    ]
}

@Callable(invoke)
func initializationUSDNtoUSDTswap() = {
    let payment = value(invoke.payments[0])
    let address = invoke.caller.toString()

    if (payment.assetId != idUSDN) then usdnToUsdtAssetError() else

    let amount = payment.amount

    let balanceKey = collectBalanceKey(address)
    let balanceWithFeeKey = collectBalanceKeyWithFee(address)

    let currentClientBalance = this.getInteger(balanceKey).valueOrElse(0)
    let currentClientBalanceWithFee  = this.getInteger(balanceWithFeeKey).valueOrElse(0)
    let userBalance = currentClientBalance + currentClientBalanceWithFee

    let data = currentWithdrawals(invoke.caller.toString(), amount)
    let toWithdrawWithoutFee = getElement(data, 0).valueOrErrorMessage("Wrong 'currentWithdrawals' method!")
    let toWithdrawWithFee = getElement(data, 1).valueOrErrorMessage("Wrong 'currentWithdrawals' method!")
    let fee = getElement(data, 2).valueOrErrorMessage("Wrong 'currentWithdrawals' method!")
    let total = toWithdrawWithFee + toWithdrawWithoutFee - fee

    let allowToWithDrawHeight = height + withdrawDelay

    if this.getString(collectKey(invoke.caller.toString(), amount, allowToWithDrawHeight)).isDefined() then throw("You have already started withdrawal process, wait next block.") else

    [
        IntegerEntry(balanceKey, currentClientBalance - toWithdrawWithoutFee),
        IntegerEntry(balanceWithFeeKey, currentClientBalanceWithFee - toWithdrawWithFee),
        StringEntry(collectKey(invoke.caller.toString(), amount, allowToWithDrawHeight), makeString(["not_withdrawn", toString(amount - fee)], "_"))
    ]
}


@Callable(invoke)
func swapUSDNtoUSDT(amount: Int, heightInKey: Int) =   {
        let key = collectKey(invoke.caller.toString(), amount, heightInKey)
        let withdrawnInfo = this.getString(key).valueOrErrorMessage("This key doesn't exists "+ key + " at address  " + toString(this))
        let toWithdraw = getListElementOrDefault(split(withdrawnInfo, "_"), 2, toString(amount))

        if height >= heightInKey && contains(withdrawnInfo, "not_withdrawn") then
            [
                DeleteEntry(key),
                ScriptTransfer(invoke.caller, parseInt(toWithdraw).valueOrErrorMessage("Wrong withdraw data!"), idUSDT)
            ]

        else throw("Withdrawal is possible after "+toString(heightInKey)+" height or you have already withdrawn USDT.")
}

@Verifier(tx)
func verify () = {
  sigVerify(tx.bodyBytes, tx.proofs[0], fromBase58String("2Cbd8ozG7A1RyRNC3nNnZgHu7Ru4K3JCfpyPkhqr9zxq"))
}
