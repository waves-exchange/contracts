{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let withdrawDelay = 1460
let decimalPartUSDN = 1000000
let decimalPartUSDT = 1000000
let minimalAmountToSwapUSDT = 10000*decimalPartUSDN
let minimalAmountToSwapUSDN = 10000*decimalPartUSDT

func keyManagerPublicKey() = "%s__managerPublicKey"
func keyPendingManagerPublicKey() = "%s__pendingManagerPublicKey"

func keyUsdtAssetId() = "%s__USDT";
func keyUsdnAssetId() = "%s__USDN";
let idUSDN = keyUsdtAssetId().fromBase58String()
let idUSDT = keyUsdnAssetId().fromBase58String()

func constructor(usdtAssetId: String, usdnAssetId: String){
  [
    StringEntry(keyUsdtAssetId(), usdtAssetId);
    StringEntry(keyUsdnAssetId(), usdnAssetId);
  ]
}

func managerPublicKeyOrUnit() = match keyManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func pendingManagerPublicKeyOrUnit() = match keyPendingManagerPublicKey().getString() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func collectKey(address: String, amountToSwapInKey:Int, allowToWithdrawHeight:Int) = {
    makeString([address, "WITHDRAW", toString(amountToSwapInKey), "HEIGHT", toString(allowToWithdrawHeight)], "_")
}

func collectBalanceKey(address: String) = {
    makeString([address, "balance"], "_")
}

func collectBalanceKeyWithFee(address: String) = {
    makeString([address, "balance_with_fee"], "_")
}

func usdtToUsdnAssetError() = {
    throw("To swap USDT to USDN you need attach payment in USDT")
}

func usdnToUsdtAssetError() = {
    throw("To swap USDN to USDT you need attach payment in USDN")
}

func usdtToUsdnLowLimitError() = {
    throw("you can swap at least " + toString(minimalAmountToSwapUSDT / decimalPartUSDT) + " tokens")
}

func abs(n: Int) = {
    if (n < 0) then n * -1 else n
}

func getWithoutFeeWithdraw(amount: Int, balanceWithoutFee: Int) = min([amount, balanceWithoutFee])

func getListElementOrDefault(list: List[String], index: Int, default: String) = {
    if (size(list) > index) then getElement(list, index) else default
}

func currentWithdrawals(address: String, amount: Int) = {
    let balanceKey = collectBalanceKey(address)
    let balanceWithFeeKey = collectBalanceKeyWithFee(address)

    let currentClientBalance = this.getInteger(balanceKey).valueOrElse(0)
    let currentClientBalanceWithFee  = this.getInteger(balanceWithFeeKey).valueOrElse(0)
    let userBalance = currentClientBalance + currentClientBalanceWithFee

    if (userBalance < amount || amount < minimalAmountToSwapUSDN) then throw("Swap amount fail, amount is to small or to big.") else

    let toWithdrawWithoutFee = getWithoutFeeWithdraw(amount, currentClientBalance)
    let toWithdrawWithFee = amount - toWithdrawWithoutFee
    let fee = toWithdrawWithFee / 100 * 2

    [toWithdrawWithoutFee, toWithdrawWithFee, fee]
}

func mustManager(i: Invocation) = {
  let pd = "Permission denied".throw()

  match managerPublicKeyOrUnit() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

@Callable(invoke)
func swapUSDTtoUSDN() =   {
    let balanceKey = collectBalanceKeyWithFee(invoke.caller.toString())
    let payment = value(invoke.payments[0])

    if (payment.assetId != idUSDT) then usdtToUsdnAssetError() else

    let amount = payment.amount
    let fee = amount / 100 * 2
    let currentClientBalanceUSDT = this.getInteger(balanceKey).valueOrElse(0)

    if (amount < minimalAmountToSwapUSDT) then usdtToUsdnLowLimitError() else

    [
        IntegerEntry(balanceKey, currentClientBalanceUSDT + amount),
        ScriptTransfer(invoke.caller, amount - fee, idUSDN)
    ]
}

@Callable(invoke)
func initializationUSDNtoUSDTswap() = {
    let payment = value(invoke.payments[0])
    let address = invoke.caller.toString()

    if (payment.assetId != idUSDN) then usdnToUsdtAssetError() else

    let amount = payment.amount

    let balanceKey = collectBalanceKey(address)
    let balanceWithFeeKey = collectBalanceKeyWithFee(address)

    let currentClientBalance = this.getInteger(balanceKey).valueOrElse(0)
    let currentClientBalanceWithFee  = this.getInteger(balanceWithFeeKey).valueOrElse(0)
    let userBalance = currentClientBalance + currentClientBalanceWithFee

    let data = currentWithdrawals(invoke.caller.toString(), amount)
    let toWithdrawWithoutFee = getElement(data, 0).valueOrErrorMessage("Wrong 'currentWithdrawals' method!")
    let toWithdrawWithFee = getElement(data, 1).valueOrErrorMessage("Wrong 'currentWithdrawals' method!")
    let fee = getElement(data, 2).valueOrErrorMessage("Wrong 'currentWithdrawals' method!")
    let total = toWithdrawWithFee + toWithdrawWithoutFee - fee

    let allowToWithDrawHeight = height + withdrawDelay

    if this.getString(collectKey(invoke.caller.toString(), amount, allowToWithDrawHeight)).isDefined() then throw("You have already started withdrawal process, wait next block.") else

    [
        IntegerEntry(balanceKey, currentClientBalance - toWithdrawWithoutFee),
        IntegerEntry(balanceWithFeeKey, currentClientBalanceWithFee - toWithdrawWithFee),
        StringEntry(collectKey(invoke.caller.toString(), amount, allowToWithDrawHeight), makeString(["not_withdrawn", toString(amount - fee)], "_"))
    ]
}

@Callable(invoke)
func swapUSDNtoUSDT(amount: Int, heightInKey: Int) =   {
        let key = collectKey(invoke.caller.toString(), amount, heightInKey)
        let withdrawnInfo = this.getString(key).valueOrErrorMessage("This key doesn't exists "+ key + " at address  " + toString(this))
        let toWithdraw = getListElementOrDefault(split(withdrawnInfo, "_"), 2, toString(amount))

        if height >= heightInKey && contains(withdrawnInfo, "not_withdrawn") then
            [
                DeleteEntry(key),
                ScriptTransfer(invoke.caller, parseInt(toWithdraw).valueOrErrorMessage("Wrong withdraw data!"), idUSDT)
            ]

        else throw("Withdrawal is possible after "+toString(heightInKey)+" height or you have already withdrawn USDT.")
}

@Callable(i)
func setManager(pendingManagerPublicKey: String) = {
  strict checkCaller = i.mustManager()
  strict checkManagerPublicKey = pendingManagerPublicKey.fromBase58String()

  [StringEntry(keyPendingManagerPublicKey(), pendingManagerPublicKey)]
}

@Callable(i)
func confirmManager() = {
  let pm = pendingManagerPublicKeyOrUnit()
  strict hasPM = pm.isDefined() || throw("No pending manager")
  strict checkPM = i.callerPublicKey == pm.value() || throw("You are not pending manager")

  [
    StringEntry(keyManagerPublicKey(), pm.value().toBase58String()),
    DeleteEntry(keyPendingManagerPublicKey())
  ]
}

@Verifier(tx)
func verify () = {
  let targetPublicKey = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], fromBase58String("2Cbd8ozG7A1RyRNC3nNnZgHu7Ru4K3JCfpyPkhqr9zxq"))
}